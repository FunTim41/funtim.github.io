
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>funtim</title>
    <meta name="author" content="XH" />
    <meta name="description" content="ddd" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>FUNTIM</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;FUNTIM</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>funtim</h1>
                <h3>hello</h3>
                <h5>ddd</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/12/28/22%E6%9B%B2%E9%9D%A2/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/CHS/?guid=GUID-064E828D-83B8-4671-9F82-C189377DDAE3">Surfaces</a></h1><p>surface类表示表面的数学表示。</p>
<p>surface类不是从GeometryObject类派生的，并且不以边或边循环为边界。Revit中的有界曲面由Face类表示。</p>
<p>Surface是更具体的曲面的基类：</p>
<ul>
<li>Plane   平面</li>
<li>CylindricalSurface   圆柱形表面</li>
<li>ConicalSurface   圆锥面</li>
<li>RuledSurface   规则曲面</li>
<li>RevolvedSurface   旋转曲面</li>
<li>HermiteSurface   Hermite曲面</li>
</ul>
<p>这些子类包含Create（）方法和只读属性，适用于构造导入几何图形。有关在几何体创建中使用曲面的示例，请参见DirectShape主题。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/22%E6%9B%B2%E9%9D%A2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/21%E6%A5%BC%E6%A2%AF%E5%92%8C%E6%89%B6%E6%89%8B/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="楼梯和扶手"><a href="#楼梯和扶手" class="headerlink" title="楼梯和扶手"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Stairs_and_Railings_html">楼梯和扶手</a></h1><p>Autodesk.Revit.DB.Architecture命名空间中的Revit API中的类允许访问楼梯和相关构件（如平台和梯段）。可以使用Revit API创建或修改楼梯。Stairs类表示“由构件”创建的楼梯。不能在API中将通过草图创建的楼梯图元作为楼梯对象进行访问。静态方法Stairs.IsByComponent（）可用于确定ElementId是否表示由构件创建的楼梯。</p>
<p> 本节中的页面</p>
<ul>
<li>创建和编辑楼梯</li>
<li>扶手</li>
<li>楼梯注释</li>
<li>楼梯构件</li>
</ul>
<h2 id="创建和编辑楼梯"><a href="#创建和编辑楼梯" class="headerlink" title="创建和编辑楼梯"></a>创建和编辑楼梯</h2><p><strong>StairsEditScope</strong></p>
<p>与Revit文档中其他类型的元素一样，编辑楼梯和楼梯构件需要事务处理。但是，若要创建新构件（如梯段和平台）或创建新楼梯本身，则必须使用Autodesk.Revit.DB.StairsEditScope对象，该对象支持楼梯编辑任务。</p>
<p>StairsEditScope的作用类似于TransactionGroup。启动StairsEditScope后，可以启动事务并编辑楼梯。在StairsEditScope中创建的单个事务不会出现在撤消菜单中。在编辑模式下提交的所有事务将被合并为一个事务，该事务的名称由传递给 StairsEditScope 构造函数的参数指定。</p>
<p>StairsEditScope有两个Start方法。获取现有Stairs对象的ElementId，并为其启动楼梯编辑会话。第二个Start方法采用底部标高和顶部标高的ElementId，并在指定标高中创建具有默认楼梯类型的新空楼梯元素，然后为新楼梯启动楼梯编辑模式。</p>
<p>将梯段和平台添加到楼梯并完成编辑后，请调用 StairsEditScope.Commit() 方法结束楼梯编辑模式。</p>
<p><strong>添加梯段</strong></p>
<ul>
<li>StairsRun类有三个用于为Stairs对象创建新梯段的静态方法：<ul>
<li><strong>CreateSketchedRun</strong> - 通过提供一组边界曲线和踢面曲线来创建草图梯段。</li>
<li><strong>CreateStraightRun</strong> - 创建直线梯段。</li>
<li><strong>CreateSpiralRun</strong> - 通过提供圆心、起始角度和夹角来创建螺旋梯段。</li>
</ul>
</li>
</ul>
<p><strong>添加平台</strong></p>
<p>可以在两个梯段之间添加自动平台或草图平台。静态方法StairsLanding. Canadian AutomaticLanding（）将检查两个楼梯梯段是否满足创建自动平台的限制。静态StairsLanding. random AutomaticLanding（）方法将返回在两个楼梯梯段之间创建的所有平台的Id。</p>
<p>静态StairsLanding. RightSketchedLanding方法通过提供平台的闭合边界曲线，在两个梯段之间创建自定义平台。基本高程的双精度值是CreateSketchedLanding方法的输入参数之一。标高有以下限制：</p>
<ul>
<li>底部高程相对于楼梯的底部高程。</li>
<li>底部高程将自动舍入为踢面高度的倍数。</li>
<li>基础标高应等于或大于踢面高度的一半。</li>
</ul>
<p><strong>例子</strong></p>
<p>下面的示例将创建一个新的Stairs对象、两个梯段（一个为草图梯段，一个为直线梯段）以及它们之间的平台。</p>
<p>代码区域：创建楼梯、楼梯平台和平台</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FailurePreprocessor class required for StairsEditScope</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StairsFailurePreprocessor</span> : <span class="title">IFailuresPreprocessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FailureProcessingResult <span class="title">PreprocessFailures</span>(<span class="params">FailuresAccessor failuresAccessor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use default failure processing</span></span><br><span class="line">        <span class="keyword">return</span> FailureProcessingResult.Continue; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">CreateStairs</span>(<span class="params">Document document, Level levelBottom, Level levelTop</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId newStairsId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (StairsEditScope newStairsScope = <span class="keyword">new</span> StairsEditScope(document, <span class="string">&quot;New Stairs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newStairsId = newStairsScope.Start(levelBottom.Id, levelTop.Id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction stairsTrans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Runs and Landings to Stairs&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            stairsTrans.Start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a sketched run for the stairs</span></span><br><span class="line">            IList bdryCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList riserCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList pathCurves = <span class="keyword">new</span> List();</span><br><span class="line">            XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// boundaries</span></span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt1, pnt2));</span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt3, pnt4));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// riser curves</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> riserNum = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> ii = <span class="number">0</span>; ii &lt;= riserNum; ii++)</span><br><span class="line">            &#123;</span><br><span class="line">                XYZ end0 = (pnt1 + pnt2)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end1 = (pnt3 + pnt4)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end2 = <span class="keyword">new</span> XYZ(end1.X, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                riserCurves.Add(Line.CreateBound(end0, end2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//stairs path curves</span></span><br><span class="line">            XYZ pathEnd0 = (pnt1 + pnt3) / <span class="number">2.0</span>;</span><br><span class="line">            XYZ pathEnd1 = (pnt2 + pnt4) / <span class="number">2.0</span>;</span><br><span class="line">            pathCurves.Add(Line.CreateBound(pathEnd0, pathEnd1));</span><br><span class="line"></span><br><span class="line">            StairsRun newRun1 = StairsRun.CreateSketchedRun(document, newStairsId, levelBottom.Elevation, bdryCurves, riserCurves, pathCurves);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a straight run</span></span><br><span class="line">            Line locationLine = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-5</span>, newRun1.TopElevation), <span class="keyword">new</span> XYZ(<span class="number">35</span>, <span class="number">-5</span>, newRun1.TopElevation));</span><br><span class="line">            StairsRun newRun2 = StairsRun.CreateStraightRun(document, newStairsId, locationLine, StairsRunJustification.Center);</span><br><span class="line">            newRun2.ActualRunWidth = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a landing between the runs</span></span><br><span class="line">            CurveLoop landingLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">            XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>); </span><br><span class="line">            XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            Line curve_1 = Line.CreateBound(p1, p2);</span><br><span class="line">            Line curve_2 = Line.CreateBound(p2, p3);</span><br><span class="line">            Line curve_3 = Line.CreateBound(p3, p4);</span><br><span class="line">            Line curve_4 = Line.CreateBound(p4, p1);</span><br><span class="line"></span><br><span class="line">            landingLoop.Append(curve_1);</span><br><span class="line">            landingLoop.Append(curve_2);</span><br><span class="line">            landingLoop.Append(curve_3);</span><br><span class="line">            landingLoop.Append(curve_4);</span><br><span class="line">            StairsLanding newLanding = StairsLanding.CreateSketchedLanding(document, newStairsId, landingLoop, newRun1.TopElevation);</span><br><span class="line"></span><br><span class="line">            stairsTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A failure preprocessor is to handle possible failures during the edit mode commitment process.</span></span><br><span class="line">        newStairsScope.Commit(<span class="keyword">new</span> StairsFailurePreprocessor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newStairsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子产生的楼梯：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/stairs.jpg" alt="img"></p>
<p><strong>多层楼梯</strong> </p>
<p>MultistoryStairs类允许楼梯跨越多个标高。多层楼梯元素可以包含多个楼梯，这些楼梯的范围由底部标高和顶部标高控制。 此元素将包含一个或多个Stairs元素。楼梯元素是： 复制到由共享相同标高高度的相同楼梯实例组覆盖的每个标高的参考实例， 或未连接到具有相同标高高度的组的单个Stairs实例。 默认情况下，向多层楼梯添加新标高时，新楼梯将添加到组中。对于不同标高的重复楼梯组，实例可以作为Stairs元素的子元素找到。通过修改关联的Stairs实例，可以一起编辑连接组中的楼梯。对于需要特殊设计的特定楼层，可以使用“取消锁定”方法将楼梯从组中分离出来-对取消锁定的楼梯所做的更改不会影响图元中的其他任何实例。稍后可以使用“锁定”方法将楼梯添加回组中，但是对楼梯所做的任何更改都将丢失，因为楼梯的属性将被组规范覆盖。</p>
<p>代码区域：创建多层楼梯</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create new MultistoryStairs </span></span><br><span class="line">MultistoryStairs multistoryStairs = MultistoryStairs.Create(stairs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all levels that can be connected to this multistoryStairs</span></span><br><span class="line">IEnumerable levelIds = <span class="keyword">new</span> FilteredElementCollector(doc).OfClass(<span class="keyword">typeof</span>(Level)).Cast().Where(q =&gt; multistoryStairs.CanConnectLevel(q.Id))</span><br><span class="line">.Select(q =&gt; q.Id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the levels to the multistoryStairs</span></span><br><span class="line"><span class="comment">// The input to ConnectLevels is a HashSet or SortedSet, so a HashSet is created from the IEnumerable returned by FilteredElementCollector</span></span><br><span class="line">multistoryStairs.ConnectLevels(<span class="keyword">new</span> HashSet(levelIds));</span><br></pre></td></tr></table></figure>

<p>当使用StairsEditScope.Start（ElementId，ElementId）方法创建新楼梯时，它们具有与其关联的默认扶手。但是，Railing.Create（）方法可用于在不带扶手的楼梯的楼梯元素的所有边上创建具有指定扶手类型的新扶手。与需要使用StairsEditScope创建梯段和平台不同，扶手创建不能在打开的楼梯编辑任务中执行。 由于无法为已具有关联扶手的楼梯创建扶手，因此下面的示例在创建新扶手之前删除与楼梯对象关联的现有扶手。</p>
<p>代码区域：创建扶手</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRailing</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Railings&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delete existing railings</span></span><br><span class="line">        ICollection railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">        &#123;</span><br><span class="line">            document.Delete(railingId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find RailingType</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection RailingTypeIds = collector.OfClass(<span class="keyword">typeof</span>(RailingType)).ToElementIds();</span><br><span class="line">        Railing.Create(document, stairs.Id, RailingTypeIds.First(), RailingPlacementPosition.Treads);</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扶手"><a href="#扶手" class="headerlink" title="扶手"></a>扶手</h2><p>Autodesk.Revit.DB.Architecture.Railing类表示Autodesk Revit项目中的扶手元素。尽管扶手与楼梯关联，但它们也可以与其他主体（如楼板）关联，也可以放置在空间中。扶手可以是连续的或不连续的。如果它们是不连续的，则仅提供有限的访问级别。</p>
<p>可以使用GetAssociatedRailings（）方法从Stairs类中检索与楼梯关联的扶手。只有少数属性和方法专用于栏杆扶手，例如返回顶部栏杆的ElementId的TopRail属性和指示栏杆扶手是否翻转的Flipped属性。Railing.Flip（）方法翻转扶手，而RemoveHost（）方法将删除扶手与其主体之间的关联。</p>
<p>下面的示例检索与Stairs对象关联的所有栏杆扶手，并翻转系统生成的默认栏杆扶手。</p>
<p>代码区域：使用扶手</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlipDefaultRailings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    Transaction trans = <span class="keyword">new</span> Transaction(stairs.Document, <span class="string">&quot;Flip Railings&quot;</span>);</span><br><span class="line">    trans.Start();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        <span class="keyword">if</span> (railing.IsDefault == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            railing.Flip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Railing类具有Create方法，该方法可自动在楼梯元素的所有侧面上创建具有指定扶手类型的新扶手。扶手的创建将在“创建和编辑楼梯”部分中进行演示。</p>
<p>RailingType类表示生成扶手时使用的扶手类型。它包含许多关于扶手的属性，例如主扶手和次扶手以及顶部扶手的高度、横向偏移和类型。</p>
<p> 代码区域：RailingType</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRailingType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        RailingType railingType = stairs.Document.GetElement(railing.GetTypeId()) <span class="keyword">as</span> RailingType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Format railing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Railing Type:  &quot;</span> + railingType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nPrimary Handrail Height:  &quot;</span> + railingType.PrimaryHandrailHeight;</span><br><span class="line">        info += <span class="string">&quot;\nTop Rail Height:  &quot;</span> + railingType.TopRailHeight;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯注释"><a href="#楼梯注释" class="headerlink" title="楼梯注释"></a>楼梯注释</h2><p><strong>楼梯注释</strong></p>
<p>StairsPath类可用于注释楼梯的坡度方向和行走线。静态StairsPath.Create（）方法将在楼梯必须可见的特定平面视图中为具有指定楼梯路径类型的指定楼梯创建新楼梯路径。</p>
<p>在Revit UI中编辑楼梯路径时，StairsPath类具有与“属性”窗口中可用的属性相同的属性，例如设置上下方向文字沿着或是否应显示文字的属性。此外，可以指定上下文字的偏移，也可以指定楼梯路径相对于楼梯中心线的偏移。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-98F7477B-3F67-4E52-BDC3-6B63ECA6B700.jpg" alt="img"></p>
<p>下面的示例在项目中查找StairsPathType和FloorPlan，并使用它们为给定的Stairs创建新的StairsPath。</p>
<p>代码区域：创建楼梯路径</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateStairsPath</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transaction transNewPath = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;New Stairs Path&quot;</span>);</span><br><span class="line">    transNewPath.Start();</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Find StairsPathType</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsPathIds = collector.OfClass(<span class="keyword">typeof</span>(StairsPathType)).ToElementIdsElementId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a FloorPlan</span></span><br><span class="line">    ElementId planViewId = ElementId.InvalidElementId;</span><br><span class="line">    FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; viewIds = viewCollector.OfClass(<span class="keyword">typeof</span>(View)).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId viewId <span class="keyword">in</span> viewIds)</span><br><span class="line">    &#123;</span><br><span class="line">        View view = document.GetElement(viewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (view.ViewType == ViewType.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            planViewId = view.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    LinkElementId stairsLinkId = <span class="keyword">new</span> LinkElementId(stairs.Id);</span><br><span class="line">    StairsPath.Create(stairs.Document, stairsLinkId, stairsPathIds.First(), planViewId);</span><br><span class="line">    transNewPath.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsPath具有StairsPathType。楼梯路径类型可从两个预定义的系统族中获得：“自动向上&#x2F;向下方向”和“固定向上方向”。可用于这两种类型的属性作为StairsPathType类中的属性提供，例如FullStepArrow和DistanceToCutMark。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-21CCA05E-3A7C-4CA3-AF96-8BBB88F775E7.jpg" alt="img"></p>
<p>CutMarkType类表示Revit UI中的剪切标记类型，它具有表示在UI中编辑剪切标记类型时可用的相同属性的属性，例如CutLineAngle和CutLineExtension。它与StairsType对象相关联，可以使用BuiltInParameter STAIRSTYPE_CUTMARK_TYPE进行检索，如下所示。</p>
<p>代码区域：获取楼梯的CutMarkType</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CutMarkType <span class="title">GetCutMark</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CutMarkType cutMarkType = <span class="literal">null</span>;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line">    Parameter paramCutMark = stairsType.get_Parameter(BuiltInParameter.STAIRSTYPE_CUTMARK_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (paramCutMark.StorageType == StorageType.ElementId)  <span class="comment">// should be an element id</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId cutMarkId = paramCutMark.AsElementId();</span><br><span class="line">        cutMarkType = stairs.Document.GetElement(cutMarkId) <span class="keyword">as</span> CutMarkType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cutMarkType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯构件"><a href="#楼梯构件" class="headerlink" title="楼梯构件"></a>楼梯构件</h2><p><strong>楼梯构件</strong></p>
<p>Stairs类表示Revit中的楼梯图元，并包含表示有关踏步、高度、楼层数以及楼梯高度、底部标高和顶部标高的信息的属性。Stairs类的方法可用于获取楼梯平台构件、楼梯梯段构件和楼梯支撑。</p>
<p>下面的示例按构件查找所有楼梯，并将有关每个楼梯的一些信息输出到TaskDialog对话框。请注意，此示例使用带有BuiltInCategory.OST_Stairs的类别过滤器，该过滤器将返回所有楼梯的ElementId，因此在从文档中检索时将每个ElementId转换为Stairs类之前，需要进行测试以查看每个ElementId是否代表Stairs By Component。</p>
<p>代码区域：获取楼梯信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stairs <span class="title">GetStairInfo</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stairs stairs = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsIds = collector.WhereElementIsNotElementType().OfCategory(BuiltInCategory.OST_Stairs).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId stairId <span class="keyword">in</span> stairsIds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Stairs.IsByComponent(document, stairId) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stairs = document.GetElement(stairId) <span class="keyword">as</span> Stairs;</span><br><span class="line">                   </span><br><span class="line">            <span class="comment">// Format the information</span></span><br><span class="line">            String info = <span class="string">&quot;\nNumber of stories:  &quot;</span> + stairs.NumberOfStories;</span><br><span class="line">            info += <span class="string">&quot;\nHeight of stairs:  &quot;</span> + stairs.Height;</span><br><span class="line">            info += <span class="string">&quot;\nNumber of treads:  &quot;</span> + stairs.ActualTreadsNumber;</span><br><span class="line">            info += <span class="string">&quot;\nTread depth:  &quot;</span> + stairs.ActualTreadDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Show the information to the user.</span></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsType类表示Stairs元素的类型。它包含有关楼梯的信息，例如楼梯对象中所有梯段和平台的类型、楼梯左侧、右侧和中间支撑的类型和偏移，以及与楼梯生成相关的许多其他特性，例如楼梯图元上每个踢面的最大高度。下面的示例获取Stairs元素的StairsType，并在TaskDialog中显示有关该元素的一些信息。</p>
<p>代码区域：获取楼梯类型信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairsType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format stairs type info for display</span></span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Stairs Type:  &quot;</span> + stairsType.Name;</span><br><span class="line">    info += <span class="string">&quot;\nLeft Lateral Offset:  &quot;</span> + stairsType.LeftLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nRight Lateral Offset:  &quot;</span> + stairsType.RightLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nMax Riser Height:  &quot;</span> + stairsType.MaxRiserHeight;</span><br><span class="line">    info += <span class="string">&quot;\nMin Run Width:  &quot;</span> + stairsType.MinRunWidth;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>梯段</strong></p>
<p>楼梯构件由梯段、平台和支撑组成。这些项中的每一项都可以从Stairs类中检索。梯段在Revit API中由StairsRun类表示。下面的示例获取Stairs对象的每个梯段，并确保它以踢面开始和结束。</p>
<p>代码区域：使用StairsRun</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddStartandEndRisers</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">foreach</span> (ElementId runId <span class="keyword">in</span> runIds)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRun run = stairs.Document.GetElement(runId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != run)</span><br><span class="line">        &#123;</span><br><span class="line">            run.BeginsWithRiser = <span class="literal">true</span>;</span><br><span class="line">            run.EndsWithRiser = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsRun类提供对梯段属性的访问，例如StairsRunStyle（直线、斜梯等），BaseElevation、TopElevation和有关高程的属性。StairsRun类中还有一些方法可用于访问梯段承载的支撑，可以是全部支撑，也可以仅是梯段边界左侧或右侧的支撑。GetStairsPath（）方法将返回表示梯段上楼梯路径的曲线，这些曲线将投影到楼梯的底部标高上。GetFootprintBoundary（）方法返回梯段的边界曲线，这些曲线也投影到楼梯的底部标高上。</p>
<p>StairsRun类有三个用于创建新梯段的静态方法。这些将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsRunType类表示StairsRun的类型。它包含有关梯段踏板和宽度的许多特性以及有关梯段的其他信息。下面的示例获取Stairs元素中第一个梯段的StairsRunType，并显示踢面和踏步厚度沿着以及类型名称。</p>
<p>代码区域：获取StairsRunType信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRunType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line"></span><br><span class="line">    ElementId firstRunId = runIds.First();</span><br><span class="line"></span><br><span class="line">    StairsRun firstRun = stairs.Document.GetElement(firstRunId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != firstRun)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRunType runType = stairs.Document.GetElement(firstRun.GetTypeId()) <span class="keyword">as</span> StairsRunType;</span><br><span class="line">        <span class="comment">// Format landing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Stairs Run Type:  &quot;</span> + runType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nRiser Thickness:  &quot;</span> + runType.RiserThickness;</span><br><span class="line">        info += <span class="string">&quot;\nTread Thickness:  &quot;</span> + runType.TreadThickness;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平台</strong></p>
<p>平台由StairsLanding类表示。下面的示例查找Stairs对象的每个平台的厚度。</p>
<p>代码区域：使用楼梯平台</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairLandings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; landingIds = stairs.GetStairsLandings();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of landings:  &quot;</span> + landingIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> landingIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId landingId <span class="keyword">in</span> landingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        landingIndex++;</span><br><span class="line">        StairsLanding landing = stairs.Document.GetElement(landingId) <span class="keyword">as</span> StairsLanding;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != landing)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nThickness of Landing &quot;</span> + landingIndex + <span class="string">&quot;:  &quot;</span> + landing.Thickness;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与StairsRun类似，StairsLanding具有GetStairsPath（）方法和GetFootprintBoundary（）方法，前者返回表示平台上投影到楼梯基层的楼梯路径的曲线，后者返回平台的边界曲线，也投影到楼梯基层。同样类似于StairsRun，有一种方法可以获取平台承载的所有支撑。</p>
<p>StairsLanding类有一个在两个梯段之间创建新平台的方法。它将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsLandingType类表示Revit API中的平台类型。StairsLandingType类只有两个特定于它的属性，即IsMonolithic（如果楼梯平台是整体的，则为真）和Thickness（表示楼梯平台的厚度）。</p>
<p><strong>楼梯连接</strong><br>Both StairsRun and StairsLanding have a GetConnections() method which provides information about connections among stairs components (run to run, or run to landing). The method returns a collection of StairsComponentConnection objects which have properties about each connection, including the connection type (to a landing, the start of a stairs run, or the end of a stairs run) and the Id of the connected stairs component.<br>StairsRun和StairsLanding都具有GetConnections（）方法，该方法提供有关楼梯构件之间连接的信息（梯段到梯段，或梯段到平台）。该方法返回一个StairsStringentConnection对象的集合，这些对象具有关于每个连接的属性，包括连接类型（连接平台、楼梯梯段起点或楼梯梯段终点）和连接的楼梯构件的ID。</p>
<p><strong>支撑</strong></p>
<p>Revit API不显示楼梯支撑类。获取楼梯、楼梯梯段或楼梯平台的支撑时，支撑将为常规Revit图元。下面的示例获取Stairs对象的所有支撑的名称。</p>
<p>代码区域：获取楼梯支撑</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairSupports</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; supportIds = stairs.GetStairsSupports();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of supports:  &quot;</span> + supportIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> supportIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId supportId <span class="keyword">in</span> supportIds)</span><br><span class="line">    &#123;</span><br><span class="line">        supportIndex++;</span><br><span class="line">        Element support = stairs.Document.GetElement(supportId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != support)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nName of support &quot;</span> + supportIndex + <span class="string">&quot;:  &quot;</span> + support.Name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/21%E6%A5%BC%E6%A2%AF%E5%92%8C%E6%89%B6%E6%89%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/20%E6%9D%90%E6%96%99/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Material_html">材质</a></h1><p>在Revit Platform API中，材质数据作为图元进行存储和管理。就像在Revit UI中一样，材质可以有多个与之关联的资源，但只能使用API指定热学和结构（在Revit UI中称为物理）资源。</p>
<p>某些材质特征由材质类本身的属性（例如FillPattern、Color或Render）表示，而其他材质特征则可用作与材质关联的结构资源或热资源的属性。</p>
<p>在本章中，您将学习如何访问Material元素以及如何管理文档中的Material对象。“元素材质”提供了一个演练，演示如何获取窗材质。</p>
<p>本节中的页面</p>
<ul>
<li>一般材质信息</li>
<li>材质管理</li>
<li>元素材质</li>
<li>材质数量</li>
<li>绘制元素的表面</li>
</ul>
<h2 id="一般材质信息"><a href="#一般材质信息" class="headerlink" title="一般材质信息"></a>一般材质信息</h2><p>在开始演练之前，请通读以下部分以更好地理解Material类。</p>
<p>所有材质对象都可以使用材质类过滤器进行检索。材质对象也可在文档、类别、元素、面等中使用，并在本章的相关部分中进行讨论。无论你在哪里得到一个材质对象，它都被表示为Material类。</p>
<p><strong>属性</strong></p>
<p>材质将具有与渲染外观、结构或其他主要材质类别相关的一个或多个方面。每个方面都由Material类本身的属性或通过其结构或热资产之一表示。StructuralAsset类表示与结构分析相关的材料属性。ThermalAsset类表示与能量分析相关的材料属性。</p>
<p>代码区域19-3：获取材料属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadMaterialProps</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = document.GetElement(strucAssetId) asPropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check the material behavior and only read if Isotropic</span></span><br><span class="line">            <span class="keyword">if</span> (asset.Behavior == StructuralBehavior.Isotropic)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the class of material</span></span><br><span class="line">                StructuralAssetClass assetClass = asset.StructuralAssetClass; <span class="comment">// Get other material properties</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get other material properties</span></span><br><span class="line">                <span class="built_in">double</span> poisson = asset.PoissonRatio.X;</span><br><span class="line">                <span class="built_in">double</span> youngMod = asset.YoungModulus.X;</span><br><span class="line">                <span class="built_in">double</span> thermCoeff = asset.ThermalExpansionCoefficient.X;</span><br><span class="line">                <span class="built_in">double</span> unitweight = asset.Density;</span><br><span class="line">                <span class="built_in">double</span> shearMod = asset.ShearModulus.X;</span><br><span class="line">                <span class="built_in">double</span> dampingRatio = asset.DampingRatio;</span><br><span class="line">                <span class="keyword">if</span> (assetClass == StructuralAssetClass.Metal)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dMinStress = asset.MinimumYieldStress;</span><br><span class="line">                &#125;</span><br><span class="line">                elseif (assetClass == StructuralAssetClass.Concrete)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dConcComp = asset.ConcreteCompression;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Classification</strong> </p>
<p>与结构分析相关的材料分类（即钢、混凝土、木材）可以从与材料关联的StructuralAsset的StructuralAssetClass属性中获得。</p>
<p>注意：API不提供对混凝土材料的混凝土类型值的访问。</p>
<p>与能量分析相关的材料分类（即固体、液体、气体）可以从与材料关联的ThermalAsset的ThermalMaterialType属性中获得。</p>
<p><strong>其它性质</strong></p>
<p>材质对象属性标识特定类型的材质，包括颜色、填充图案等。</p>
<p>属性和参数</p>
<p>某些“材质”属性只能作为“参数”使用。有一些，如颜色，可作为属性或作为参数使用内置参数MATERIAL_PARAM_COLOR。</p>
<p>渲染信息</p>
<p>渲染数据的集合被组织到称为资源的对象中，这些对象是只读的。您可以从Application.Assets属性获取所有可用的与外观相关的资产。可以通过Material.AppearanceAssetId属性从材质访问外观资源。</p>
<p>下图显示了“资源浏览器”对话框的“外观库”部分，其中显示了某些渲染资源在UI中的显示方式。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/AssetBrowser.jpg"></p>
<p>图106：外观库</p>
<p>SDK附带的Materials示例应用程序显示了如何将RenderApperance属性设置为对话框中选定的材质。该对话框将填充Application.Assets中的所有Asset对象。</p>
<p>填充模式</p>
<p>文档中的所有FillPatterns都可以使用FilteredElementCollector过滤类FillPatternElement。FillPatternElement是包含FillPattern的元素，而FillPattern类提供对模式名称和组成模式的FillGrid集的访问。</p>
<p>FillPatterns有两种：Drafting和Model。在UI中，只能将“绘图”填充样式设置为Material.CutPatternId。填充图案类型通过FillPattern.Target属性公开。下面的示例显示如何更改材质FillPattern。</p>
<p>代码区域19-4：设置填充图案</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetFillPattern</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection fillPatternElements = collector.OfClass(<span class="keyword">typeof</span>(FillPatternElement)).ToElementIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId fillPatternId <span class="keyword">in</span> fillPatternElements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// always set successfully</span></span><br><span class="line">        material.CutPatternId = fillPatternId;</span><br><span class="line">        material.SurfacePatternId = fillPatternId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="材质管理"><a href="#材质管理" class="headerlink" title="材质管理"></a>材质管理</h2><p>您可以使用过滤来检索文档中的所有材料。文档中的每个Material对象都由唯一的名称标识。</p>
<p>以下示例说明如何使用材质名称获取材质。</p>
<p>代码区域19-5：按名称获取材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector elementCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">elementCollector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Material)));</span><br><span class="line">IList materials = elementCollector.ToElements();</span><br><span class="line"></span><br><span class="line">Material floorMaterial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> floorMaterialName = <span class="string">&quot;Default Floor&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Element materialElement <span class="keyword">in</span> materials)</span><br><span class="line">&#123;</span><br><span class="line">    Material material = materialElement <span class="keyword">as</span> Material;</span><br><span class="line">    <span class="keyword">if</span> (floorMaterialName == material.Name)</span><br><span class="line">    &#123;</span><br><span class="line">        floorMaterial = material;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != floorMaterial)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Material found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：要运行示例代码，请确保文档中存在材质名称。当前文档的所有材质名称都位于“管理”选项卡（“项目设置”面板  Materials）下。</p>
<p>创建材质</p>
<p>有两种方法可以在API中创建新的Material对象。</p>
<ul>
<li>复制现有材质</li>
<li>添加新材质。</li>
</ul>
<p>使用Duplicate（）方法时，返回的Material对象与原始对象的类型相同。</p>
<p>代码区域19-6：复制材料</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">DuplicateMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> duplicated = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//try to duplicate a new instance of Material class using duplicate method</span></span><br><span class="line">        <span class="comment">//make sure the name of new material is unique in MaterailSet</span></span><br><span class="line">        <span class="built_in">string</span> newName = <span class="string">&quot;new&quot;</span> + material.Name;</span><br><span class="line">        Material myMaterial = material.Duplicate(newName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == myMaterial)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Failed to duplicate a material!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                duplicated = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> duplicated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用静态方法Material.Create（）直接添加新Material。无论如何应用，都必须为材质和属于该材质的任何资产指定唯一的名称。唯一名称是“材质”对象键。</p>
<p>代码区域19-7：添加新材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create the material</span></span><br><span class="line">ElementId materialId = Material.Create(document, <span class="string">&quot;My Material&quot;</span>);</span><br><span class="line">Material material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a new property set that can be used by this material</span></span><br><span class="line">StructuralAsset strucAsset = <span class="keyword">new</span> StructuralAsset(<span class="string">&quot;My Property Set&quot;</span>, StructuralAssetClass.Concrete);</span><br><span class="line">strucAsset.Behavior = StructuralBehavior.Isotropic;</span><br><span class="line">strucAsset.Density = <span class="number">232.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Assign the property set to the material.</span></span><br><span class="line">PropertySetElement pse = PropertySetElement.Create(document, strucAsset);</span><br><span class="line">material.SetMaterialAspectByPropertySet(MaterialAspect.Structural, pse.Id);</span><br></pre></td></tr></table></figure>

<p>删除材质</p>
<p>要删除材料，用：</p>
<ul>
<li>Document.Delete()</li>
</ul>
<p>Document.Delete() 是一个泛型方法。有关详细信息，请参见编辑元素。</p>
<h2 id="元素材质"><a href="#元素材质" class="headerlink" title="元素材质"></a>元素材质</h2><p>一个元素可以有多个元素和组件。例如，FamilyInstance具有SubComponents，Wall具有CompoundStructure，其中包含多个CompoundStructureLayers。(有关“子构件”的详细信息，请参阅“族”部分，有关“复合结构”的详细信息，请参阅“墙、楼板、屋顶和洞口”。）</p>
<p>在Revit Platform API中，使用以下准则获取图元的材质：</p>
<ul>
<li>如果元素包含元素，则单独获取材料。</li>
<li>如果图元包含构件，请从参数或以特定方式获取每个构件的材质（请参见墙、楼板、屋顶和洞口中的“材质”部分）。</li>
<li>如果构件的材质返回null，则从相应的Element.Category子类别中获取物料。</li>
</ul>
<p><strong>参数中的材质</strong></p>
<p>如果Element对象有一个参数，其中的参数类型是参数类型.材料，您可以从参数中获取元素材料。例如，结构柱FamilySymbol（类别为BuiltInCategory.OST_StructuralColumns的FamilyInstance）具有“结构材质”参数。使用ElementId获取材质。下面的代码示例阐释如何获取具有一个构件的结构柱Material。</p>
<p>代码区域：从参数获取元素材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> familyInstance.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        Definition definition = parameter.Definition;</span><br><span class="line">        <span class="comment">// material is stored as element id</span></span><br><span class="line">        <span class="keyword">if</span> (parameter.StorageType == StorageType.ElementId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (definition.ParameterGroup == BuiltInParameterGroup.PG_MATERIALS &amp;&amp;</span><br><span class="line">                    definition.ParameterType == ParameterType.Material)</span><br><span class="line">            &#123;</span><br><span class="line">                Autodesk.Revit.DB.Material material = <span class="literal">null</span>;</span><br><span class="line">                Autodesk.Revit.DB.ElementId materialId = parameter.AsElementId();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == materialId.IntegerValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Invalid ElementId, assume the material is &quot;By Category&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Category)</span><br><span class="line">                    &#123;</span><br><span class="line">                        material = familyInstance.Category.Material;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Element material: &quot;</span> + material.Name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果在UI中将材质属性设置为“按类别”，则材质的ElementId为ElementId.InvalidElementId，并且不能用于检索Material对象，如示例代码中所示。尝试从类别中检索材质，如下一节所述。 其他化合物参数中包含的某些材质特性无法从API访问。例如，在下图中，对于“系统族：栏杆扶手”，“栏杆结构”参数的“栏杆类型”为“栏杆类型.无”。因此，在这种情况下，您无法获得实质性信息。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ByCategory.jpg"></p>
<p>图107：扶手结构属性</p>
<p> Material和FamilyInstance 梁族、柱族和基础族有另一种使用其StructuralMaterialId属性获取其材质的方法。此属性返回一个ElementId，用于标识定义实例的结构分析属性的材质。</p>
<p>代码区域：从族实例获取图元材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Material <span class="title">GetFamilyInstanceMaterial</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Material material = document.GetElement(beam.StructuralMaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>材质和类别</strong></p>
<p>只有模型图元可以具有材质。</p>
<p>从Revit的“管理”选项卡中，单击“设置” <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> “对象样式”以显示“对象样式”对话框。类别列在“模型对象”（Model Objects)选项卡中的图元具有材质信息。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ModelObjectsMaterial.jpg" alt="img"></p>
<p>图108：材质分类</p>
<p>只有模型元素可以指定“材质”属性。因此，查询与Model元素（例如，Annotations或Imported）以外的元素相对应的类别的Material将始终导致null。有关元素和类别分类的更多详细信息，请参阅元素要素。</p>
<p>如果一个元素有多个组件，则某些类别.子类别对应于这些组件。</p>
<p>在上一个“对象样式”对话框中，“窗类别”和“框架&#x2F;竖梃”子类别以及“玻璃”子类别将映射到windows元素中的构件。在下图中，似乎窗符号Glass材质参数是获取窗玻璃材质的唯一方法。但是，该值为“按类别”，相应的参数返回ElementId. InvalidElementId。</p>
<p>在这种情况下，窗户的Material不为null，它取决于Category OST_WindowsFrameMullionProjection的Material属性，该属性是窗口类别OST_Windows的子类别。如果它也返回null，则窗格的Material由父类别OST_Windows确定。有关更多详细信息，请参阅元素材质。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E345BF1-1837-41C7-BF9C-A89A1A76539F-low.png"></p>
<p>图109：窗户材料</p>
<p><strong>复合结构层材料</strong></p>
<p>可以从HostObjAttributes获取CompoundStructureLayer对象。有关详细信息，请参阅墙、地板、天花板、屋顶和洞口。</p>
<p><strong>电子元件材料</strong></p>
<p>下图显示了检索元素材质的工作流：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-64D41480-87CE-454E-8B14-1EFEFEC8BF09-low.png"></p>
<p>图110：获取元素材质工作流</p>
<p>此工作流说明了以下过程：</p>
<ul>
<li>该工作流显示了如何获取属于图元的Material对象（而不是Autodesk.Revit.DB.Structure.StructuralMaterialType枚举类型）。</li>
<li>检索材质时有两种要素分类：<ul>
<li>HostObject with CompoundStructure -从CompoundStructureLayer类MaterialId属性获取Material对象。</li>
<li>其他-从参数中获取材质。</li>
</ul>
</li>
<li>当您获得空Material对象或值为ElementId.InvalidElementId的无效ElementId时，请尝试相应类别中的Material。请注意，FamilyInstance及其FamilySymbol通常具有相同的类别。</li>
<li>对Element对象了解得越多，获取材质就越容易。举例来说：<ul>
<li>如果知道元素是梁，则可以获取实例参数Structural Material</li>
<li>如果知道该元素是一个窗口，则可以将其强制转换为FamilyInstance并获取FamilySymbol。</li>
</ul>
</li>
<li>之后，您可以获得参数，如框架外部材料或框架内部材料，以获得材料对象。如果你得到null，尝试从FamilySymbol类别中获取Material对象。</li>
<li>API中并非所有元素材质都可用。</li>
</ul>
<p><strong>演练：获取窗户材质</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance window</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilySymbol windowSymbol = window.Symbol;</span><br><span class="line">    Category category = windowSymbol.Category;</span><br><span class="line">    Autodesk.Revit.DB.Material frameExteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material frameInteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material sashMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Check the parameters first</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> windowSymbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (parameter.Definition.Name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Exterior Material&quot;</span>:</span><br><span class="line">                frameExteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Interior Material&quot;</span>:</span><br><span class="line">                frameInteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Sash&quot;</span>:</span><br><span class="line">                sashMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try category if the material is set by category</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameExteriorMaterial)</span><br><span class="line">        frameExteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameInteriorMaterial)</span><br><span class="line">        frameInteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == sashMaterial)</span><br><span class="line">        sashMaterial = category.Material;</span><br><span class="line">    <span class="comment">// Show the result because the category may have a null Material,</span></span><br><span class="line">    <span class="comment">// the Material objects need to be checked.</span></span><br><span class="line">    <span class="built_in">string</span> materialsInfo = <span class="string">&quot;Frame Exterior Material: &quot;</span> + (<span class="literal">null</span> != frameExteriorMaterial ? frameExteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Frame Interior Material: &quot;</span> + (<span class="literal">null</span> != frameInteriorMaterial ? frameInteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Sash: &quot;</span> + (<span class="literal">null</span> != sashMaterial ? sashMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,materialsInfo);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="材质数量"><a href="#材质数量" class="headerlink" title="材质数量"></a>材质数量</h2><p>有一些方法可以直接获取Revit为材质提取明细表计算的材质体积和面积：</p>
<ul>
<li>Element.GetMaterialIds() –获取元素中的材料列表</li>
<li>Element.GetMaterialVolume() – 获取元素中特定材料的体积</li>
<li>Element.GetMaterialArea() – 获取元素中特定材质的面积</li>
</ul>
<p>这些方法适用于其中Category. HasMaterialList属性为true的元素类别。实际上，这仅限于使用复合结构的图元（如墙、屋顶、楼板、天花板）、其他一些基本三维图元（如楼梯）以及可以将材质指定给族几何图形的三维族（如窗、门、柱、MEP设备和装置以及常规模型族）。请注意，在这些类别中，对于如何提取材料数量有进一步的限制。例如，幕墙和幕墙屋顶本身不会报告任何材质数量;这些构件使用的材质可以从组成幕墙系统的各个嵌板图元中提取。</p>
<p>请注意，在某些情况下，Revit计算的体积和面积可能是近似值。例如，对于墙内的各个层，模型中可见的体积与材质提取明细表中显示的体积之间可能会出现微小的差异。使用墙饰条工具向墙添加饰条或分隔缝时，或在某些连接条件下，往往会出现这些差异。</p>
<p>SDK示例“MaterialTools”结合了材质数量提取工具和剪切元素（洞口、窗和门）的临时抑制，以提取总材质数量和净材质数量。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/material_quantities.png"></p>
<h2 id="绘制元素的表面"><a href="#绘制元素的表面" class="headerlink" title="绘制元素的表面"></a>绘制元素的表面</h2><p>绘制工具功能可通过Revit API使用。可以使用材质绘制墙、楼板和屋顶等图元的面以更改其外观。它不会改变元素的结构。</p>
<p>与绘制元素相关的方法是Document类的一部分。Paint（）将材质应用于元素的指定面。Document.RemovePaint（）将移除应用的材质。此外，IsPainted（）和GetPaintedMaterial（）方法返回有关元素表面的信息。</p>
<p>代码区域：绘制墙面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Paint any unpainted faces of a given wall</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PaintWallFaces</span>(<span class="params">Wall wall, ElementId matId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = wall.Document;</span><br><span class="line">    GeometryElement geometryElement = wall.get_Geometry(<span class="keyword">new</span> Options());</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geometryObject <span class="keyword">in</span> geometryElement)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geometryObject <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geometryObject <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (doc.IsPainted(wall.Id, face) == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    doc.Paint(wall.Id, face, matId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/20%E6%9D%90%E6%96%99/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/19%E8%8D%89%E5%9B%BE/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="草图"><a href="#草图" class="headerlink" title="草图"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Sketching_html">草图</a></h1><p>要在Revit中创建图元或编辑其轮廓，必须先创建草图对象。需要绘制草图的图元示例包括：</p>
<ul>
<li>Roofs 屋顶</li>
<li>Floors 地板</li>
<li>Stairs 楼梯</li>
<li>Railings 栏杆</li>
</ul>
<p>还需要草图来定义其他类型的几何图形，例如：</p>
<ul>
<li>Extrusions 拉伸</li>
<li>Openings 开口</li>
<li>Regions 区域</li>
</ul>
<p>在Revit Platform API中，草图函数由二维和三维草图类表示，如下所示：</p>
<ul>
<li>二维Sketch：<ul>
<li>SketchPlane 草图平面</li>
<li>Sketch 草图</li>
<li>ModelCurve 模型线</li>
<li>and more</li>
</ul>
</li>
<li>三维Sketch：<ul>
<li>GenericForm 通用形状</li>
<li>Path3D 3D路径</li>
</ul>
</li>
</ul>
<p>除了草图元素外，本章还介绍了ModelCurve。有关元素分类的详细信息，请参阅元素部分中的元素分类。</p>
<p> 本节中的页面</p>
<ul>
<li>2DSketch类</li>
<li>3DSketch</li>
<li>模型线</li>
</ul>
<h2 id="2D-Sketch类"><a href="#2D-Sketch类" class="headerlink" title="2D Sketch类"></a>2D Sketch类</h2><p>Sketch类表示用于创建3D模型的平面中的封闭曲线。关键功能由SketchPlane和CurveLoop属性表示。</p>
<p>编辑Revit文件时，无法通过迭代Document.Elements枚举来检索Sketch对象，因为所有Sketch对象都是瞬态Elements。访问族的三维建模信息时，草图对象对于形成几何图形非常重要。有关更多详细信息，请参见3D草图。</p>
<p>SketchPlane是所有2D草图类（如ModelCurve和Sketch）的基础。SketchPlane也是DetailCurve等2D注释元素的基础。ModelCurve和DetailCurve都具有SketchPlane属性，并且在相应的创建方法中需要SketchPlane。SketchPlane在Revit UI中始终不可见。</p>
<p>每个ModelCurve必须位于一个SketchPlane中。换句话说，无论您在UI中还是通过使用API绘制ModelCurve，都必须存在SketchPlane。因此，在绘制ModelCurve的二维视图中至少存在一个SketchPlane。</p>
<p>二维视图包含CeilingPlan、FloorPlan和Elevation ViewTypes。默认情况下，会自动为所有这些视图创建“草绘平面”（SketchPlane）。与二维视图相关的SketchPlane Name返回视图名称，例如Level 1或North。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9B03E831-1E6C-4CE2-9149-3F7B309A5B5D-low.png"></p>
<p>图77：拾取平面以标识新的工作平面</p>
<p>指定新工作平面时，可以选择“拾取平面”，如上图所示。拾取平面后，选择特定图元（如墙）上的平面，如下图所示。在这种情况下，SketchPlane.Name属性返回与该元素相关的字符串。例如，在下图中，SketchPlane.Name属性返回与Wall.Name属性相同的“Generic - 8”。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67D74CA2-D850-422F-A4FF-E762D683DFC9-low.png"></p>
<p> 图78：在墙上拾取一个平面作为工作平面</p>
<p>注意：“草绘平面”与工作平面不同，因为工作平面是可见的并且可以选择。它在当前API中没有特定的类，但由Element类表示。必须基于特定的SketchPlane定义工作平面。工作平面和SketchPlane Category属性都返回null。尽管“草绘平面”始终不可见，但始终存在与工作平面对应的“草绘平面”。工作平面用于在文本和图片中表达SketchPlane。</p>
<p>以下信息适用于SketchPlane成员：</p>
<ul>
<li>ID、UniqueId、Name和Plane属性返回值;</li>
<li>参数属性为空</li>
<li>Location属性返回Location对象</li>
<li>其他属性返回null。</li>
</ul>
<p>Plane包含SketchPlane几何信息。SketchPlane使用Plane设置平面坐标系，如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-415773EF-49A7-4158-B9DD-42A218063E81-low.png"></p>
<p>图79：SketchPlane和Plane坐标系</p>
<p>以下代码示例说明如何创建新的SketchPlane：</p>
<p>代码区域17-1：创建新的草绘平面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SketchPlane <span class="title">CreateSketchPlane</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//try to create a new sketch plane</span></span><br><span class="line">    XYZ newNormal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// the normal vector</span></span><br><span class="line">    XYZ newOrigin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the origin point</span></span><br><span class="line">    <span class="comment">// create geometry plane</span></span><br><span class="line">    Plane geometryPlane = Plane.CreateByNormalAndOrigin(newNormal, newOrigin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create sketch plane</span></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(application.ActiveUIDocument.Document,geometryPlane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sketchPlane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3D-Sketch"><a href="#3D-Sketch" class="headerlink" title="3D Sketch"></a>3D Sketch</h2><p>三维草图用于编辑族或创建三维对象。在Revit Platform API中，可以使用以下类完成三维草图。</p>
<ul>
<li>Extrusion </li>
<li>Revolution </li>
<li>Blend </li>
<li>Sweep</li>
</ul>
<p>换句话说，有四个操作可以将2D模型转换为3D模型。有关在2D中绘制草图的详细信息，请参见2D草图类。</p>
<p><strong>Extrusion</strong> </p>
<p>Revit使用拉伸定义族的三维几何图形。通过在平面上定义二维草图来创建拉伸;然后Revit在起点和终点之间拉伸草图。</p>
<p>查询“拉伸形状”对象，以查找要在族建模和体量中使用的常规形状。Extrusion类具有以下属性：</p>
<p>表40：拉伸属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>ExtrusionStart</td>
<td>返回拉伸起点。这是一个双类型。</td>
</tr>
<tr>
<td>ExtrusionEnd</td>
<td>返回拉伸终点。这是一个双类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个草图平面和一些曲线。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F322D1A-5035-4E9E-88F6-2AFAD258E59E-low.png"></p>
<p>图81：拉伸结果</p>
<p><strong>Revolution</strong> </p>
<p>“旋转”命令可创建绕轴旋转的几何图形。可以使用“旋转”命令在家具、圆屋顶或柱上创建门把手或其他把手。</p>
<p>查询“旋转形式”对象，以获得要在族建模和体量中使用的常规形式。Revolution类具有以下属性：</p>
<p>表41：Revolution属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Axis</td>
<td>返回轴。它是一个ModelLine对象。</td>
</tr>
<tr>
<td>EndAngle</td>
<td>返回结束角度。这是一个double类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个SketchPlane和一些曲线。</td>
</tr>
</tbody></table>
<p>EndAngle与Revit UI中的相同参数一致。下图说明了Revolution对应参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CF60823-4258-4838-ADA8-61F52C4B3515-low.png"></p>
<p>图82：对应参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-10A03254-96BC-4023-99C5-B22AF43A0702-low.png"></p>
<p>图83：旋转草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-803C819E-E85C-462B-BF33-CC49E9FC3C86-low.png"></p>
<p>图84：旋转结果</p>
<p>Note: 注意事项：</p>
<ul>
<li>无法使用Revit Platform API访问“起始角度”。</li>
<li>如果“结束角度”为正，则“旋转”方向为顺时针。如果为负，则旋转方向为逆时针</li>
</ul>
<h2 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h2><p>“融合”命令将两个轮廓融合在一起。例如，如果绘制了一个大矩形，并在其上绘制了一个小矩形，则Revit会将这两个形状融合在一起。</p>
<p>查询“融合形式”对象以获得要在族建模和体量中使用的常规形式。Blend类具有以下属性：</p>
<p>表42：Blend属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>BottomSketch</td>
<td>返回底部草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>TopSketch</td>
<td>返回顶部草图融合。它是一个Sketch对象。</td>
</tr>
<tr>
<td>FirstEnd</td>
<td>返回第一个端点。这是一个double类型。</td>
</tr>
<tr>
<td>SecondEnd</td>
<td>返回第二个终点。这是一个double类型。</td>
</tr>
</tbody></table>
<p>FirstEnd和SecondEnd属性值与Revit UI中的相同参数一致。下图说明了“融合”对应的参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BF73A304-626D-43C2-9A53-8C396270369F-low.png"></p>
<p>图85：UI中的融合参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-14B5134B-B412-429C-8CBF-A542C16659C0-low.png"></p>
<p>图86：融合顶部草图和底部草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F637CA72-BA0E-4917-B24D-93947FD69E22-low.png"></p>
<p> 图87：融合结果</p>
<h2 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h2><p>“放样”命令可沿创建的二维路径或选定的三维路径沿着放样一个轮廓。路径可以是开环或闭环，但必须穿过轮廓平面。</p>
<p>查询“放样形状”对象，以获得用于族建模和体量的常规形状。Sweep类具有以下属性：</p>
<p>表43：Sweep 属性</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Path3d</td>
<td>返回三维路径草图。它是一个Path3D对象。</td>
</tr>
<tr>
<td>PathSketch</td>
<td>返回平面路径草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>ProfileSketch</td>
<td>返回轮廓草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>EnableTrajSegmentation</td>
<td>返回轨迹分段状态。它是一个布尔值。</td>
</tr>
<tr>
<td>MaxSegmentAngle</td>
<td>返回最大线段角度。这是一个double类型。</td>
</tr>
</tbody></table>
<p>创建2D路径与其他形状类似。通过拾取创建的3D曲线来获取3D路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C9B66D17-E7EF-4CE4-B186-E1862B49461D-low.png"></p>
<p>图88：选择Sweep 3D路径</p>
<p>注意：以下信息适用于放样：</p>
<ul>
<li>仅当使用“拾取路径”获取3D路径时，Path3d特性才可用。</li>
<li>无论路径是三维还是二维，PathSketch都可用。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E2B269D-16CC-417E-A4BF-EBAD946C73DC-low.png" alt="img"><br>图89：扫描轮廓草图</li>
</ul>
<p>注意：轮廓草图垂直于路径。</p>
<p>分段放样对于创建机械风管弯头非常有用。通过设置两个放样参数并绘制带有圆弧的路径来创建分段放样。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B63CD7A5-25B1-440A-A31B-AB6FADF08169-low.png"></p>
<p>图90：UI中的相应分段设置</p>
<p>注意：以下信息适用于分段放样：</p>
<ul>
<li>这些参数仅影响路径中的弧。</li>
<li>放样的最小分段数为两个。</li>
<li>通过清除“轨迹分段”（Trajectory Segmentation）复选框，将分段放样更改为非分段放样。EnableTrajSegmentation属性返回false。</li>
<li>如果EnableTrajSegmentation属性为false，则MaxSegmentAngle的值为默认360°。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2AACA3CE-F284-4412-9887-B84FB87CC6BA-low.png" alt="img"></li>
</ul>
<p>图91：放样结果</p>
<h2 id="模型线"><a href="#模型线" class="headerlink" title="模型线"></a>模型线</h2><p>ModelCurve表示项目中的模型线。它存在于三维空间中，在所有视图中可见。</p>
<p>以下图片说明了四个ModelCurve派生类：<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1CE68863-4E07-4852-A896-5ACE5235B7AE-low.png" alt="img"> 图92：ModelLine和ModelArc<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-E914167B-553C-4B5B-A87E-1AAB487A12B5-low.png" alt="img"> 图93：ModelEllipse和ModelNurbSpline</p>
<p><strong>创建模型线</strong></p>
<p>创建模型曲线的关键是创建曲线所在的几何、曲线和草图平面。根据您输入的Geometry.Curve类型，返回的相应ModelCurve可以向下转换为正确的类型。</p>
<p>以下示例说明如何创建新的模型曲线（ModelLine和ModelArc）：</p>
<p>代码区域17-2：创建新的模型曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get handle to application from document</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry line in Revit application</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">Line geomLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry arc in Revit application</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry plane in Revit application</span></span><br><span class="line">XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">SketchPlane sketch = SketchPlane.Create(document, geomPlane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelLine element using the created geometry line and sketch plane</span></span><br><span class="line">ModelLine line = document.Create.NewModelCurve(geomLine, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelArc element using the created geometry arc and sketch plane</span></span><br><span class="line">ModelArc arc = document.Create.NewModelCurve(geomArc, sketch) <span class="keyword">as</span> ModelArc;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong> </p>
<p>GeometryCurve </p>
<p>GeometryCurve属性用于获取或设置模型曲线的几何曲线。除了ModelHermiteSpline，你可以从四个ModelCurves中得到不同的几何曲线;</p>
<ul>
<li>Line </li>
<li>Arc </li>
<li>Ellipse </li>
<li>Nurbspline</li>
</ul>
<p>下面的代码示例说明如何从ModelCurve获取特定Curve。</p>
<p>代码区域17-3：从ModelCurve获取特定曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the geometry modelCurve of the model modelCurve</span></span><br><span class="line">Autodesk.Revit.DB.Curve geoCurve = modelCurve.GeometryCurve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (geoCurve <span class="keyword">is</span> Autodesk.Revit.DB.Line)</span><br><span class="line">&#123;</span><br><span class="line">        Line geoLine = geoCurve <span class="keyword">as</span> Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GeometryCurve属性返回值是一个常规的Geometry.Curve对象，因此，必须使用As运算符来转换对象类型。</p>
<p>注意：以下信息适用于GeometryCurve：</p>
<ul>
<li>在Revit中，无法创建Hermite曲线，但可以从其他软件（如AutoCAD）导入该曲线。Curve是唯一表示Hermite曲线的几何类。</li>
<li>SetPlaneAndCurve（）方法以及Curve和SketchPlane属性设置器用于不同的情况。<ul>
<li>当新曲线位于同一个SketchPlane中，或者新SketchPlane与旧SketchPlane位于同一个平面上时，请使用Curve或SketchPlane属性设置器。</li>
<li>如果新的Curve不在同一个SketchPlane中，或者新的SketchPlane与旧的SketchPlane不在同一个平面上，则必须使用SetPlaneAndCurve（）同时更改Curve值和SketchPlane值，以避免内部数据不一致。</li>
</ul>
</li>
</ul>
<p>线样式</p>
<p>线型由GraphicsStyle类表示。ModelCurve的所有线条样式都可以从GetLineStyleIds（）方法中获得，该方法返回一组GraphicsStyle元素的ElementIds。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/19%E8%8D%89%E5%9B%BE/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/18%E5%87%A0%E4%BD%95/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Geometry_html">几何</a></h1><p>Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：</p>
<ul>
<li>GeometryObject class - 包含从几何对象类派生的类。</li>
<li>Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型</li>
<li>Geometry Utility Classes - 包含创建非元素几何体和查找实体交点的类</li>
<li>Collection Classes - 包括从 IEnumerable 或 IEnumerator 接口派生的类。</li>
</ul>
<p>在这一节中，您将学习如何使用各种图形相关类型，如何从元素中检索几何数据，如何变换元素，以及更多内容。</p>
<p><strong>本节页面</strong></p>
<ul>
<li>从墙壁中检索几何数据</li>
<li>GeometryObject类</li>
<li>几何辅助类</li>
<li>集合类</li>
<li>从梁中检索几何数据</li>
<li>固体挤压分析</li>
<li>通过光线投影寻找几何图形</li>
<li>几何工具类</li>
<li>房间与空间几何</li>
</ul>
<h2 id="示例：从墙壁中检索几何数据"><a href="#示例：从墙壁中检索几何数据" class="headerlink" title="示例：从墙壁中检索几何数据"></a>示例：从墙壁中检索几何数据</h2><p>本教程演示了如何从墙壁获取几何数据。以下信息被涵盖：</p>
<ul>
<li>获取墙体几何边缘。</li>
<li>获取墙体几何面。</li>
</ul>
<p>注意：在本例中，由于未考虑实例，从元素中检索几何数据受到限制。例如，包含在墙中的放样在示例代码中不可用。本指南的目标是让您对如何检索几何数据有一个基本了解，但并不涵盖所有情况。有关从元素中检索几何数据的更多信息，请参阅示例：从梁中检索几何数据。</p>
<p>代码区域20-1：创建 Geometry.Options</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options geomOption = application.Create.NewGeometryOptions();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != geomOption)</span><br><span class="line">&#123;</span><br><span class="line">        geomOption.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">        geomOption.DetailLevel = Autodesk Autodesk.Revit.DB.DetailLevels.Fine;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either the DetailLevel or the View can be set, but not both</span></span><br><span class="line">        <span class="comment">//geomOption.View = commandData.Application.ActiveUIDocument.Document.ActiveView;</span></span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Geometry Option created successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关详细信息，请参阅几何辅助类。</p>
<p>检索面和边</p>
<p> 墙几何图形是由面和边组成的实体。完成以下步骤以获取面和边：</p>
<p>1.使用Wall类的Geometry属性创建一个Geometry.Element实例。此实例包含“对象”属性中的所有几何体对象，如实体、直线等。</p>
<p>2.迭代Object属性以获取几何体实体实例，该实例包含“面”和“边”属性中的所有几何体面和边。</p>
<p>3.迭代“面”属性以获取所有几何体面。</p>
<p>4.迭代Edges属性以获取所有几何体边。 </p>
<p>示例代码如下：</p>
<p>代码区域20-2：检索面和边</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetFacesAndEdges</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        String faceInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Autodesk.Revit.DB.Options opt = <span class="keyword">new</span> Options();</span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geomElem = wall.get_Geometry(opt);</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">        &#123;</span><br><span class="line">                Solid geomSolid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != geomSolid)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">int</span> faces = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">double</span> totalArea = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Face geomFace <span class="keyword">in</span> geomSolid.Faces)</span><br><span class="line">                        &#123;</span><br><span class="line">                                faces++;</span><br><span class="line">                                faceInfo += <span class="string">&quot;Face &quot;</span> + faces + <span class="string">&quot; area: &quot;</span> + geomFace.Area.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                totalArea += geomFace.Area;</span><br><span class="line">                        &#125;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Number of faces: &quot;</span> + faces + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Total area: &quot;</span> + totalArea.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge geomEdge <span class="keyword">in</span> geomSolid.Edges)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">// get wall&#x27;s geometry edges</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, faceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GeometryObject类"><a href="#GeometryObject类" class="headerlink" title="GeometryObject类"></a>GeometryObject类</h2><p>索引属性Element.Geometry[]可用于提取任何模型元素（3D元素）的几何图形。这既适用于系统族实例（如墙、楼板和屋顶），也适用于许多类别的族实例（如门、窗、家具或体量）。</p>
<p>提取的几何图形将作为Autodesk. Revit. DB. GeometryElement返回给您。可以使用GetEnumerator（）方法遍历该元素的几何成员。</p>
<p>通常，在提取的几何图形的顶层返回的对象将是以下对象之一：</p>
<ul>
<li>Solids, Faces and Edges-由面和边组成的边界表示</li>
<li>Meshes-三角形的3D阵列</li>
<li>Curves-有界3D曲线</li>
<li>Points – 给定3D位置处的可见基准点</li>
<li>PolyLines – 由3D点定义的一系列线段</li>
<li>GeometryInstances-位于元素内的几何元素的实例</li>
</ul>
<p>该图说明了通过几何体提取找到的对象的层次结构。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/geometry_hierarchy.png"></p>
<p>本节中的页面</p>
<ul>
<li>Curves </li>
<li>GeometryInstances </li>
<li>Meshes </li>
<li>Points </li>
<li>PolyLines </li>
<li>Solids, Faces and Edges</li>
</ul>
<h3 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h3><p>曲线表示Revit模型中的二维或三维路径。曲线可以表示元素几何形状的整个范围（例如CurveElements），也可以显示为元素几何形状的一部分（例如墙或风管的中心线）。曲线和曲线集合在API的许多元素创建方法中用作输入。</p>
<p>本节中的页面</p>
<ul>
<li>曲线分析</li>
<li>曲线工作</li>
<li>曲线集合</li>
<li>曲线创建</li>
<li>曲线参数化</li>
<li>曲线类型</li>
<li>曲线类型的数学表示</li>
</ul>
<h4 id="曲线分析"><a href="#曲线分析" class="headerlink" title="曲线分析"></a>曲线分析</h4><p>有几种曲线方法是适用于几何分析的工具。</p>
<p>在某些情况下，这些API所做的事情比您通过快速查看其名称所期望的要多。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法允许您比较两条曲线，以找出它们的不同之处或相似之处。它可以以您可能期望的方式使用，以获得两条曲线彼此相交的点，但它也可以用于识别：</p>
<ul>
<li>Collinear lines 共线的线</li>
<li>Overlapping lines 重叠线</li>
<li>Identical curves 相同曲线</li>
<li>Totally distinct curves with no intersections 完全不同的曲线，没有交叉点</li>
</ul>
<p>返回值标识这些不同的结果，输出IntersectionSetResult包含有关交点的信息。</p>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到曲线上，并返回有关曲线上最近点、其参数以及与投影点的距离的信息。</p>
<p><strong>Tessellate()</strong></p>
<p>这会将曲线分割为一系列线性段，精确度在默认公差范围内。对于Curve.Tessellate（），公差略大于1&#x2F;16”。此近似公差是Revit内部使用的公差，足以满足显示目的。</p>
<p>请注意，只有直线可以被分割成只有两个细分点的输出;非线性曲线将总是输出两个以上的点，即使曲线具有极大的半径，在数学上可能等同于直线。</p>
<h4 id="曲线工作"><a href="#曲线工作" class="headerlink" title="曲线工作"></a>曲线工作</h4><p>Curve类提供了使用曲线的有用方法。</p>
<p>除了对分析有用的方法外，Curve类还提供了用于修改曲线或获取有关曲线的基本信息的属性和方法。</p>
<p><strong>改变界限</strong></p>
<p>MakeBound（）方法可用于更改曲线的边界或为先前未绑定的曲线创建边界。MakeUnbound（）将使曲线未绑定。对于这两种方法，如果曲线标记为只读（因为它是直接从Revit图元或集合&#x2F;聚合对象中提取的），则调用此方法会导致对象更改为包含原始曲线的断开连接的副本。修改不会影响原始曲线或提供原始曲线的对象。</p>
<p><strong>图形样式</strong></p>
<p>Curve从GeometryObject继承GraphicsStyleId只读属性，GeometryObject提供指定给Curve的GraphicsStyle的ElementId。方法Curve.SetGraphicsStyleId（）可用于设置Curve的GraphicsStyle Id。Revit API中的许多方法将不使用与此曲线关联的图形样式。例如，用作图元草图一部分的曲线将不会读取此属性。新创建的曲线元素也不会使用此值，因为它们从其关联类别继承图形特性。</p>
<p><strong>曲线长度</strong></p>
<p>曲线有两个与长度相关的属性。Length属性将返回曲线的精确长度。我使用解析或数值积分计算曲线的长度。对于直线和圆弧没有性能影响。对于更快的近似，ApproximateLength属性可以快速估计曲线的长度，但在某些情况下可能会偏离2倍。此计算对于直线和圆弧是精确的。</p>
<h4 id="曲线集合"><a href="#曲线集合" class="headerlink" title="曲线集合"></a>曲线集合</h4><p>Revit API使用不同类型的曲线集合作为输入。</p>
<p>注意：较新的API方法使用Curves的.NET集合代替CurveArray和CurveArrArray。</p>
<p><strong>CurveLoop</strong></p>
<p>curveloop表示端到端连接的特定曲线链。它可以表示一个闭环或一个开环。curveloop的成员可以直接迭代，因为该类实现了IEnumerable。迭代提供了直接包含在循环中的曲线的副本；曲线的修改不会影响loop中包含的曲线。可以使用以下方法创建CurveLoops：</p>
<ul>
<li>CurveLoop.Create（）-从曲线列表创建新的CurveLoop。</li>
<li>CurveLoop.CreateViaCopy() - 创建新的CurveLoop作为现有CurveLoop的副本。</li>
<li>CurveLoop. ViaThumb（Curve，double，XYZ）-通过相对于给定平面加厚输入曲线来创建新的闭合CurveLoop。</li>
<li>CurveLoop. curveViaThrottle（CurveLoop，double，XYZ）-通过相对于给定平面加厚输入开放曲线循环来创建新的闭合曲线循环。</li>
<li>CurveLoop.CreateViaTransform() - 创建一个新的CurveLoop作为输入CurveLoop的转换副本。请注意，重载ViaThursday（）方法的thickness参数必须导致曲线超过Revit的短曲线容差（Application.ShortCurveTolerance），否则将引发异常。</li>
</ul>
<p>CurveLoop.Transform（） 的执行方式与 CreateViaTransform（） 类似，但它会变换 CurveLoop 中包含的曲线，而不是创建变换后的副本。</p>
<p><strong>CurveArray</strong></p>
<p>此集合类表示曲线的任意集合。使用其构造函数创建它。</p>
<p><strong>CurveArrArray</strong></p>
<p>此集合类是 CurveArray 的集合。当使用 this 时，此数组的子元素的组织对 this 传递给的方法有意义;例如，在 NewExtrusion（） 中，多个 CurveArrays 应该表示不同的闭合循环。</p>
<h4 id="曲线创建"><a href="#曲线创建" class="headerlink" title="曲线创建"></a>曲线创建</h4><p>通常需要将曲线作为 Revit API 方法的输入。可以通过多种方式创建它们。</p>
<p>曲线具有许多派生类型，这些类型具有用于创建曲线的静态方法。基类 Curve 还具有从现有曲线创建新曲线的方法。</p>
<p>曲线创建方法会阻止创建短于 Revit 容差的曲线。此容差通过 Application.ShortCurveTolerance 属性公开。</p>
<p><strong>Curve</strong> </p>
<p>Curve 类具有多种从现有曲线创建新曲线的方法。</p>
<ul>
<li>Clone（） - 创建此曲线的副本。</li>
<li>CreateOffset（） - 从该曲线创建一个新的曲线偏移。</li>
<li>CreateReversed（） - 创建一条与现有曲线方向相反的新曲线</li>
<li>Curve.CreateTransformed（） - 创建曲线的新实例作为该曲线的变换。</li>
</ul>
<p><strong>Line</strong></p>
<p>有两种静态方法可用于创建新 Line。</p>
<ul>
<li>CreateBound() - 在两点之间创建新的边界线性曲线。</li>
<li>CreateUnbound() - 在给定原点和方向的情况下创建新的未绑定线性曲线。</li>
</ul>
<p>Code Region：创建unbound 的线性曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define start point and direction for unbound line</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ directionPt = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create line</span></span><br><span class="line">Line line = Line.CreateUnbound(startPoint, directionPt);</span><br></pre></td></tr></table></figure>

<p><strong>Arc</strong> </p>
<p>重载的静态 Create（） 方法允许通过以下三种方式之一创建 Arc：</p>
<ul>
<li><p>基于 3 点</p>
</li>
<li><p>代码区域：创建具有 3 个点的圆弧</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new arc using two ends and a point on the curve</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// start point of the arc</span></span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// end point of the arc</span></span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// point along arc</span></span><br><span class="line"></span><br><span class="line">Arc arc = Arc.Create(end0, end1, pointOnCurve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于平面、半径和角度</p>
</li>
<li><p>代码区域：使用平面创建圆弧</p>
</li>
<li><pre><code class="c#">Arc CreateArcByGivingPlane(Autodesk.Revit.ApplicationServices.Application application, Plane plane)
&#123;
    // Create an arc which is placed on the plane and whose center is the plane&#39;s origin
    double radius = 10;
    double startAngle = 0;      // The unit is radian
    double endAngle = 2 * Math.PI;        // this arc will be a circle
    return Arc.Create(plane, radius, startAngle, endAngle);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- based on center, radius, angles and two axes</span><br><span class="line">  基于圆心、半径、角度和两个轴</span><br><span class="line"></span><br><span class="line">  代码区域：使用轴创建圆弧</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  // Create a new arc defined by its center, radios, angles and 2 axes</span><br><span class="line">  double radius = 10;</span><br><span class="line">  double startAngle = 0;      // In radian</span><br><span class="line">  double endAngle = Math.PI;        // In radian</span><br><span class="line">  XYZ center = new XYZ(5, 0, 0);</span><br><span class="line">  XYZ xAxis = new XYZ(1, 0, 0);   // The x axis to define the arc plane. Must be normalized</span><br><span class="line">  XYZ yAxis = new XYZ(0, 1, 0);   // The y axis to define the arc plane. Must be normalized</span><br><span class="line">  </span><br><span class="line">  Arc arc = Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);</span><br></pre></td></tr></table></figure>

注意，对于后两个选项，如果角度范围等于或大于 2 * PI，则曲线将自动转换为无界圆。
</code></pre>
</li>
</ul>
<p><strong>Ellipse</strong> </p>
<p>静态 CreateCurve（） 方法创建一个椭圆，给定中心、椭圆的 x 向量和 y 向量半径、x 轴和 y 轴以定义椭圆的平面以及开始和结束参数。如果 x 半径和 y 半径几乎相等，它将返回一个圆弧，否则将返回一个椭圆。</p>
<p><strong>Cylindrical Helix</strong></p>
<p>CylindricalHelix 的静态 Create（） 方法从轴的基点、半径、x 向量、z 向量、螺距、起始角度（用于指定螺旋线的起点）和结束角度（用于指定螺旋线的终点）创建一个新的 CylindricalHelix。z 向量是轴方向，应垂直于 x 向量。正螺距产生右旋螺旋，而负螺距产生左旋螺旋。</p>
<p><strong>NURBS</strong> </p>
<p>NurbSpline 类表示 NURBS 或非均匀有理 B 样条曲线。重载的静态 CreateCurve（） 方法提供了多种创建 NURBS 曲线的方法。第一种方法是使用 Revit 在用户界面中绘制样条曲线时使用的相同计算。它需要一个控制点和权重的列表来创建新的 NurbSpline。样条的结和阶数是根据给定的控制点和权重计算的。</p>
<p>第二个选项还需要控制点和权重列表，还需要结列表以及 NurbSpline 的阶数。度数必须为 1 或更大。必须至少有 degree+1 个控制点。结的大小必须等于 degree、control points 数组的大小和 1 之和。第一度 + 1 节应该相同，最后一度 + 1 节也应相同。序列中间的结必须是非递减的。</p>
<p>第三个选项只需要控制点和权重。必须至少有 2 个控制点，并且权重的数量必须等于控制点的数量。所有权重的值都必须为正。</p>
<p>在所有情况下，创建的曲线可以是 NURBSpline 或更简单的曲线，例如直线或圆弧。这与 Revit 的期望一致，即在 Revit 图元中应使用尽可能简单的曲线表示。</p>
<p><strong>Hermite Spline</strong></p>
<p>重载的静态 HermiteSpline.Create（） 方法提供了两个用于创建 Hermite 样条的选项。最简单的方法是创建端点处具有默认切线的 Hermite 样条，并且只需要一个控制点列表和一个指示 Hermite 样条是否为周期性的标志。第二个选项将创建在其端点处具有指定切线的 Hermite 样条曲线。它有一个附加的 HermiteSplineTangents 对象参数，用于指定曲线起点和&#x2F;或终点的切线。</p>
<h4 id="曲线参数化"><a href="#曲线参数化" class="headerlink" title="曲线参数化"></a>曲线参数化</h4><p>Revit API 中的曲线可以描述为输入参数“u”的数学函数，其中曲线在 XYZ 空间中任何给定点的位置是“u”的函数。</p>
<p>曲线可以是绑定的，也可以是未绑定的。未绑定曲线没有端点，表示无限抽象（未绑定的直线）或循环曲线（圆或椭圆）。</p>
<p>在 Revit 中，参数“u”可以用两种方式表示：</p>
<ul>
<li>一个 ‘normalized’ 参数。参数的起始值为 0.0，结束值为 1.0。对于某些曲线类型，这使得沿曲线范围的曲线计算非常容易，例如，直线的中点位于参数 0.5 处。（请注意，对于更复杂的曲线方程式（如 Splines），不能总是做出此假设）。</li>
<li>一个 ‘raw’ 参数。参数的 start 和 end 值可以是任何值。对于给定的曲线，最小和最大原始参数的值可以通过 Curve.GetEndParameter（int） 获取。原始参数非常有用，因为它们的单位与 Revit 默认单位（英尺）相同。因此，要从起点沿曲线获得 5 英尺的位置，您可以在起点处获取 raw 参数，并在其上添加 5。原始参数也是计算未绑定曲线的唯一方法。</li>
</ul>
<p>方法 Curve.ComputeNormalizedParameter（） 和 Curve.ComputeRawParameter（） 会自动在两种参数类型之间缩放。方法 Curve.IsInside（） 计算原始参数，以查看它是否位于曲线的边界内。</p>
<p>您可以使用参数来计算曲线在任何给定位置的各种属性：</p>
<ul>
<li>给定曲线的 XYZ 位置。这是从 Curve.Evaluate（） 返回的。可以提供 raw 或 normalized 参数。如果您还调用 ComputeDerivatives（），则这也是 .Origin 属性。</li>
<li>给定曲线的第一个导数&#x2F;切线向量。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisX 属性。</li>
<li>给定曲线的第二个导数&#x2F;法向量。这是 .BasisY 属性。</li>
<li>给定曲线的<em>次法向量</em>，定义为切线向量和法向量的叉积。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisZ 属性。</li>
</ul>
<p>返回的所有向量都是非规格化的（但可以使用XYZ.Normalize（）规格化Revit API中的任何向量）。请注意，当曲线是直线时，将不会为法线和副法线向量设置值。可以使用切向量计算给定平面中直线的法向量。</p>
<p>API示例“DirectionCalculation”使用墙位置曲线的切线向量来查找朝南的外墙：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/directioncalculation_sample.png"></p>
<p>寻找并突出显示朝南的外墙</p>
<h4 id="曲线类型"><a href="#曲线类型" class="headerlink" title="曲线类型"></a>曲线类型</h4><p>Revit使用各种曲线类型来表示文档中的曲线几何图形。</p>
<table>
<thead>
<tr>
<th><strong>Curve type 曲线类型</strong></th>
<th>Revit API类**</th>
<th><strong>Definition 定义</strong></th>
<th><strong>Notes 注意</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bound line</td>
<td>Line</td>
<td>由端点定义的线段。</td>
<td>从Curve.GetEndpoint（）获取端点</td>
</tr>
<tr>
<td>Unbound line</td>
<td>Line</td>
<td>由位置和方向定义的无限线</td>
<td>使用Curve.IsBound标识这些。在原始参数&#x3D; 0处计算点和切向量，以找到直线方程的输入参数。</td>
</tr>
<tr>
<td>Arc</td>
<td>Arc</td>
<td>一个有界的圆弧</td>
<td>开始和结束在一定的角度。这些角度可以通过弧的每一端的原始参数值获得。</td>
</tr>
<tr>
<td>Circle</td>
<td>Arc</td>
<td>一个没有束缚的圆圈</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>Cylindrical helix</td>
<td>CylindricalHelix</td>
<td>绕在圆柱体上的螺旋线，与圆柱体的轴线成恒定的角度</td>
<td>仅在楼梯和扶手中的特定应用中使用，在访问其他Revit图元和几何图形的曲线时不应使用或遇到。</td>
</tr>
<tr>
<td>Elliptical arc</td>
<td>Ellipse</td>
<td>一个约束椭圆段</td>
<td></td>
</tr>
<tr>
<td>Ellipse</td>
<td>Ellipse</td>
<td>无约束椭圆</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>NURBS</td>
<td>NurbSpline</td>
<td>非均匀有理B样条曲线</td>
<td>用于在各种Revit工具中绘制的样条曲线，以及导入的几何图形</td>
</tr>
<tr>
<td>Hermite</td>
<td>HermiteSpline</td>
<td>一组点之间的样条插值</td>
<td>用于“逐点曲线”和软风管&#x2F;管道等工具，以及导入的几何图形</td>
</tr>
</tbody></table>
<p>所有Revit曲线类型的数学表示可以在曲线类型的数学表示找到。</p>
<h4 id="曲线类型的数学表示"><a href="#曲线类型的数学表示" class="headerlink" title="曲线类型的数学表示"></a>曲线类型的数学表示</h4><p>本节介绍Revit几何图形中遇到的曲线类型、其属性及其数学表示。</p>
<p><strong>Bound lines</strong></p>
<p>Bound lines由其端点定义。在Revit API中，从曲线-标高 GetEndPoint（）方法获取线的端点。</p>
<p>Bound lines上的点根据归一化参数“u”和Bound lines上点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_bound_line.png"></p>
<p><strong>Unbound lines</strong></p>
<p>Unbound lines在Revit API中进行了专门处理。不能使用大多数曲线属性，但是，当提供原始参数时，Evaluate（）和ComputeDerivatives（）可用于获取曲线沿着的位置。</p>
<p>根据原始参数“u”以及线原点和归一化方向向量，未绑定线的点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_unbound_line.png"></p>
<p><strong>Arcs and Circles</strong></p>
<p>圆弧和圆在Revit API中由Arc类表示。它们是根据半径、圆心和垂直于弧平面的矢量定义的，这些参数可以在Revit API中作为属性直接从Arc类访问。</p>
<p>圆的IsBound属性设置为true。这意味着它们只能通过使用原始参数（范围从0到2π）来计算，并且圆上的点的原始参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_arcs.png"></p>
<p>其中假设圆位于XY平面内。</p>
<p>弧的开始和结束都有一定的角度。这些角度可以通过弧的每一端处的原始参数值来获得，并且这些值之间的角度值可以插入到与上述相同的等式中。</p>
<p><strong>圆柱螺旋</strong></p>
<p>圆柱螺旋线在Revit API中由ExtradricalHashion类表示。它们是根据螺旋缠绕的圆柱体的轴的基点、半径、x和y矢量、螺距以及起始角和结束角来定义的。</p>
<p><strong>椭圆和椭圆弧</strong></p>
<p>椭圆和椭圆弧段在Revit API中由Ellipse类表示。与圆弧和圆类似，它们在给定平面中根据其X和Y半径、中心和垂直于椭圆平面的向量来定义。</p>
<p>完整椭圆的IsBound属性设置为true。与圆类似，它们可以通过0和2π之间的原始参数进行评估：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_ellipse.png"></p>
<p><strong>NurbSpline</strong></p>
<p>NURBS用于用户绘制为曲线或3D对象草图的一部分的样条线段。它们还用于表示某些类型的导入几何数据。</p>
<p>NurbSpline的数据包括：</p>
<ul>
<li>长度为n+1的控制点数组</li>
<li>weights数组，长度也是n+1</li>
<li>曲线阶数，其值等于曲线阶数（k）的小一</li>
<li>长度为n + k +1的节点向量</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_nurb_spline.png"></p>
<p>Revit的草图绘制工具中使用的NurbSplines可以使用算法单独从控制点和阶数生成。可以在外部复制Revit算法执行的计算，请参见下面的示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">NurbSplinespline = curve.GeometryCurve <span class="keyword">as</span> NurbSpline;</span><br><span class="line">DoubleArrayknots = spline.Knots;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert to generic collection</span></span><br><span class="line">List knotList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; knots.Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    knotList.Add(knots.get_Item(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preparation - get distance between each control point</span></span><br><span class="line">IList controlPoints = spline.CtrlPoints;</span><br><span class="line"><span class="built_in">int</span> numControlPoints = controlPoints.Count;</span><br><span class="line"><span class="built_in">double</span>[] chordLengths = <span class="keyword">new</span> <span class="built_in">double</span>[numControlPoints - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> iControlPoint = <span class="number">1</span>; iControlPoint &lt; numControlPoints; ++iControlPoint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> chordLength = </span><br><span class="line">       controlPoints[iControlPoint].DistanceTo(controlPoints[iControlPoint - <span class="number">1</span>]);</span><br><span class="line">    chordLengths[iControlPoint - <span class="number">1</span>] = chordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> degree = spline.Degree;</span><br><span class="line"><span class="built_in">int</span> order = degree + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> numKnots = numControlPoints + order;</span><br><span class="line"><span class="built_in">double</span>[] computedKnots = <span class="keyword">new</span> <span class="built_in">double</span>[numKnots];</span><br><span class="line"><span class="built_in">int</span> iKnot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="built_in">double</span> startKnot = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">double</span> knot = startKnot;</span><br><span class="line"><span class="keyword">for</span>(iKnot = <span class="number">0</span>; iKnot &lt; order; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interior knots based on chord lengths</span></span><br><span class="line"><span class="built_in">double</span> prevKnot = knot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt;= numControlPoints; ++iKnot) </span><br><span class="line">    <span class="comment">// Last loop computes end knot but does not set interior knot.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> knotIncrement = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> jj = iKnot - order; jj &lt; iKnot - <span class="number">1</span>; ++jj)</span><br><span class="line">    &#123;</span><br><span class="line">        knotIncrement += chordLengths[jj];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    knotIncrement /= degree;</span><br><span class="line">    knot = prevKnot + knotIncrement;</span><br><span class="line">    <span class="keyword">if</span> (iKnot &lt; numControlPoints)</span><br><span class="line">        computedKnots[iKnot] = knot;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;   <span class="comment">// Leave &quot;knot&quot; set to the end knot; do not increment &quot;ii&quot;.</span></span><br><span class="line"></span><br><span class="line">    prevKnot = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt; numKnots; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HermiteSpline</strong></p>
<p>Hermite样条用于在一组控制点之间插值的曲线，如MEP中的逐点曲线和软风管和管道。它们还用于表示某些类型的导入几何数据。在Revit API中，HermiteSpline类提供了通过“控制点”、“切线”和“参数”属性访问点阵列、切线向量和参数的功能。</p>
<p>Hermite样条中两个节点之间的曲线方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_1.png"></p>
<p>其中，Pk和Pk+1表示每个节点处的点，Mk和Mk+1表示切向量，并且uk和uk+1表示节点处的参数，并且基函数为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_2.png"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite5.png"></p>
<h3 id="GeometryInstances"><a href="#GeometryInstances" class="headerlink" title="GeometryInstances"></a>GeometryInstances</h3><p>GeometryInstance表示Revit以默认配置存储的一组几何图形，然后根据图元的属性将其转换到正确的位置。最常见的遇到几何图形的情况是在族实例中。Revit使用几何图形库，允许它存储给定族的几何图形的单个副本，并在多个实例中重复使用该副本。</p>
<p>请注意，并非所有族实例都将包括几何图形。当Revit需要为给定实例制作族几何图形的唯一副本时（由于局部连接、交点以及与实例放置相关的其他因素的影响），不会遇到GeometryInstance;相反，实体几何图形将位于层次的顶层。</p>
<p>GeometryInstance提供了通过GetSymbolGeometry（）和GetInstanceGeometry（）方法读取其几何体的能力。这些方法返回另一个Autodesk.Revit.DB.GeometryElement，可以像第一级返回一样对其进行分析。</p>
<p>GetSymbolGeometry（）返回在族的坐标系中表示的几何图形。例如，当您需要“通用”表格的图片而不考虑项目中的方向和放置位置时，请使用此选项。这也是唯一一个将实际的Revit几何图形对象返回给您而不是复制的重载。这一点很重要，因为使用此几何图形作为输入来创建其他图元的操作（例如，标注尺寸或放置基于面的族）需要参照原始几何图形。</p>
<p>GetInstanceGeometry（）返回在放置实例的项目的坐标系中表示的几何图形。例如，当需要项目中实例的特定几何图形的图片时（例如，确保桌子与房间的墙壁平行放置），请使用此选项。这始终会返回图元几何图形的副本，因此，虽然它适用于实施导出器或几何分析工具，但不适合用于创建引用此几何图形的其他Revit图元。</p>
<p>GetInstanceGeometry（）和GetSymbolGeometry（）也有重载，它们可以通过任意坐标系变换几何体。这些方法始终返回类似于GetInstanceGeometry（）的副本。</p>
<p>GeometryInstance还存储了从符号坐标空间到实例坐标的变换。此转换可作为Transform属性访问。它也是通过GetInstanceGeometry（）提取几何体副本时使用的变换。有关更多详细信息，请参见几何辅助类。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/instances_transformed.png"></p>
<p>2个使用不同变换放置的族实例-将从两个族实例中获取相同的几何图形</p>
<p>对于某些族，可以嵌套多层。如果您遇到嵌套实例，则可能会以与第一级实例类似的方式对其进行解析。</p>
<p>给出了两个示例来解释如何解析实例的几何形状。</p>
<p>在此示例中，从GeometryInstance方法GetInstanceGeometry（）提取曲线。</p>
<p>代码区域：从实例获取曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAndTransformCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app,</span></span></span><br><span class="line"><span class="params"><span class="function">            Autodesk.Revit.DB.Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">   Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get geometry object</span></span><br><span class="line">   <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">      Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">             geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">      &#123;</span><br><span class="line">         GeometryElement instanceGeometryElement = instance.GetInstanceGeometry();</span><br><span class="line">         <span class="keyword">foreach</span> (GeometryObject o <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Try to find curves</span></span><br><span class="line">            Curve curve = o <span class="keyword">as</span> Curve;</span><br><span class="line">            <span class="keyword">if</span> (curve != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// The curve is already transformed into the project coordinate system</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，使用GetSymbolGeometry（）从实例中获取实体。然后使用GeometryInstance.Transform将组成点变换到项目坐标系中。</p>
<p>代码区域：从实例获取可靠信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetAndTransformSolidInfo</span>(<span class="params">Application application, Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get geometry object</span></span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">                Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">      geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    GeometryElement instanceGeometryElement = instance.GetSymbolGeometry();</span><br><span class="line">                    <span class="keyword">foreach</span> (GeometryObject instObj <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Solid solid = instObj <span class="keyword">as</span> Solid;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == solid || <span class="number">0</span> == solid.Faces.Size || <span class="number">0</span> == solid.Edges.Size)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                Transform instTransform = instance.Transform;</span><br><span class="line">                                <span class="comment">// Get the faces and edges from solid, and transform the formed points</span></span><br><span class="line">                                <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Mesh mesh = face.Triangulate();</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> mesh.Vertices)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> solid.Edges)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> edge.Tessellate())</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关检索到的族实例几何图形的详细信息，请参见示例：从梁中检索几何图形数据。</p>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>网格是三角形边界的集合，它们共同形成3D形状。如果Revit图元是通过某些导入操作创建的，并且还用于某些本机Revit图元（如TopographySurface），则通常会在Revit图元几何图形中遇到网格。还可以通过调用任意给定Revit面的Face.Triangulate（）来获取网格。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/mesh.png"></p>
<p>表示圆环面的网格</p>
<p>以下代码示例说明了如何将Revit面的几何体作为网格获取：</p>
<p>代码区域：提取几何体的网格</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetTrianglesFromFace</span>(<span class="params">Face face</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get mesh</span></span><br><span class="line"></span><br><span class="line">        Mesh mesh = face.Triangulate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.NumTriangles; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               MeshTriangle triangle = mesh.get_Triangle(i);</span><br><span class="line"></span><br><span class="line">               XYZ vertex1 = triangle.get_Vertex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex2 = triangle.get_Vertex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex3 = triangle.get_Vertex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：用于Revit显示目的的近似公差在构造网格时由Triangulate（）方法（上面使用的）的无参数重载使用。Triangulate（）的重载接受一个double，允许将细节级别设置在0（粗糙）和1（精细）之间。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点表示3D空间中的可见坐标。</p>
<p>点通常出现在体量族图元（如ReferencePoint）中。Point类提供对其坐标的读访问，并能够获取对该点的引用，以用作其他函数的输入。</p>
<p><strong>点创建</strong></p>
<p>有两种方法可以创建点：</p>
<ul>
<li>Create(XYZ) - 在给定坐标处创建一个点。</li>
<li>Create(XYZ, ElementId) - 在给定坐标处创建一个Point，并根据GraphicsStyle元素（由ElementId指定）为其指定颜色。</li>
</ul>
<h3 id="PolyLine"><a href="#PolyLine" class="headerlink" title="PolyLine"></a>PolyLine</h3><p>PolyLine是由一组坐标点定义的线段的集合。这些通常在导入的几何体中遇到。PolyLine类提供了读取坐标的能力：</p>
<ul>
<li>PolyLine.NumberOfCoordinates – 在坐标系中的点数</li>
<li>PolyLine.GetCoordinate() – 通过索引获取坐标</li>
<li>PolyLine.GetCoordinates() – 获取对象中所有坐标的集合</li>
<li>PolyLine.Evaluate() – 给定一个规格化参数（从0到1），沿整个PolyLine范围沿着计算XYZ点</li>
</ul>
<h3 id="实体、面和边"><a href="#实体、面和边" class="headerlink" title="实体、面和边"></a>实体、面和边</h3><p>实体是一个Revit API对象，表示面和边的集合。通常，在Revit中，这些集合是完全封闭的体积，但也可能遇到壳或部分有界体积。请注意，有时Revit几何图形将包含未使用的实体，这些实体包含零个边和面。选中“边”和面成员以过滤掉这些实体。</p>
<p>Revit API提供了读取面和边的集合以及计算实体的表面积、体积和质心的功能。</p>
<p>本节中的页面</p>
<ul>
<li>边和面参数化</li>
<li>面</li>
<li>面分析</li>
<li>面分割</li>
<li>面类型</li>
<li>面类型的数学表示</li>
<li>实体分析</li>
<li>实体和面的创建</li>
</ul>
<h5 id="边和面参数化"><a href="#边和面参数化" class="headerlink" title="边和面参数化"></a>边和面参数化</h5><p>边是给定面的边界曲线。</p>
<p>使用EdgeLoops属性迭代面的边。每个循环表示面上的一个闭合边界。边始终参数化为0到1。可以使用Edge.AsCurve（）和Edge.AsCurveFollowingFace（）函数提取边缘的Curve表示。</p>
<p>边通常通过计算两个面的相交来定义。但Revit在绘制图形时不会重新计算此交点。因此，边存储一个点列表-直边的端点和曲边的细分列表。这些点是两个面上的参数坐标。这些点可以通过TessellateOnFace（）方法获得。</p>
<p>剖面产生“切割边缘”。这些是人工边-不表示模型级几何体的一部分，因此不提供参照。</p>
<p><strong>边的方向</strong></p>
<p>方向通常在第一个面上为顺时针方向（第一个面表示Revit已为特定边标识的任意面）。但是，由于两个不同的面在一个特定的边相交，并且无论您关注的是哪个面，该边都具有相同的参数化方向，因此有时需要确定特定面上的边的方向。</p>
<p>下图说明了这是如何工作的。对于面0，所有边都是顺时针参数化的（？？？）。对于面1，与面0共享的边不会重新参数化;因此，相对于面1，该边具有相反的方向，并且某些边在两条边的参数均为0（或1）的地方相交。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_edge_direction.png"></p>
<p>边参数化</p>
<p>API示例“PanelEdgeLengthAngle”显示了如何识别给定面的反转边。它使用边端点处的切向量来计算相邻边之间的角度，并检测是否在每个交点处翻转切向量以计算适当的角度。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/paneledgelengthangle_sample.png"></p>
<p>PanelEdgeLengthAngle结果</p>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>可以将Revit API中的面描述为两个输入参数“u”和“v”的数学函数，其中面在XYZ空间中任意给定点处的位置是参数的函数。</p>
<p>U和V方向是根据给定面的形状自动确定的。恒定U或V的线可以表示为面上的网格线，如下例所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_params.png"></p>
<p>圆柱面上的U和V网格线</p>
<p>可以使用UV参数来评估任意给定位置处的面的各种属性：</p>
<ul>
<li>参数是否在面的边界内，使用Face.IsInside（）</li>
<li>指定UV参数值处给定面的XYZ位置。这是从Face.Evaluate（）返回的。如果您还在调用ComputeDerivatives（），则这也是该方法返回的Transform的.Origin属性。</li>
<li>给定面在U方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisX属性</li>
<li>给定面在V方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisY属性。</li>
<li>给定面部的法向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisZ属性。</li>
<li>关于U的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的. UUD派生属性。</li>
<li>相对于V的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.VVDerivative。</li>
<li>给定面的混合导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.MixedDerivative。</li>
</ul>
<p>返回的所有向量都是非单位化的。</p>
<h5 id="面分析"><a href="#面分析" class="headerlink" title="面分析"></a>面分析</h5><p>有几种面方法是适用于几何分析的工具。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法计算面与曲线之间的相交。它可用于识别：</p>
<ul>
<li>两个对象之间的交点</li>
<li>如果有一条边靠近该位置，则为距离交点最近的边</li>
<li>与面完全重合的曲线</li>
<li>不相交的曲线和面</li>
</ul>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到输入面上，并返回有关投影点、到面的距离以及到投影点的最近边的信息。</p>
<p><strong>Triangulate()</strong></p>
<p>Triangulate方法获得一个近似于面的三角形网格。此方法有两个重载。无参数方法与Curve.Tessellate（）类似，因为网格的点在Revit使用的输入公差范围内（略大于1&#x2F;16”）是精确的。第二个Triangulate方法接受一个细节级别作为参数，范围从0（粗略）到1（精细）。</p>
<h5 id="面分割"><a href="#面分割" class="headerlink" title="面分割"></a>面分割</h5><p>可以通过“分割面”命令将面分割为面域。Face.HasRegions属性将报告面是否包含使用Split Face命令创建的区域，而Face.GetRegions（）方法将返回一个面列表，一个面用于承载Split Face的对象的主面（如地板的墙壁），一个面用于每个Split Face区域。</p>
<p>FaceSplitter类表示拆分面的元素。FaceSplitter.SplitElementId属性提供其面被此元素分割的元素的ID。FaceSplitter类可用于按类型过滤和查找这些面，如下所示。</p>
<p>代码区域：查找面分割元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options opt = app.Create.NewGeometryOptions();</span><br><span class="line">opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">opt.IncludeNonVisibleObjects = <span class="literal">true</span>;</span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">ICollection splitElements = collector.OfClass(<span class="keyword">typeof</span>(FaceSplitter)).Cast().ToList();</span><br><span class="line"><span class="keyword">foreach</span>(FaceSplitter faceSplitter <span class="keyword">in</span> splitElements)</span><br><span class="line">&#123;</span><br><span class="line">    Element splitElement = doc.GetElement(faceSplitter.SplitElementId);</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = faceSplitter.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Line line = geomObj <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (line != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            XYZ end1 = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">            XYZ end2 = line.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">double</span> length = line.ApproximateLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="面类型"><a href="#面类型" class="headerlink" title="面类型"></a>面类型</h5><p>Revit使用各种曲线类型来表示文档中的面几何图形。其中包括：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Face type **</td>
<td><strong>Revit API Class</strong></td>
<td>**Definition **</td>
<td><strong>Notes 注意</strong></td>
</tr>
<tr>
<td>Plane</td>
<td>PlanarFace</td>
<td>由原点与U和V的单位向量定义的平面。</td>
<td></td>
</tr>
<tr>
<td>Cylinder</td>
<td>CylindricalFace</td>
<td>通过沿着轴拉伸圆定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Cone</td>
<td>ConicalFace</td>
<td>一条线绕一个轴旋转而定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Revolved face</td>
<td>RevolvedFace</td>
<td>由任意曲线绕轴旋转定义的面。</td>
<td>Radius提供旋转平面的单位矢量，不涉及“半径”。</td>
</tr>
<tr>
<td>Ruled surface</td>
<td>RuledFace</td>
<td>通过放样两条轮廓曲线或一条轮廓曲线和一个点之间的直线而定义的面。</td>
<td>曲线和点都可以作为属性获得。</td>
</tr>
<tr>
<td>Hermite face</td>
<td>HermiteFace</td>
<td>由点之间的Hermite插值定义的面。</td>
<td></td>
</tr>
</tbody></table>
<p>所有Revit面类型的数学表示可以在其中找到：面类型的数学表示。</p>
<h5 id="面类型的数学表示"><a href="#面类型的数学表示" class="headerlink" title="面类型的数学表示"></a>面类型的数学表示</h5><p>本节介绍Revit几何图形中遇到的面类型、其属性及其数学表示。</p>
<p><strong>PlanarFace</strong></p>
<p>由原点与U和V的单位向量定义的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_planar.png"></p>
<p><strong>CylindricalFace</strong> </p>
<p>通过沿轴沿着拉伸圆而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>拉伸轴。</li>
<li>在X和Y中的“径向矢量”。这些向量是圆的单位向量乘以圆的半径。注意，单位向量可以表示右手或左手控制。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cylinder.png" alt="img"></p>
<p><strong>ConicalFace</strong> </p>
<p>由一条线绕一个轴旋转而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>圆锥体的轴。</li>
<li>在X和Y中的“径向矢量”。这些矢量是单位矢量乘以旋转形成的圆的半径。注意，单位向量可以表示右手或左手控制。</li>
<li>The half angle of the face.<br>面的半个角。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cone.png" alt="img"></p>
<p><strong>RevolvedFace</strong></p>
<p>由任意曲线绕轴旋转定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点</li>
<li>面的轴线</li>
<li>轮廓曲线</li>
<li>旋转曲线的单位向量（姑且地称为“半径”）</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_revolved.png" alt="img"></p>
<p><strong>RuledFace</strong> </p>
<p>RuledFace 是通过放样两条轮廓曲线之间或曲线与点之间的直线而创建的。Revit API提供曲线和点作为属性。</p>
<p>该曲面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled1.png" alt="img"> 如果两条曲线都有效。如果其中一条曲线被替换为一个点，则方程简化为以下之一：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled2.png" alt="img"> <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled3.png" alt="img"> 没有曲线和两个点的RuledFace是不会被返回。</p>
<p><strong>HermiteFace</strong></p>
<p>立方Hermite样条曲线面。Revit API提供：</p>
<ul>
<li>样条插值点的u和v参数数组</li>
<li>每个节点上的3D点的数组（数组按u递增，然后v递增的方式组织）</li>
<li>每个节点的切向量数组</li>
<li>每个节点处的扭曲向量数组</li>
</ul>
<p>在节点（u1，v1）和（u2，v2）之间，该曲面的参数表示为：</p>
<p>其中 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite2.png" alt="img"> ， <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite3.png" alt="img"> ，<strong>MH</strong>是Hermite矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite4.png" alt="img"><br>并且B是从插值点处的面属性获得的系数矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite5.png" alt="img"></p>
<h5 id="实体分析"><a href="#实体分析" class="headerlink" title="实体分析"></a>实体分析</h5><p><strong>实体与曲线的交线</strong></p>
<p>方法Solid.IntersectWithCurve（）计算闭合体积实体和曲线之间的交点。SolidCurveIntersectionOptions类可以指定IntersectWithCurve（）方法的结果是否将包括实体体积内部或外部的曲线段。实体内的曲线段将包括与实体的面重合的曲线段。曲线段和曲线段的参数都可以在结果中使用。</p>
<p>以下示例使用IntersectWithCurve（）方法计算柱内钢筋的长度。</p>
<p>代码区域：查找实体和曲线之间的交点</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindColumnRebarIntersections</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We will be computing the total length of the rebar inside the column</span></span><br><span class="line">    <span class="built_in">double</span> totalRebarLengthInColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rebar hosted by this column</span></span><br><span class="line">    RebarHostData rebarHostData = RebarHostData.GetRebarHostData(column);</span><br><span class="line">    <span class="keyword">if</span> (rebarHostData == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IList rebars = rebarHostData.GetRebarsInHost();</span><br><span class="line">    <span class="keyword">if</span> (rebars.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve geometry of the column</span></span><br><span class="line">    Options geomOptions = <span class="keyword">new</span> Options();</span><br><span class="line">    geomOptions.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">    geomOptions.DetailLevel = ViewDetailLevel.Fine;</span><br><span class="line">    GeometryElement elemGeometry = column.get_Geometry(geomOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine all geometry primitives of the column</span></span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject elemPrimitive <span class="keyword">in</span> elemGeometry)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip objects that are not geometry instances</span></span><br><span class="line">        GeometryInstance gInstance = elemPrimitive <span class="keyword">as</span> GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (gInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve geometry of each found geometry instance</span></span><br><span class="line">        GeometryElement instGeometry = gInstance.GetInstanceGeometry();</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject instPrimitive <span class="keyword">in</span> instGeometry)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip non-solid sobject</span></span><br><span class="line">            Solid solid = instPrimitive <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">if</span> (solid == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SolidCurveIntersectionOptions intersectOptions = <span class="keyword">new</span> SolidCurveIntersectionOptions();</span><br><span class="line">            <span class="keyword">foreach</span> (Rebar rebar <span class="keyword">in</span> rebars)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the centerlines for the rebar to find their intersection with the column</span></span><br><span class="line">                <span class="built_in">bool</span> selfIntersection = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresHooks = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresBends = <span class="literal">false</span>;</span><br><span class="line">                IList curves = rebar.GetCenterlineCurves(selfIntersection, suppresHooks, suppresBends, MultiplanarOption.IncludeOnlyPlanarCurves, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Examine every segment of every curve of the centerline</span></span><br><span class="line">                <span class="keyword">foreach</span> (Curve curve <span class="keyword">in</span> curves)</span><br><span class="line">                &#123;</span><br><span class="line">                    SolidCurveIntersection intersection = solid.IntersectWithCurve(curve, intersectOptions);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> segment = <span class="number">0</span>; segment &lt;= intersection.SegmentCount - <span class="number">1</span>; segment++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Calculate length of the rebar that is inside the column</span></span><br><span class="line">                        Curve curveInside = intersection.GetCurveSegment(segment);</span><br><span class="line">                        <span class="built_in">double</span> rebarLengthInColumn = curveInside.Length;</span><br><span class="line">                        totalRebarLengthInColumn = totalRebarLengthInColumn + rebarLengthInColumn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实体和面的创建"><a href="#实体和面的创建" class="headerlink" title="实体和面的创建"></a>实体和面的创建</h5><p>实体和面有时用作其他实用程序的输入。Revit API提供了几个例程，可用于从头开始创建此类几何图形或从其他输入中导出此类几何图形。</p>
<p><strong>Transformed geometry</strong></p>
<p>方法</p>
<ul>
<li>GeometryElement.GetTransformed()</li>
</ul>
<p>返回应用了变换的输入几何图元的副本。由于此几何图形是副本，因此其成员不能用作其他Revit图元的输入参照，但可用于几何分析和提取。</p>
<p><strong>Geometry creation utilities</strong></p>
<p>GeometryCreationUtilities类是一个允许构造基本实体形状的实用程序类：</p>
<ul>
<li>Extrusion 拉伸</li>
<li>Loft</li>
<li>Revolution 旋转</li>
<li>Sweep 放样</li>
<li>Blend 融合</li>
<li>SweptBlend 放样融合</li>
</ul>
<p>生成的几何图形不会作为任何元素的一部分添加到文档中。然而，创建的Solid可用作其他API函数的输入，包括：</p>
<ul>
<li>作为分析可视化框架（SpatialFieldManager.AddSpatialFieldPrimitive（））中方法的输入面-这允许用户相对于文档中的其他元素可视化创建的形状</li>
<li>作为通过相交查找3D元素的输入实体</li>
<li>作为布尔运算的一个或多个输入</li>
<li>作为几何计算的一部分（例如，使用Face.Project（）、Face.Intersect（）或其他面、实体和边几何方法）</li>
</ul>
<p>下面的示例使用GeometryCreationUtilities类基于位置和高度创建圆柱形。例如，这可以用于在墙端点周围创建体积，以便查找与墙端点非常接近的其他墙：</p>
<p>代码区域：创建圆柱体</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build cylinder centered at wall end point, extending 3&#x27; in diameter</span></span><br><span class="line">CurveLoop cylinderLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">XYZ arcCenter = <span class="keyword">new</span> XYZ(endPoint.X, endPoint.Y, elevation);</span><br><span class="line">Application application = wall.Document.Application;</span><br><span class="line">Arc firstArc = Arc.Create(arcCenter, <span class="number">1.5</span>, <span class="number">0</span>, Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line">Arc secondArc = Arc.Create(arcCenter, <span class="number">1.5</span>, Math.PI, <span class="number">2</span> * Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line"></span><br><span class="line">cylinderLoop.Append(firstArc);</span><br><span class="line">cylinderLoop.Append(secondArc);</span><br><span class="line"></span><br><span class="line">List singleLoop = <span class="keyword">new</span> List();</span><br><span class="line">singleLoop.Add(cylinderLoop);</span><br><span class="line"></span><br><span class="line">Solid proximityCylinder = GeometryCreationUtilities.CreateExtrusionGeometry(singleLoop, XYZ.BasisZ, height);</span><br></pre></td></tr></table></figure>

<p><strong>Boolean operations</strong> </p>
<p>BooleanOperationsUtils类提供用于组合一对实心几何体对象的方法。</p>
<p>ExecuteBooleanOperation（）方法获取输入实体的副本，并生成新实体作为结果。它的第一个参数可以是任何实体，可以直接从Revit图元获得，也可以通过其他操作（如GeometryCreationUtils）创建。</p>
<p>方法ExecuteBooleanOperationModifyingOriginalSolid（）直接对第一个输入实体执行布尔运算。第一个输入必须是不是直接从Revit图元获得的实体。属性GeometryObject.IsElementGeometry可以标识实体是否适合作为此方法的输入。</p>
<p>这两种方法的选项包括操作类型：并集、差集或交集。下面的示例演示如何获取两个实体的交点，然后查找体积。</p>
<p>代码区域：实体相交的体积</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComputeIntersectionVolume</span>(<span class="params">Solid solidA, Solid solidB</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Solid intersection = BooleanOperationsUtils.ExecuteBooleanOperation(solidA, solidB, BooleanOperationsType.Intersect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> volumeOfIntersection = intersection.Volume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法CutWithHalfSpace（）和CutWithHalfSpaceModifyingOriginalSolid（）生成一个实体，该实体是输入Solid与给定Plane正侧的半空间的交点。平面的正侧是平面。法线指向的一侧。第一种方法使用结果创建新实体，而第二种方法修改现有实体（必须是由应用程序创建的实体，而不是从Revit图元获得的实体）。</p>
<h2 id="Geometry-Helper-类"><a href="#Geometry-Helper-类" class="headerlink" title="Geometry Helper 类"></a>Geometry Helper 类</h2><p>API中有几个Geometry Helper类。Helper类用于描述某些元素的几何信息，例如使用BoundingBoxXYZ类为视图定义CropBox。</p>
<ul>
<li>BoundingBoxXYZ - 用于定义三维视图截面区域等情况的三维矩形框。</li>
<li>Transform - 变换仿射3D空间。</li>
<li>Reference -Revit模型中几何对象的稳定参照，在创建尺寸标注等图元时使用。</li>
<li>Plane - 几何中的平面。</li>
<li>Options - 用于分析几何图形的用户首选项。</li>
<li>XYZ - 表示3D空间中坐标的对象。</li>
<li>UV - 表示2D空间中坐标的对象。</li>
<li>BoundingBoxUV - 平行于坐标轴的2D矩形。</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>在Revit应用程序中，变换仅限于3x4变换（矩阵），即相对于模型空间的其余部分和其他对象变换对象在模型空间中的位置。变换是根据模型空间中的位置和方向构建的。三个方向矢量（BasisX、BasisY和BasisZ属性）和原点提供所有变换信息。由四个值形成的矩阵如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-362AC8B3-CB53-4DB6-8606-5D90F2C8BFC4-low.png"></p>
<p>将变换应用于点如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5ABFA7C5-22F5-4A86-9878-CB0812834EB8-low.png"></p>
<p>Transform Of Point方法实现了前面的函数。</p>
<p>下面几节将介绍Geometry.Transform类的属性和方法。</p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>转换Identity </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4AD4178C-E897-44E0-93CD-AA8C1FD39AC4-low.png">CreateReflection()</p>
<p>反射指定的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-DCA42587-9FD4-4AE3-95A8-1D45ED472D14-low.png">图112：墙反射关系</p>
<p>如上图所示，参照平面镜像了一面墙。CreateReflection（）方法需要参考平面的几何平面信息。</p>
<p>代码区域20-8：使用反射属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Transform <span class="title">Reflect</span>(<span class="params">ReferencePlane refPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform mirTrans = Transform.CreateReflection(refPlane.GetPlane());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mirTrans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CreateRotation-and-CreateRotationAtPoint"><a href="#CreateRotation-and-CreateRotationAtPoint" class="headerlink" title="CreateRotation() and CreateRotationAtPoint()"></a>CreateRotation() and CreateRotationAtPoint()</h4><p>围绕位于（0，0，0）或指定点的指定轴旋转指定角度。</p>
<h4 id="CreateTranslation"><a href="#CreateTranslation" class="headerlink" title="CreateTranslation()"></a>CreateTranslation()</h4><p>按指定的向量平移。给定一个矢量XYZ数据，如下创建一个变换：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E661E3C-0609-44C0-A7D5-52E993FEA94C-low.png"></p>
<h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p>变换行列式</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4570D0C0-0834-4A9E-AB7C-751F771AAE5B-low.png"></p>
<h4 id="HasReflection"><a href="#HasReflection" class="headerlink" title="HasReflection"></a>HasReflection</h4><p>这是一个布尔值，指示变换是否产生反射。</p>
<h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>表示变换比例的值。</p>
<h4 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h4><p>逆变换。如果存在变换矩阵B使得A<em>B &#x3D; B</em> A &#x3D; I（单位元），则变换矩阵A是可逆的。</p>
<h4 id="IsIdentity"><a href="#IsIdentity" class="headerlink" title="IsIdentity"></a>IsIdentity</h4><p>指示此转换是否为标识的布尔值。</p>
<h4 id="IsTranslation"><a href="#IsTranslation" class="headerlink" title="IsTranslation"></a>IsTranslation</h4><p>布尔值，指示此转变是否是转换。</p>
<h4 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h4><p>将转换乘以指定的变换并返回结果。</p>
<p>Operator*-将两个指定的转换相乘。</p>
<h4 id="ScaleBasis"><a href="#ScaleBasis" class="headerlink" title="ScaleBasis"></a>ScaleBasis</h4><p>缩放基向量并返回结果。</p>
<h4 id="ScaleBasisAndOrigin"><a href="#ScaleBasisAndOrigin" class="headerlink" title="ScaleBasisAndOrigin"></a>ScaleBasisAndOrigin</h4><p>缩放基向量，变换原点返回结果。</p>
<h4 id="OfPoint"><a href="#OfPoint" class="headerlink" title="OfPoint"></a>OfPoint</h4><p>将transformation到指定点。使用Origin属性。</p>
<h4 id="OfVector"><a href="#OfVector" class="headerlink" title="OfVector"></a>OfVector</h4><p>将transform转换为向量。不使用Origin属性。</p>
<h4 id="AlmostEqual"><a href="#AlmostEqual" class="headerlink" title="AlmostEqual"></a>AlmostEqual</h4><p>比较两个转换。AlmostEqual与Revit核心代码中的计算机制和精度一致。此外，在Transform类中没有实现Equal和&#x3D;&#x3D;运算符。</p>
<p>API提供了几种完成几何变换的快捷方式。几个几何体类中的Transformed属性用于执行此工作，如下表所示。</p>
<p>表48：Transformed 方法</p>
<table>
<thead>
<tr>
<th><strong>Class Name 类名</strong></th>
<th><strong>Function Description 功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Curve.get_Transformed(Transform transform)</td>
<td>将指定的变换转换为曲线</td>
</tr>
<tr>
<td>GeometryElement.GetTransformed(Transform transform)</td>
<td>转换原始元素中几何图形的副本。</td>
</tr>
<tr>
<td>Profile.get_Transformed(Transform transform)</td>
<td>转换轮廓并返回结果。</td>
</tr>
<tr>
<td>Mesh.get_Transformed(Transform transform) M</td>
<td>转换网格并返回结果。</td>
</tr>
</tbody></table>
<p>注意：transformed方法克隆自身，然后返回转换后的克隆结果。 除了这些方法之外，Instance类（它是族实例、链接实例和导入的CAD内容等图元的父类）还有两个方法，可以为给定的Instance提供变换。GetTransform（）方法根据实例的放置方式获得实例的基本变换，而GetTotalTransform（）方法提供使用真北变换修改的变换，例如导入实例。</p>
<p><strong>Reference</strong> </p>
<p>Reference 在元素创建中非常有用。 创建尺寸需要参照。 参考以灵活的方式标识几何表示树内的路径。 树用于查看特定的几何表达创建。API基于不同的Pick指针类型公开四种类型的引用。它们以不同的方式从API中检索：</p>
<ul>
<li>对于点-Curve.GetEndPointReference方法</li>
<li>对于曲线（直线、圆弧等）- Curve.Reference属性</li>
<li>对于面-face.Reference属性</li>
<li>对于剪切边-Edge.Reference property</li>
</ul>
<p>不能任意使用不同的参考类型。举例来说： NewLineBoundaryConditions（）方法需要Line的引用。 NewAreaBoundaryConditions（）方法需要面的引用。 NewPointBoundaryConditions（）方法需要Point的引用。 Reference. ConvertToStableRepresentation（）方法可用于将对几何体对象（例如面、边或曲线）的引用另存为字符串，然后在同一Revit任务中（甚至在存在同一文档的不同任务中）使用ParseFromStableRepresentation（）方法以字符串作为输入来获取相同的引用。</p>
<p> Options Geometry 通常从索引属性Element.Geometry中提取。梁、柱或支撑的原始几何图形在实例通过连接、剪切、复制、拉伸或其他后处理进行修改之前，可以使用FamilyInstance. GetOriginalGeometry（）方法提取。Element. Geometry和FamilyInstance. GetOriginalGeometry（）都接受必须提供的options 类。</p>
<p>options 类根据其属性自定义接收的输出类型： </p>
<ul>
<li>ComputeReferences -指示检索几何信息时是否计算几何参照。默认值为false，因此如果此属性未设置为true，则引用将不可访问。 </li>
<li>IncludeNonVisibleObjects -指示还返回在默认视图中不可见的几何对象。 </li>
<li><em>View</em> -从特定视图获取几何信息。请注意，如果指定了视图，则将使用此视图的详细程度来代替“DetailLevel”。 </li>
<li>DetailLevel -指示首选详细程度。默认值为“中”。</li>
</ul>
<p> ComputeReferences  如果将此属性设置为false，则API不计算几何参照。从几何体树检索的所有引用属性都不返回任何内容。有关引用的更多详细信息，请参阅“引用”部分。与FamilyInstance.GetOriginalGeometry（）一起使用时，此选项不能设置为true。 </p>
<p>IncludeNonVisibleObjects 大多数不可见几何图形是用户在编辑元素时看到的构造和条件几何图形（即，窗族实例的中心平面）。此属性的默认值为false。但是，某些条件可见几何图形表示真实对象（例如Revit中风管周围的隔热层），因此应将其提取。 </p>
<p>View 如果用户将“视图”特性设置为其他视图，则检索到的几何图形信息可能会有所不同。有关详细信息，请查看以下示例： 1. 在Revit中，在三维视图中绘制楼梯，然后在三维视图中选择“裁剪区域”、“裁剪区域可见”和“剖面框”属性。在“裁剪区域”中，修改三维视图中的剖面框以显示楼梯的一部分。如果使用API获取楼梯的几何图形信息，并将三维视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。下图显示了Revit应用程序中的楼梯（左图）和使用API绘制的楼梯（右图）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F6123E3E-4B46-4502-915A-5FC399B34045-low.png"></p>
<p>图113：不同的剖面框显示不同的几何图形 </p>
<p>在Revit中绘制楼梯，然后绘制剖面，如左图所示。如果使用API获取此楼梯的信息，并将此剖面视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。使用API绘制的楼梯如右图所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1095389D-A7C6-4AB8-A6C6-FC8CC3C05EAB-low.png"></p>
<p>图114：检索几何剖面图 </p>
<p>DetailLevel API在Geometry.Options.DetailLevels中定义了三个枚举。这三个枚举对应于Revit应用程序中的三个详细程度，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-81B8A84A-2F7B-4019-8CC8-4DA11B7A176A-low.png"></p>
<p>图115：三个细节层次</p>
<p>据DetailLevel特性中的不同设置检索不同的几何体信息。例如，在Revit应用程序中绘制梁，然后使用API从梁中获取几何图形进行绘制。以下图片显示了绘制结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B1C82974-A3D1-4893-9DF9-E9396C7D6352-low.png"></p>
<p>图116：梁的几何详图</p>
<p>BoundingBoxXYZ BoundingBoxXYZ定义了一个3D矩形框，它需要与任何坐标轴平行。与Instance类类似，BoundingBoxXYZ将数据存储在局部坐标空间中。它具有一个Transform属性，可将数据从框局部坐标空间转换到模型空间。换句话说，要获取模型空间中的长方体边界（与Revit中的长方体边界相同），请使用Transform属性变换每个数据成员。以下各节说明如何使用BoundingBoxXYZ。 #定义视图边界 BoundingBoxXYZ可用于通过View.CropBox属性定义视图边界。下图使用剖面视图显示了如何在Revit应用程序中使用BoundingBoxXYZ。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C517106E-BC7F-4E89-90C4-7FFF1D6B3FD2-low.png"></p>
<p>图117：截面视图中的BoundingBoxXYZ </p>
<p>前面图片中的虚线显示了作为CropBox特性（BoundingBoxXYZ实例）显示的横断面图边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-22E284B3-C514-4EB4-B322-91454006173E-low.png"></p>
<p>图118：创建的截面视图 </p>
<p>上一张图片显示了相应的横断面图。视图边界外的墙将不显示。 </p>
<p>定义截面框 BoundingBoxXYZ还用于为从View3D.GetSectionBox（）方法检索的三维视图定义剖面框。在“特性”对话框中选择“剖面框”特性。剖面框如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1EA1F70A-FFC5-4C58-9446-48E73E9C5606-low.png"></p>
<p>图119：三维视图剖面框#其他用途在元素的几何图形周围定义一个框。（Element.BoundingBox属性）。</p>
<p>以这种方式检索的BoundingBoxXYZ实例平行于坐标轴。在ViewSection. ViewDetail（）方法中使用。下表标识了此类的主要用途。表49：BoundingBoxXYZ属性</p>
<table>
<thead>
<tr>
<th>**Property Name **</th>
<th><strong>Usage 使用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Max&#x2F;Min</td>
<td>最大&#x2F;最小坐标。这两个属性定义了一个平行于任何坐标轴的三维长方体。Transform属性提供了一个可以将长方体变换到适当位置的变换矩阵。</td>
</tr>
<tr>
<td>Transform</td>
<td>从长方体坐标空间转换到模型空间。</td>
</tr>
<tr>
<td>Enabled</td>
<td>指示是否打开边界框。</td>
</tr>
<tr>
<td>MaxEnabled&#x2F; MinEnabled</td>
<td>如果裁剪视图处于打开状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回true。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-7050609C-8AAF-40C4-A9A8-F8920B6AD022-low.png" alt="img">如果裁剪视图处于关闭状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回false。* 定义给定维度的最大&#x2F;最小界限是否处于活动状态。如果Enable属性为false，这两个属性也应该返回false。  此属性指示视图的裁剪框面是否可用于裁剪元素的视图。 <em>如果从View3D.GetSectionBox（)方法检索BoundingBoxXYZ，则返回值取决于是否在“三维视图属性”对话框中选择了“剖面框”属性。如果是，则所有Enabled属性都返回true。</em> 如果从Element.BoundingBox属性检索BoundingBoxXYZ，则所有Enabled属性都为true。</td>
</tr>
<tr>
<td>Bounds</td>
<td>Max&#x2F;Min属性的界限。</td>
</tr>
<tr>
<td>BoundEnabled</td>
<td>MaxEnabled&#x2F;MinEnabled属性的界限。</td>
</tr>
</tbody></table>
<p>下面的代码示例阐释如何旋转BoundingBoxXYZ以修改三维视图剖面框。</p>
<p>代码区域20-9：旋转BoundingBoxXYZ</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RotateBoundingBox</span>(<span class="params">View3D view3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!view3d.IsSectionBoxActive)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The section box for View3D isn&#x27;t active.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BoundingBoxXYZ box = view3d.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a rotation transform to apply to the section box </span></span><br><span class="line">    XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ axis = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate 30 degrees</span></span><br><span class="line">    Transform rotate = Transform.CreateRotationAtPoint(axis, Math.PI/<span class="number">6.0</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the View3D&#x27;s section box with the rotation transform</span></span><br><span class="line">    box.Transform = box.Transform.Multiply(rotate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the section box back to the view (requires an open transaction)</span></span><br><span class="line">    view3d.SetSectionBox(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BoundingBoxUV"><a href="#BoundingBoxUV" class="headerlink" title="BoundingBoxUV"></a>BoundingBoxUV</h3><p>BoundingBoxUV是一个值类，它定义了一个平行于坐标轴的2D矩形。它支持最小和最大数据成员。它们一起定义BoundingBoxUV的边界。BoundingBoxUV从View.Outline属性中检索，该属性是图纸空间视图中的边界视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3CDBA6D9-E139-482E-816C-640D56DE5E63-low.png"></p>
<p>图120：视图轮廓</p>
<p>两个点定义BoundingBoxUV。</p>
<ul>
<li><p>Min point - 左下角端点。</p>
</li>
<li><p>Max point - 右上端点。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-71827A01-D568-4770-9457-A279F252DBFD-low.png"></p>
</li>
</ul>
<p>图121：BoundingBoxUV最大值和最小值</p>
<p>注意：BoundingBoxUV不能像下图那样呈现倾斜矩形</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1A52815E-11F5-4305-B68E-B0A63A06718D-low.png"></p>
<p>图122：倾斜矩形</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>Revit API中的专用几何图形集合类。</p>
<p>API根据集合类包含的项提供以下集合类：</p>
<p>表50：几何集合类</p>
<table>
<thead>
<tr>
<th>**Class&#x2F;Type **</th>
<th>对应的集合类**</th>
<th>对应的迭代器**</th>
</tr>
</thead>
<tbody><tr>
<td>Edge</td>
<td>EdgeArray, EdgeArrayArray</td>
<td>EdgeArrayIterator, EdgeArrayArrayIterator</td>
</tr>
<tr>
<td>Face</td>
<td>FaceArray</td>
<td>FaceArrayIterator</td>
</tr>
<tr>
<td>Reference</td>
<td>ReferenceArray</td>
<td>ReferenceArrayIterator</td>
</tr>
<tr>
<td>Double value</td>
<td>DoubleArray</td>
<td>DoubleArrayIterator</td>
</tr>
</tbody></table>
<p>所有这些类都使用非常相似的方法和属性来完成类似的工作。有关更多详细信息，请参阅集合。</p>
<h2 id="示例：从梁中检索几何图形数据"><a href="#示例：从梁中检索几何图形数据" class="headerlink" title="示例：从梁中检索几何图形数据"></a>示例：从梁中检索几何图形数据</h2><p>本节说明如何从梁获取实体和曲线。可以以类似的方式检索柱和支撑几何数据。GeometryElement可以包含所需的几何体作为Solid或GeometryInstance，具体取决于梁是连接的还是独立的，本代码涵盖了这两种情况。</p>
<p>注意：如果要获取梁和支撑驱动曲线，请调用LocationCurve可用的FamilyInstance Location属性。</p>
<p>示例代码如下所示：</p>
<p>代码区域20-10：从梁获取实体和曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetCurvesFromABeam</span>(<span class="params">Autodesk.Revit.DB.FamilyInstance beam,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Autodesk.Revit.DB.Options options</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = beam.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">    System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids = <span class="keyword">new</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find all solids and insert them into solid array</span></span><br><span class="line">    AddCurvesAndSolids(geomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCurvesAndSolids</span>(<span class="params">Autodesk.Revit.DB.GeometryElement geomElem,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> Autodesk.Revit.DB.CurveArray curves,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Autodesk.Revit.DB.Curve curve = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Curve;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Autodesk.Revit.DB.Solid solid = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Solid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != solid)</span><br><span class="line">        &#123;</span><br><span class="line">            solids.Add(solid);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If this GeometryObject is Instance, call AddCurvesAndSolids</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryInstance geomInst = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != geomInst)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.GeometryElement transformedGeomElem</span><br><span class="line">                = geomInst.GetInstanceGeometry(geomInst.Transform);</span><br><span class="line">            AddCurvesAndSolids(transformedGeomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例使用FamilyInstance.Geometry属性访问梁的真实几何图形。若要在通过连接、剪切、复制、拉伸或其他后期处理修改族实例之前获取其原始几何图形，请使用FamilyInstance.GetOriginalGeometry（）方法。</p>
<p>注意：有关如何检索Geometry.Options类型对象的详细信息，请参阅Geometry Helper Classes。</p>
<h2 id="实体的拉伸分析"><a href="#实体的拉伸分析" class="headerlink" title="实体的拉伸分析"></a>实体的拉伸分析</h2><p>实用程序类ExtrusionAnalyzer允许您尝试将给定的几何图形“拟合”到拉伸轮廓的形状中。这个类的实例是一次性使用类，应该提供一个立体几何、一个平面和一个方向。初始化ExtrusionAnalyzer后，可以通过以下成员访问结果：</p>
<ul>
<li>GetExtrusionBase（）方法返回与输入平面对齐的拉伸实体的计算基础轮廓。</li>
<li>CalculateFaceAlignment（）方法可用于标识原始几何体中与计算拉伸的面对齐或不对齐的所有面。例如，这对于确定墙的顶部是否有倾斜连接（如果与屋顶有连接，则会出现这种情况）非常有用。如果某个面未对齐，则会将某些内容连接到影响该面的几何体。</li>
<li>若要确定生成非对齐面的元素，请将面传递给Element.GetGeneratingElementIds（）。有关此实用程序的更多详细信息，请参阅以下部分。</li>
</ul>
<p>ExtrusionAnalyzer实用程序最适用于至少有点“类似于拉伸”的几何体，例如，可能会或可能不会受到端点连接、楼板连接、屋顶连接、由门窗切割的洞口或其他修改影响的墙几何体。对于特定的形状和方向组合，分析器可能很少无法确定作为挤出基础的连贯面-在这些情况下将引发InvalidOperationException。</p>
<p>在此示例中，拉伸分析器用于计算并绘制由输入实体和太阳方向形成的阴影的轮廓。</p>
<p>代码区域：使用拉伸分析器计算并绘制阴影轮廓。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Draw the shadow of the indicated solid with the sun direction specified.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The shadow will be outlined with model curves added to the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A transaction must be open in the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target solid.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target level where to measure and draw the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The direction from the sun (or light source).</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The curves created for the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Thrown by ExtrusionAnalyzer when the geometry and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> direction combined do not permit a successful analysis.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ICollection <span class="title">DrawShadow</span>(<span class="params">Document document, Solid solid, Level targetLevel, XYZ sunDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create target plane from level.    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, new XYZ(0, 0, targetLevel.ProjectElevation));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create extrusion analyzer.</span></span><br><span class="line">    ExtrusionAnalyzer analyzer = ExtrusionAnalyzer.Create(solid, plane, sunDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the resulting face at the base of the calculated extrusion.</span></span><br><span class="line">    Face result = analyzer.GetExtrusionBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert edges of the face to curves.</span></span><br><span class="line">    CurveArray curves = document.Application.Create.NewCurveArray();</span><br><span class="line">    <span class="keyword">foreach</span> (EdgeArray edgeLoop <span class="keyword">in</span> result.EdgeLoops)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(edge.AsCurve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the model curve factory object.</span></span><br><span class="line">    Autodesk.Revit.Creation.ItemFactoryBase itemFactory;</span><br><span class="line">    <span class="keyword">if</span> (document.IsFamilyDocument)</span><br><span class="line">        itemFactory = document.FamilyCreate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        itemFactory = document.Create;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a sketch plane for the curves.    CurveLoop loop = new CurveLoop();</span></span><br><span class="line">    <span class="keyword">foreach</span> (Curve currentCurve <span class="keyword">in</span> curves)</span><br><span class="line">    &#123;</span><br><span class="line">        loop.Append(currentCurve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(document, loop.GetPlane());</span><br><span class="line">    document.Regenerate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the shadow curves</span></span><br><span class="line">    ModelCurveArray curveElements = itemFactory.NewModelCurveArray(curves, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the ids of the curves created</span></span><br><span class="line">    List curveElementIds = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">foreach</span> (ModelCurve curveElement <span class="keyword">in</span> curveElements)</span><br><span class="line">    &#123;</span><br><span class="line">        curveElementIds.Add(curveElement.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveElementIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实用程序可用于计算给定质量相对于视图当前日光和阴影设置的阴影：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/shadowcalculator.png"></p>
<h2 id="通过光线投影查找几何图形"><a href="#通过光线投影查找几何图形" class="headerlink" title="通过光线投影查找几何图形"></a>通过光线投影查找几何图形</h2><p>ReferenceIntersector类可用于查找与给定射线相交的元素。</p>
<p><strong>ReferenceIntersector</strong> </p>
<p>此类允许应用程序使用Revit的拾取工具来查找图元和几何图形。这个类使用从指定方向的点发出的射线来查找射线击中的几何体。</p>
<p>该类仅与3D几何体相交，并且在创建时需要3D视图。可以使用已被剖面框剪切的三维视图，或设置了视图专有几何图元和图形选项的三维视图。输入视图上的可见性设置将确定是否返回特定图元（例如，此工具永远不会返回隐藏图元，几何图形位于视图剖面框之外的图元也不会返回）。</p>
<p>ReferenceIntersector类支持基于元素或引用类型过滤输出。输出可以根据使用的构造函数进行自定义，或者在调用方法执行光线投影之前使用类的方法和属性进行自定义。</p>
<p>有4个构造函数。</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ReferenceIntersector(View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回所有元素的交集，并表示所有引用目标类型。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，将其设置为返回通过过滤器的任何元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementId, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为仅返回来自单个目标元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ICollection, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回一组目标元素中任何一个的交集。</td>
</tr>
</tbody></table>
<p>FindReferenceTarget枚举包括以下选项：元素、网格、边、曲线、面或全部。 </p>
<p>查找元素 </p>
<p>有两种方法可以投影光线，这两种方法都将光线的原点及其方向作为输入。仅返回光线前面的元素的引用。Find（）方法返回与ReferenceIntersector的条件匹配的ReferenceWithContext对象的集合。该对象包含光线参照，它可以是与光线相交的元素和几何参照。返回的某些图元参照将具有一个相应的几何对象，该对象也是矩形的（例如，穿过墙中洞口的光线将与墙和洞口图元相交）。如果只对真正的物理交点感兴趣，则应用程序应丢弃其Reference类型为Element的所有引用。 FindNearest（）方法的行为与Find（）方法类似，但仅返回距离光线原点最近的对象引用。 返回的ReferenceWithContext包含一个接近度参数。这是光线原点与交点之间的距离。应用程序可以使用此距离来排除距离原点太远的项目，以进行特定的几何分析。应用程序还可以使用此距离来处理一些有趣的问题，包括分析模型的几何图形。</p>
<p>注意：这些方法不会返回与不在激活设计选项中的图元的交点。</p>
<p>链接文件中的元素</p>
<p> FindReferencesInRevitLinks属性提供了一个选项，用于返回在Revit链接中遇到的图元结果。如果设置为false，ReferenceIntersector将找不到对Revit链接中任何图元的参照，并且返回的所有参照将仅指向主体文档中的图元。如果设置为true，则结果可能包括对主体中元素的引用和对链接实例中元素的引用。 如果在ReferenceIntersector中设置了目标ElementId的列表，则仅当ElementId与ReferenceRevitLinkInstance的ID匹配时，才会返回引用。如果有匹配，链接中的任何相交元素都将被返回（它们的id将不会与目标id列表进行比较）。 如果应用了ElementFilter，则将根据存储的ElementFilter计算链接中的元素。请注意，如果应用的过滤器是几何过滤器（如BoundingBox过滤器或ElementIntersects过滤器），则结果可能与预期不同。这是因为将针对链接模型坐标中的链接图元计算过滤器，而链接模型坐标可能与图元在主体模型中显示的坐标不匹配。此外，在实例化期间接受Document和&#x2F;或ElementId作为输入的ElementFilters将无法正确传递链接中出现的元素，因为过滤器将无法将链接元素与过滤器的标准相匹配。 ###查找元素附近的元素 此工具的一个主要用途是查找与其他元素非常接近的元素。这允许应用程序将该工具用作其“眼睛”，并确定尚未具有内置关系的元素之间的关系。 例如，光线跟踪功能可用于查找嵌入墙中的柱。由于柱和墙不直接保持关系，因此此类允许我们通过跟踪墙范围外的光线并查找与柱的交点来查找潜在的候选对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_1.png"></p>
<p>示例：查找嵌入墙中的柱</p>
<p><strong>测量距离</strong> </p>
<p>这个类也可以用来测量从天窗到最近楼层的垂直距离。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DistanceToFloor.jpg"></p>
<p>示例：使用ReferenceIntersector.FindNearest（）进行测量</p>
<p>代码区域：使用光线投影测量距离</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RayProjection</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData revit, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = revit.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">        ICollection selectedIds = revit.Application.ActiveUIDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If skylight is selected, process it.</span></span><br><span class="line">        FamilyInstance skylight = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedIds.Count == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">            &#123;</span><br><span class="line">                Element e = doc.GetElement(id);</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilyInstance instance = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">                    <span class="built_in">bool</span> isWindow = (instance.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Windows);</span><br><span class="line">                    <span class="built_in">bool</span> isHostedByRoof = (instance.Host.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Roofs);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isWindow &amp;&amp; isHostedByRoof)</span><br><span class="line">                    &#123;</span><br><span class="line">                        skylight = instance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skylight == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="string">&quot;Please select one skylight.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the height</span></span><br><span class="line">        Line line = CalculateLineAboveFloor(doc, skylight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a model curve to show the distance</span></span><br><span class="line">        Plane plane = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), line.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">        SketchPlane sketchPlane = SketchPlane.Create(doc, plane);</span><br><span class="line"></span><br><span class="line">        ModelCurve curve = doc.Create.NewModelCurve(line, sketchPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a message with the length value</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Distance&quot;</span>, <span class="string">&quot;Distance to floor: &quot;</span> + String.Format(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>, line.Length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Determines the line segment that connects the skylight to the nearest floor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The line segment.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Line <span class="title">CalculateLineAboveFloor</span>(<span class="params">Document doc, FamilyInstance skylight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find a 3D view to use for the ReferenceIntersector constructor</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line">        View3D view3D = collector.OfClass(<span class="keyword">typeof</span>(View3D)).Cast().First(isNotTemplate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the center of the skylight bounding box as the start point.</span></span><br><span class="line">        BoundingBoxXYZ box = skylight.get_BoundingBox(view3D);</span><br><span class="line">        XYZ center = box.Min.Add(box.Max).Multiply(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project in the negative Z direction down to the floor.</span></span><br><span class="line">        XYZ rayDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Floor));</span><br><span class="line"></span><br><span class="line">        ReferenceIntersector refIntersector = <span class="keyword">new</span> ReferenceIntersector(filter, FindReferenceTarget.Face, view3D);</span><br><span class="line">        ReferenceWithContext referenceWithContext = refIntersector.FindNearest(center, rayDirection);</span><br><span class="line"></span><br><span class="line">        Reference reference = referenceWithContext.GetReference();</span><br><span class="line">        XYZ intersection = reference.GlobalPoint;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create line segment from the start point and intersection point.</span></span><br><span class="line">        Line result = Line.CreateBound(center, intersection);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>射线反弹&#x2F;分析</strong></p>
<p>ReferenceIntersector.Find（）返回的参照包括几何上的交点。知道了面上的交点、面的材质和光线方向，应用程序就可以分析建筑物内的反射和折射。下图演示了如何使用交点来反射由模型图元遮挡的光线;添加了模型曲线来表示每条光线的路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_3.png"></p>
<p>示例：从曲面反弹的射线</p>
<p><strong>查找交点&#x2F;碰撞</strong></p>
<p>ReferenceIntersector类的另一个用途是检测与给定梁或管道的中心线相交&#x2F;干涉的交点（如梁或管道）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_4.png"></p>
<p>示例：在干涉周围重新布线元素</p>
<h2 id="几何工具类"><a href="#几何工具类" class="headerlink" title="几何工具类"></a>几何工具类</h2><p>有许多工具类可用于处理几何体对象。</p>
<p><strong>HostObjectUtils</strong></p>
<p>HostObjectUtils类提供方法作为定位复合HostObjects的某些面的快捷方式。这些实用程序检索用作对象的CompoundStructure的边界的面：</p>
<ul>
<li>HostObjectUtils.GetSideFaces() – 适用于墙壁和FaceWalls;您可以获得外部或内部饰面。</li>
<li>HostObjectUtils.GetTopFaces() and HostObjectUtils.GetBottomFaces() – 适用于屋顶、楼板和天花板。</li>
</ul>
<p><strong>SolidUtils</strong></p>
<p>SolidUtils类包含对实体执行操作的方法。</p>
<ul>
<li>SolidUtils.Clone() - 创建一个新的Solid，它是输入Solid的副本</li>
<li>SolidUtils.SplitVolumes() - 使用一个包含不相交的封闭体积的实体，并返回新创建的代表每个体积的实体对象。如果不需要分割，则返回输入实体。</li>
<li>SolidUtils.TessellateSolidOrShell() - 对给定的输入实体（可以是一个或多个完全闭合的体积，也可以是一个开放的壳）进行三角测量。返回一个TriangulatedSolidOrShell对象，该对象允许访问存储的实体的三角化边界组件或壳的三角化连接组件。</li>
<li>SolidUtils.CreateTransformed() - 创建一个新的实体，它是输入实体的变换。</li>
</ul>
<p><strong>JoinGeometryUtils</strong></p>
<p>JoinGeometryUtils类包含用于连接和取消连接元素以及管理元素连接顺序的方法。这些实用程序不适用于族文档。</p>
<ul>
<li>JoinGeometryUtils.AreElementsJoined() - 确定是否连接两个元素</li>
<li>JoinGeometryUtils.GetJoinedElements() - 返回连接到给定元素的所有元素</li>
<li>JoinGeometryUtils.JoinGeometry() - 在共享公共面的两个元素之间创建连接。将删除连接图元之间的可见边。然后，连接的元素共享相同的线宽和填充图案。</li>
<li>JoinGeometryUtils.UnjoinGeometry() - 删除两个连接元素之间的连接</li>
<li>JoinGeometryUtils.SwitchJoinOrder() - 反转两个元素连接的顺序。切割元件变成被切割元件，反之亦然。</li>
<li>JoinGeometryUtils . IsCuttingElementInJoin() - 确定两个连接的元素中的第一个元素是否剪切第二个元素，反之亦然。</li>
</ul>
<p><strong>FacetingUtils</strong></p>
<p>此类用于将三角形结构转换为其中某些三角形已合并为四边形的结构。</p>
<ul>
<li>FacetingUtils.ConvertTrianglesToQuads() - 此方法以TriangulationInterface（从TriangulatedSolidOrShell构造）作为输入，并返回表示原始三角化对象的三角形和四边形的集合。</li>
</ul>
<h2 id="房间和空间几何"><a href="#房间和空间几何" class="headerlink" title="房间和空间几何"></a>房间和空间几何</h2><p>通过Revit API可以访问空间图元（房间和空间）的三维几何图形。</p>
<p>SpatialElementGeometryCalculator类可用于计算空间元素的几何形状并获取几何形状与元素边界元素之间的关系。可以为此实用程序提供2个选项：</p>
<ul>
<li>SpatialElementBoundaryLocation – 是否使用详细面或边界元素中心线进行计算</li>
<li>StoredFreeBoundaryFaces – 是否在结果中包括不直接映射到边界元素的面。</li>
</ul>
<p>计算几何体的结果包含在SpatialElementGeometryResults类中。从SpatialElementGeometryResults类中，可以获得：</p>
<ul>
<li>表示几何的实体体积（GetGeometry（）方法）</li>
<li>边界面信息（一个集合SpatialElementBoundarySubfaces）</li>
</ul>
<p>每个子面提供：</p>
<ul>
<li>空间元素的表面</li>
<li>边界元素的匹配面</li>
<li>子面（由该特定边界元素限定的空间元素面部分）</li>
<li>底面类型（底部、顶部或侧面）</li>
</ul>
<p>关于使用此实用程序的一些注意事项：</p>
<ul>
<li>计算器为已处理的几何体维护一个内部缓存。如果要计算同一项目中多个图元的几何图形，则应使用此类的单个实例。请注意，当对文档进行任何更改时，将清除该高速缓存。</li>
<li>楼板几乎从不作为边界元素包含在内。Revit使用房间的二维轮廓来形成底面，而不将其与楼板几何图形相匹配。</li>
<li>由墙剪切特征（例如门和窗）创建的洞口不包括在返回的面中。</li>
<li>几何图形计算与Revit提供的功能相匹配。在某些情况下，如果Revit假设如何计算房间和空间边界的体积，则这些假设将显示在实用程序的输出中。</li>
</ul>
<p>以下示例计算房间的几何图形并查找其边界面</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面部区域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(doc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the room geometry</span></span><br><span class="line">SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the solid representing the room&#x27;s geometry</span></span><br><span class="line">Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">foreach (Face face in roomSolid.Faces)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> faceArea = face.Area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the sub-faces for the face of the room</span></span><br><span class="line">    IList subfaceList = results.GetBoundaryFaceInfo(face);</span><br><span class="line">    foreach (SpatialElementBoundarySubface subface in subfaceList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (subfaceList.Count &gt; <span class="number">1</span>) <span class="comment">// there are multiple sub-faces that define the face</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the area of each sub-face</span></span><br><span class="line">            <span class="type">double</span> subfaceArea = subface.GetSubface().Area;</span><br><span class="line">            <span class="comment">// sub-faces exist in situations such as when a room-bounding wall has been</span></span><br><span class="line">            <span class="comment">// horizontally split and the faces of each split wall combine to create the </span></span><br><span class="line">            <span class="comment">// entire face of the room</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例计算房间的几何图形，并查找属于定义房间的图元的面的材质。</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MaterialFromFace</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Document doc = <span class="keyword">this</span>.Document;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(doc);</span><br><span class="line">        Room room = doc.GetElement(uidoc.Selection.PickObject(ObjectType.Element).ElementId) <span class="keyword">as</span> Room;</span><br><span class="line"></span><br><span class="line">        SpatialElementBoundaryOptions  spatialElementBoundaryOptions = <span class="keyword">new</span> SpatialElementBoundaryOptions();</span><br><span class="line">        spatialElementBoundaryOptions.SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Finish;</span><br><span class="line">        SpatialElementGeometryCalculator calculator = <span class="keyword">new</span> SpatialElementGeometryCalculator(doc, spatialElementBoundaryOptions);</span><br><span class="line">        SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line">        Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Face roomSolidFace <span class="keyword">in</span> roomSolid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (SpatialElementBoundarySubface subface <span class="keyword">in</span> results.GetBoundaryFaceInfo(roomSolidFace))</span><br><span class="line">            &#123;</span><br><span class="line">                Face boundingElementface = subface.GetBoundingElementFace();</span><br><span class="line">                ElementId id = boundingElementface.MaterialElementId;</span><br><span class="line">                s +=  doc.GetElement(id).Name + <span class="string">&quot;, id = &quot;</span> + id.IntegerValue.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;revit&quot;</span>,s);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/18%E5%87%A0%E4%BD%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/17%E6%B3%A8%E9%87%8A%E5%85%83%E7%B4%A0/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="注释元素"><a href="#注释元素" class="headerlink" title="注释元素"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Annotation_Elements_html">注释元素</a></h1><p>本节介绍Revit注释元素，例如尺寸标注、文字注释、注释记号、标记和符号。</p>
<p>请注意：</p>
<ul>
<li>尺寸标注是视图专有的图元，用于显示项目中的尺寸和距离。</li>
<li>为详图创建详图曲线。它们仅在绘制它们的视图中可见。它们通常绘制在模型视图上。</li>
<li>标签是用于标识图形中图元的注释。与标签关联的特性可以显示在明细表中。</li>
<li>AnnotationSymbol在加载到项目中时具有多个引线选项。</li>
</ul>
<p>有关Revit Element分类的详细信息，请参见元素要点。</p>
<h2 id="尺寸标注和约束"><a href="#尺寸标注和约束" class="headerlink" title="尺寸标注和约束"></a>尺寸标注和约束</h2><p>永久性尺寸标注和尺寸标注相关约束。</p>
<p>Dimension类表示永久性尺寸标注和与尺寸标注相关的约束元素。在UI中编辑元素时创建的临时尺寸标注不可访问。高程点和高程点坐标由SpotDimension类表示。</p>
<p>下面的代码示例在结尾处说明了如何区分永久性尺寸标注和约束元素。</p>
<p>代码区域16-1：区分永久性尺寸标注和约束</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Dimension</span>(<span class="params">Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Dimension : &quot;</span>;</span><br><span class="line">    <span class="comment">// Get Dimension name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension name is : &quot;</span> + dimension.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension Curve</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = dimension.Curve;</span><br><span class="line">    <span class="keyword">if</span> (curve != <span class="literal">null</span> &amp;&amp; curve.IsBound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get curve start point</span></span><br><span class="line">        message += <span class="string">&quot;\nCurve start point:(&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve end point</span></span><br><span class="line">        message += <span class="string">&quot;; Curve end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension type name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension type name is : &quot;</span> + dimension.DimensionType.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension view name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension view name is : &quot;</span> + dimension.View.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension reference count</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension references count is &quot;</span> + dimension.References.Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Dimensions == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a permanent dimension.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Constraints == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a constraint element.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尺寸标注"><a href="#尺寸标注" class="headerlink" title="尺寸标注"></a>尺寸标注</h3><p>有五种永久尺寸标注：</p>
<ul>
<li>Linear dimension 线性尺寸标注</li>
<li>Radial dimension 半径尺寸标注</li>
<li>Diameter Dimension 直径尺寸标注</li>
<li>Angular dimension 角度尺寸标注</li>
<li>Arc length dimension 弧长尺寸标注</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/Dims.png"></p>
<p>图66：永久尺寸标注</p>
<p>所有永久性尺寸标注的BuiltInCategory为OST_Dimensions。没有一种使用API区分四个维度的简单方法。</p>
<p>除半径尺寸标注和直径尺寸标注外，每个尺寸标注都有一条尺寸线。尺寸线可从始终未绑定的Dimension.Curve属性中获得。换句话说，尺寸线没有起点或终点。基于上一张图片：</p>
<ul>
<li>将为线性标注返回Line对象。</li>
<li>将为半径标注或角度标注返回弧对象。</li>
<li>径向尺寸标注返回空。</li>
<li>直径尺寸标注返回空。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C8DCD73-DFD8-4185-A1EA-2C890D176FBF-low.png"></p>
<p>图67：尺寸参考</p>
<p>如上图所示，通过选择几何参照来创建尺寸。几何参照在API中表示为Reference类。以下尺寸参照可从“参照”（References）属性中获得。有关参考的更多信息，请参见几何部分中的几何辅助程序类。</p>
<ul>
<li>半径和直径尺寸标注-返回曲线的一个参考对象</li>
<li>角度和弧长尺寸标注-返回两个参照对象。</li>
<li>线性尺寸标注-返回两个或多个参照对象。在下图中，线性标注有五个Reference对象。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A976B817-2D4B-471B-BF79-27E9262A8A85-low.png"></p>
<p>图68：线性尺寸参考</p>
<p>与其他注释元素一样，尺寸标注也是视图专有的。它们仅显示在添加它们的视图中。Dimension.View属性返回特定的视图。</p>
<h3 id="约束元素"><a href="#约束元素" class="headerlink" title="约束元素"></a>约束元素</h3><p>具有类别约束的标注对象（BuitInCategory.OST_Constraints）表示两种与标注相关的约束：</p>
<ul>
<li>Linear and radial dimension constraints<br>线性和半径尺寸标注约束</li>
<li>Equality constraints 等式约束</li>
</ul>
<p>在下图中，两种锁定约束分别对应于线性标注和半径标注。在应用程序中，它们显示为带有绿色虚线的挂锁。(绿色虚线可从“尺Dimension.Curve”属性中获得。）线性标注约束和半径标注约束都从Dimension.References属性返回两个Reference对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-370D4754-3BC7-4A6C-8531-41B7A5B424D9-low.png"></p>
<p>图69：线性和半径尺寸约束</p>
<p>约束图元不是视图专有的，可以显示在不同的视图中。因此，View属性总是返回null。在下图中，上一图中的约束元素在3D视图中也可见。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8365F25E-7304-413D-BABE-1C495BD8ADAD-low.png"></p>
<p>图70：3D视图中的线性和半径尺寸约束</p>
<p>虽然等分约束基于尺寸标注，但它们也由Dimension类表示。在API中，没有使用类别或类型区分线性标注约束和等式约束的直接方法。相等约束返回三个或更多引用，而线性尺寸约束返回两个或更多引用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FB6F70CD-8913-4C3A-A036-2108550BA25C-low.png"></p>
<p>图71：等分约束</p>
<p>注意：并非所有约束元素都由Dimension类表示，但都属于约束（OST_Constraints）类别，如对齐约束。</p>
<h3 id="高程点标注"><a href="#高程点标注" class="headerlink" title="高程点标注"></a>高程点标注</h3><p>高程点坐标和高程点由SpotDimension类表示，并按类别区分。与永久性尺寸标注一样，高程点尺寸标注也是视图专有的。下表列出了每个高程点标注的类型和类别：</p>
<p>表35：点尺寸类型和类别</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Category 类别</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Spot Coordinates 高程点坐标</td>
<td>OST_SpotCoordinates</td>
</tr>
<tr>
<td>Spot Elevations 高程点</td>
<td>OST_SpotElevations</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BDB09C60-D4AC-4F6A-8100-6BA2FA165228-low.png"></p>
<p>图72：SpotCoordinates和SpotElevations</p>
<p>可以将SpotDimension Location向下转换为LocationPoint，以便可以从LocationPoint.Point属性中获得点尺寸所指向的点坐标。SpotDimensions没有尺寸曲线，因此其Curve属性始终返回null。SpotDimension References属性返回一个Reference，表示高程点标注引用的点或边。* 若要控制文本和标记显示样式，请修改SpotDimension和SpotExpressionType参数。</p>
<p>对比下表对比了API中不同类型的维度和约束：</p>
<p>表36：Dimension类别对比</p>
<table>
<thead>
<tr>
<th>Dimension or Constraint</th>
<th>Dimension or Constraint</th>
<th>API Class</th>
<th>BuiltInCategory</th>
<th>Curve</th>
<th>Geometry Helper Classes</th>
<th>View</th>
<th>Location</th>
</tr>
</thead>
<tbody><tr>
<td>Permanent Dimension</td>
<td>linear dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>A Line</td>
<td>&#x3D;2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>radial dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>diameter dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>arc length dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>linear dimension constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Equality Constraint</td>
<td>Equality Constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>A Line</td>
<td>&#x3D;3</td>
<td></td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>NewDimension（）方法在Creation.Document类中可用。此方法只能创建线性标注。</p>
<p>代码区域16-2：NewDimension（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references, </span></span></span><br><span class="line"><span class="params"><span class="function">DimensionType dimensionType</span>)</span></span><br></pre></td></tr></table></figure>

<p>使用NewDimension（）方法输入参数，可以定义可见的View、尺寸线和References（两个或多个）。但是，没有简单的方法将线性标注类型与其他类型区分开来。很少使用带有ExcisionType参数的重载NewDimension（）方法。 下面的代码演示如何使用NewDimension（）方法复制标注。</p>
<p>代码区域16-3：使用NewDimension（）复制标注</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DuplicateDimension</span>(<span class="params">Document document, Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Line line = dimension.Curve <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != line)</span><br><span class="line">        &#123;</span><br><span class="line">                Autodesk.Revit.DB.View view = dimension.View;</span><br><span class="line">                ReferenceArray references = dimension.References;</span><br><span class="line">                Dimension newDimension = document.Create.NewDimension(view, line, references);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管只创建了线性标注，但您可以使用Document.Delete（）方法删除由Dimension和SpotDimension表示的所有标注和约束。 </p>
<p>标注文本操作 Dimension和ExpressionSegment类提供了类似的属性和方法，用于查询和调整文本相对于尺寸曲线的位置。 Dimension.Origin返回尺寸曲线中点的XYZ值，而ExpressionSegment.Origin将返回组成线段的直线的中点。 通过调用IsTextPositionAdjustable（）方法确定标注或标注段的文本位置是否可调，该方法将指示是否可以设置文本和引线位置。 使用属性TextPosition和LeaderEndPosition查询或修改文本或引线（标注或标注段）的位置。 通过调用ResetTextPosition（）方法将文本重置为其在尺寸上的默认位置。</p>
<p>注意：TextPosition和LeaderEndPosition不一定适用于所有标注（例如，标注样式为纵坐标时，使用相等约束的高程点标注、多段标注）。如果这些值不适用，它们将返回NULL，并且不允许设置值。</p>
<p>代码区域：重新定位标注文字</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Moves all of the text in this dimension one unit in the Y direction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">DimensionTextReposition</span>(<span class="params">Dimension dimToModify</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> modified = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dimToModify == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if we have a non-multisegment dimension and if text position is adjustable</span></span><br><span class="line">    <span class="keyword">if</span> (dimToModify.NumberOfSegments == <span class="number">0</span> &amp;&amp; dimToModify.IsTextPositionAdjustable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">        XYZ currentTextPosition = dimToModify.TextPosition;</span><br><span class="line">        <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">        XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">        <span class="comment">// Set the new text position</span></span><br><span class="line">        dimToModify.TextPosition = newTextPosition;</span><br><span class="line"></span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dimToModify.NumberOfSegments &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (DimensionSegment currentSegment <span class="keyword">in</span> dimToModify.Segments)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentSegment != <span class="literal">null</span> &amp;&amp; currentSegment.IsTextPositionAdjustable())</span><br><span class="line">            &#123;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">                XYZ currentTextPosition = currentSegment.TextPosition;</span><br><span class="line">                <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">                XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">                <span class="comment">// Set the new text position for the segment&#x27;s text</span></span><br><span class="line">                currentSegment.TextPosition = newTextPosition;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="详图线"><a href="#详图线" class="headerlink" title="详图线"></a>详图线</h2><p>详图线是一种重要的详图构件，通常用于详图或绘图视图中。可以在DetailCurve类及其派生类中访问详图曲线。</p>
<p>DetailCurve与其他注释元素一样，是视图专有的。但是，没有DetailCurve.View属性。创建详图曲线时，必须将详图曲线与模型曲线视图进行比较。</p>
<p>代码区域16-4：NewDetailCurve（）和NewModelCurve（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DetailCurve <span class="title">NewDetailCurve</span> (<span class="params">View, Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">NewModelCurve</span> (<span class="params">Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<p>通常，只有二维视图（如平面视图和立面视图）是可接受的，否则将引发异常。</p>
<p>除了与视图相关的功能外，DetailCurve与ModelCurve非常相似。有关ModelCurve属性和用法的详细信息，请参见“草图”部分中的ModelCurve。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是用于标识图形元素的注释。API公开IndependentTag和RoomTag类，以涵盖Revit应用程序中使用的大多数标签。有关RoomTag的更多详细信息，请参阅房间。</p>
<p>注意：IndependentTag类表示Revit中的标签图元和其他特定标记，如注释标签、梁系统标签、电子电路符号等。在Revit内部代码中，特定标记具有从IndependentTag派生的相应类。因此，特定功能不会由API公开，并且无法使用IndependentTag.xml创建。它们可按以下类别加以区分：</p>
<p>表37：标签名称和类别</p>
<table>
<thead>
<tr>
<th><strong>Tag Name 标记名称</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Keynote Tag</td>
<td>OST_KeynoteTags</td>
</tr>
<tr>
<td>Beam System Tag</td>
<td>OST_BeamSystemTags</td>
</tr>
<tr>
<td>Electronic Circuit Tag</td>
<td>OST_ElectricalCircuitTags</td>
</tr>
<tr>
<td>Span Direction Tag</td>
<td>OST_SpanDirectionSymbol</td>
</tr>
<tr>
<td>Path Reinforcement Span Tag</td>
<td>OST_PathReinSpanSymbol</td>
</tr>
<tr>
<td>Rebar System Span Tag</td>
<td>OST_IOSRebarSystemSpanSymbolCtrl</td>
</tr>
</tbody></table>
<p>族库中的每个类别都有一个预先制作的标记。某些标记会随默认的Revit应用程序样板自动加载，而其他标记则会手动加载。如果主体元素是使用“按类别”选项创建的，则IndependentTag对象将根据主体元素返回不同的类别。例如，Wall和Floor IndependentTag分别是OST_WallTags和OST_FloorTags。</p>
<p>如果标记是使用“Multi-Category ”或“Material”样式创建的，则它们的类别分别为OST_MultiCategoryTags和OST_MaterialTags。</p>
<p>请注意IndependentTag.Create只在2D视图或锁定的3D视图中工作，否则将引发异常。下面的代码是创建IndependentTag的示例。当标高视图为活动视图时运行该命令。</p>
<p>注意：您无法直接更改IndependentTag中显示的文本。您需要修改用于在要标记的图元的族类型中填充标记文字的参数。在下面的示例中，该参数为“Type Mark”，但可以在Revit UI的族编辑器中更改此设置。</p>
<p>代码区域16-5：创建IndependentTag</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IndependentTag <span class="title">CreateIndependentTag</span>(<span class="params">Autodesk.Revit.DB.Document document, Reference reference</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// make sure active view is not a 3D view</span></span><br><span class="line">    Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> View3D)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define tag mode and tag orientation for new tag</span></span><br><span class="line">    TagMode tagMode = TagMode.TM_ADDBY_CATEGORY;</span><br><span class="line">    TagOrientation tagorn = TagOrientation.Horizontal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the tag to the middle of the wall</span></span><br><span class="line">    Wall wall = document.GetElement(reference) <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (wall == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    LocationCurve wallLoc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ wallStart = wallLoc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    XYZ wallEnd = wallLoc.Curve.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">    XYZ wallMid = wallLoc.Curve.Evaluate(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    IndependentTag newTag = IndependentTag.Create(document, view.Id, reference, <span class="literal">true</span>, tagMode, tagorn, wallMid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == newTag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create IndependentTag Failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newTag.TagText is read-only, so we change the Type Mark type parameter to </span></span><br><span class="line">    <span class="comment">// set the tag text.  The label parameter for the tag family determines</span></span><br><span class="line">    <span class="comment">// what type parameter is used for the tag text.</span></span><br><span class="line"></span><br><span class="line">    WallType type = wall.WallType;</span><br><span class="line"></span><br><span class="line">    Parameter foundParameter = type.LookupParameter(<span class="string">&quot;Type Mark&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> result = foundParameter.Set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set leader mode free</span></span><br><span class="line">    <span class="comment">// otherwise leader end point move with elbow point</span></span><br><span class="line"></span><br><span class="line">    newTag.LeaderEndCondition = LeaderEndCondition.Free;</span><br><span class="line">    XYZ elbowPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.LeaderElbow = elbowPnt;</span><br><span class="line">    XYZ headerPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.TagHeadPosition = headerPnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FE76534-FEA8-4573-A2D7-747AB527B335-low.png"></p>
<p>图74：使用示例代码创建IndependentTag</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>可以从TextNote类访问文本和关联的引线。注意TextNote可以包含纯文本或格式化文本。重载的TextNote.Create（）方法提供了用于创建展开和换行文本注释元素的选项。文本内容区域的宽度可以在创建时指定，但受基于文本及其类型的属性的最小和最大宽度的限制。从TextElement继承的重载方法GetMinimumAllowedWidth（）和GetMaximumAllowedWidth（）返回特定TextNote或给定文档和文本类型ID的约束。</p>
<p>下面的示例在用户指定的点处使用给定的宽度和TextNoteOptions创建一个新的TextNote。</p>
<p>代码区域：创建文本注释</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TextNote <span class="title">AddNewTextNote</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDoc.Document;</span><br><span class="line">    XYZ textLoc = uiDoc.Selection.PickPoint(<span class="string">&quot;Pick a point for sample text.&quot;</span>);</span><br><span class="line">    ElementId defaultTextTypeId = doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);</span><br><span class="line">    <span class="built_in">double</span> noteWidth = <span class="number">.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure note width works for the text type</span></span><br><span class="line">    <span class="built_in">double</span> minWidth = TextNote.GetMinimumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="built_in">double</span> maxWidth = TextNote.GetMaximumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="keyword">if</span> (noteWidth &lt; minWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = minWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (noteWidth &gt; maxWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TextNoteOptions opts = <span class="keyword">new</span> TextNoteOptions(defaultTextTypeId);</span><br><span class="line">    opts.HorizontalAlignment = HorizontalTextAlignment.Left;</span><br><span class="line">    opts.Rotation = Math.PI / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    TextNote textNote = TextNote.Create(doc, doc.ActiveView.Id, textLoc, noteWidth, <span class="string">&quot;New sample text&quot;</span>, opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textNote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论TextNote具有纯文本还是格式化文本，始终可以从TextNote.Text属性检索未格式化的文本。</p>
<p>格式化文本 当第一次创建时，TextNote将具有纯文本。使用TextNote. GetNotedText（）方法获取TextNote的NotedText对象。类可以用于对文本应用各种格式，如粗体、下划线、上标或全部大写。在使用修改后的TextText调用SetSetNotedText（）之前，TextNote不会更新。 可以使用TextRange全部或部分地格式化已删除文本中的文本。TextRange基于TextedText对象中的文本指定起始索引和长度。当格式化方法（如SetItalicStatus（）或SetAllCapsStatus（））的重载使用TextRange时，将只修改该范围内的字符。TextRange可以使用其构造函数显式定义，也可以使用FormattedText.Find（）方法检索以获取给定搜索字符串的范围。Find（）方法指定搜索的开始索引，以及是否匹配搜索字符串的大小写或是否进行全词搜索。如果在搜索字符串中找不到文本，或者如果给定的起始索引超出了整个文本的长度，则将返回一个空的TextRange。在使用返回的范围设置文本格式之前，请确保该范围不为空，以避免异常。 下面的示例演示如何设置TextNote中的文本格式并将其设置回TextNote。它使用Find（）方法对文本中的特定单词加粗体和下划线。</p>
<p>代码区域：设置TextNote中的文本格式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TextNote created with &quot;New sample text&quot;</span></span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// italicize &quot;New&quot;</span></span><br><span class="line">    TextRange range = <span class="keyword">new</span> TextRange(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    formatText.SetItalicStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;sample&quot; bold</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;sample&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetBoldStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;text&quot; underlined</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;text&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetUnderlineStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all text uppercase</span></span><br><span class="line">    formatText.SetAllCapsStatus(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将新文本添加到已添加文本对象中的现有文本中。如果使用了具有TextRange参数的重载，SetPlainText（）方法将替换某些现有文本，否则将替换整个文本。若要插入文本而不替换现有文本，请使用Length为0的TextRange。新文本将插入到TextRange.Start属性指定的索引处。请注意，插入文本时，它可能会选择相邻文本的格式，类似于将未格式化的文本粘贴到Word文档中将导致文本具有插入点的当前格式。如果格式设置已经应用于整个multitedText，如上面示例中的SetAllCapsStatus（true）调用，则该格式设置将应用于插入的任何新文本。 在下面的示例中，通过首先查找当前文本的结尾并将其设置为要添加的范围的开始，新文本将被追加到现有文本的结尾。它还演示了如何创建一个列表（可以是项目符号，编号或字母）。请注意，它还为新文本的范围调用GetAllCapsStatus（），并在状态不是“大写状态.无”（其他选项是“全部”和“混合”）时关闭大写。</p>
<p>代码区域：插入新文本</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    TextRange range = formatText.AsTextRange();</span><br><span class="line"></span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set Length to 0 to insert</span></span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someNewText = <span class="string">&quot;\rThis is a new paragraph\vThis is a new line without a paragraph break\r&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someNewText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get range for entire text</span></span><br><span class="line">    range = formatText.AsTextRange();</span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someListText = <span class="string">&quot;\rBulleted List item 1\rItem 2\vSecond line for Item 2\rThird bullet point&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someListText);</span><br><span class="line">    range.Start++;</span><br><span class="line">    range.Length = someListText.Length;</span><br><span class="line">    formatText.SetListType(range, ListType.Bullet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (formatText.GetAllCapsStatus(range) != FormatStatus.None)</span><br><span class="line">    &#123;</span><br><span class="line">        formatText.SetAllCapsStatus(range, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示了如何使用\r创建换行符，使用\v创建不打断段落的垂直制表符。在项目符号列表的文本中，“\v”用于创建两行项目符号。仅在使用“\r”时才插入新项目符号。 </p>
<p>文本编辑器 TextEditorOptions类可用于控制Revit中文本编辑器的外观和功能。这些设置保存在Revit.ini文件中，不与文档绑定。</p>
<p>代码区域：设置文本编辑器选项</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEditorOptions</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TextEditorOptions editorOptions = TextEditorOptions.GetTextEditorOptions();</span><br><span class="line">    editorOptions.ShowBorder = <span class="literal">false</span>;</span><br><span class="line">    editorOptions.ShowOpaqueBackground = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引线"><a href="#引线" class="headerlink" title="引线"></a>引线</h3><p>Revit支持两种引线：直线引线和圆弧引线。可以使用AddLeader（）方法将引线添加到TextNote，并使用TextNoteLeaderType枚举类型指定引线类型：</p>
<p>表39：引线类型</p>
<table>
<thead>
<tr>
<th><strong>Function 功能</strong></th>
<th><strong>Member Name 成员名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0A443B27-ACDB-401E-8486-62165414529F-low.png" alt="img"> -添加右弧引线</td>
<td>TNLT_ARC_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EE3246C4-B4F8-443D-9958-66CE5E62BB12-low.png" alt="img"> -添加左弧引线</td>
<td>TNLT_ARC_L</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0D7DA193-EC77-4E99-A864-CA1E69BB3A62-low.png" alt="img"> -添加右引线。</td>
<td>TNLT_STRAIGHT_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60BA1957-992C-468D-8459-7A26E418BF57-low.png" alt="img"> -添加左引线。</td>
<td>TNLT_STRAIGHT_L</td>
</tr>
</tbody></table>
<p>注意：直线引线和圆弧引线不能同时添加到文本类型。</p>
<p>TextNote.LeaderCount属性返回引线数，GetLeaders（）方法返回当前附加到文本组件的所有引线。LeaderLeftAttachment和LeaderRightAttachment指示引线在TextNote的相应侧上的附着位置。LeaderAttachment的选项有TopLine、MidPoint和BottomLine。使用RemoveLeaders（）方法从TextNote中删除所有引线。</p>
<h2 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h2><p>注释符号是应用于族的符号，用于在项目中唯一标识该族。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-75864163-28D5-496D-9077-98DFECA07E75-low.png"></p>
<p>图76：带有两条引线的注释符号</p>
<h3 id="创建和删除-1"><a href="#创建和删除-1" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>可以使用Creation.Document.NewFamilyInstance（）方法的以下重载创建注释符号：</p>
<p>代码区域16-6：创建新注释符号</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FamilyInstance NewFamilyInstance <span class="title">Method</span> (<span class="params">XYZ origin, FamilySymbol symbol, View specView</span>)</span></span><br></pre></td></tr></table></figure>

<p>可以使用Document.Delete（）方法删除注释符号。 </p>
<p>添加和删除Leader 使用addLeader（）和removeLeader（）方法添加和删除引线。</p>
<p>代码区域16-7：使用addLeader（）和removeLeader（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAndRemoveLeaders</span>(<span class="params">AnnotationSymbol symbol</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if there are any leaders currently attached, and remove them</span></span><br><span class="line">    IList leaders = symbol.GetLeaders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaders != <span class="literal">null</span> &amp;&amp; leaders.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = leaders.Count; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            symbol.removeLeader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add one new leader instead</span></span><br><span class="line">    symbol.addLeader();&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/17%E6%B3%A8%E9%87%8A%E5%85%83%E7%B4%A0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/16%E5%9F%BA%E5%87%86%E5%92%8C%E4%BF%A1%E6%81%AF%E5%85%83%E7%B4%A0/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="基准和信息元素"><a href="#基准和信息元素" class="headerlink" title="基准和信息元素"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Datum_and_Information_Elements_html">基准和信息元素</a></h1><p>本章介绍Revit中的基准元素和信息元素。</p>
<ul>
<li>基准元素包括标高、轴网和模型线。</li>
<li>信息元素包括阶段、设计选项和EnergyDataSettings。</li>
</ul>
<p>有关Revit图元分类的详细信息，请参见图元要素。</p>
<p>注：如果您需要更多信息，请参阅相关章节：</p>
<ul>
<li>有关荷载基础、荷载工况、荷载组合、荷载性质和荷载用途，请参阅结构工程</li>
<li>对于模型曲线，请参阅草图</li>
<li>对于材质和填充图案，请参阅材质</li>
<li>有关能量数据设置，请参阅能量数据</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>Levels 标高</li>
<li>Grids 轴网</li>
<li>Phase 阶段</li>
<li>Design Options 设计选项</li>
</ul>
<h2 id="标高"><a href="#标高" class="headerlink" title="标高"></a>标高</h2><p>标高是一个有限的水平面，用作以标高为主体的图元（如墙、屋顶、楼板和天花板）的参照。</p>
<p>在Revit Platform API中，Level类派生自DatumPlane类，而DatumPlane类派生自Element类。继承的Name属性用于检索Revit UI中标高编号旁边的用户可见标高名称。若要检索项目中的所有标高，请将ElementClassFilter与Level类一起使用。</p>
<h3 id="高程"><a href="#高程" class="headerlink" title="高程"></a>高程</h3><p>Level类具有以下属性：</p>
<ul>
<li>“高程”特性用于检索或更改高于或低于地平面的高程。</li>
<li>ProjectElevation属性用于检索相对于项目原点的高程，而不考虑高程基准参数值。</li>
<li>“高程基准”值是一个标高类型参数。<ul>
<li>它的内置参数是LEVEL_RELATIVE_BASE_TYPE。</li>
<li>它的类型是整型</li>
<li>0对应于项目，1对应于共享。</li>
</ul>
</li>
</ul>
<p>下面的代码示例阐释如何使用Level类筛选器检索项目中的所有标高。</p>
<p>代码区域15-1：检索所有标高</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Level</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        StringBuilder levelInformation = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="built_in">int</span> levelNumber = <span class="number">0</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(Level)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Level level = e <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != level)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// keep track of number of levels</span></span><br><span class="line">                        levelNumber++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the name of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\nLevel Name: &quot;</span> + level.Name);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tElevation: &quot;</span> + level.Elevation);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// get the project elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tProject Elevation: &quot;</span> + level.ProjectElevation);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//number of total levels in current document</span></span><br><span class="line">        levelInformation.Append(<span class="string">&quot;\n\n There are &quot;</span> + levelNumber + <span class="string">&quot; levels in the document!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//show the level information in the messagebox</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,levelInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创造标高"><a href="#创造标高" class="headerlink" title="创造标高"></a>创造标高</h3><p>使用“标高”命令，可以定义建筑内的垂直高度或楼层，还可以为每个现有楼层或其他建筑参照创建标高。必须在剖面视图或立面视图中添加标高。此外，还可以使用Revit平台API创建新标高。</p>
<p>下面的代码示例阐释如何创建新标高。</p>
<p>代码区域15-2：创建新标高</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Level <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The elevation to apply to the new level</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">20.0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin to create a level</span></span><br><span class="line">    Level level = Level.Create(document, elevation);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new level failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the level name</span></span><br><span class="line">    level.Name = <span class="string">&quot;New level&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：创建新标高后，Revit不会为此标高创建关联的平面视图。如果有必要，您可以自己创建。有关如何创建平面视图的详细信息，请参见平面视图。</p>
<h2 id="轴网"><a href="#轴网" class="headerlink" title="轴网"></a>轴网</h2><p>Grid类表示Autodesk Revit中的一条轴网线。</p>
<p>网格由Grid类表示，Grid类派生自DatumPlane类，DatumPlane类派生自Element类。它包含所有网格属性和方法。继承的Name属性用于检索网格线的内容。</p>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>Grid类Curve属性获取表示网格线几何图形的对象。</p>
<ul>
<li>如果IsCurved属性返回true，则Curve属性将是Arc类对象。</li>
<li>如果IsCurved属性返回false，则Curve属性将是Line类对象。</li>
</ul>
<p>有关详细信息，请参考几何图形。</p>
<p>下面的代码是一个使用Grid类的简单示例。调用命令后，结果将显示在消息框中。</p>
<p>代码区域15-3：使用Grid类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Grid</span>(<span class="params">Grid grid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Grid : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show IsCurved property</span></span><br><span class="line">    message += <span class="string">&quot;\nIf grid is Arc : &quot;</span> + grid.IsCurved;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show Curve information</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = grid.Curve;</span><br><span class="line">    <span class="keyword">if</span> (grid.IsCurved)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is an arc, give center and radius information</span></span><br><span class="line">        Autodesk.Revit.DB.Arc arc = curve <span class="keyword">as</span> Autodesk.Revit.DB.Arc;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s radius: &quot;</span> + arc.Radius;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s center:  (&quot;</span> + XYZToString(arc.Center);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is a line, give length information</span></span><br><span class="line">        Autodesk.Revit.DB.Line line = curve <span class="keyword">as</span> Autodesk.Revit.DB.Line;</span><br><span class="line">        message += <span class="string">&quot;\nLine&#x27;s Length: &quot;</span> + line.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get curve start point</span></span><br><span class="line">    message += <span class="string">&quot;\nStart point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// Get curve end point</span></span><br><span class="line">    message += <span class="string">&quot;; End point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建轴网"><a href="#创建轴网" class="headerlink" title="创建轴网"></a>创建轴网</h3><p>Grid类中有两个重载的Create（）方法可用于在Revit Platform API中创建新的轴网。使用以下方法和不同的参数，可以创建曲线或直线格线：</p>
<p>代码区域15-4：Grid.Create（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Arc arc </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Line line </span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：用于创建网格的弧或线必须位于水平面内。</p>
<p>下面的代码示例演示如何创建带有直线或圆弧的新轴网。</p>
<p>代码区域15-5：使用直线或圆弧创建网格</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the geometry line which the grid locates</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry line</span></span><br><span class="line">    Grid lineGrid = Grid.Create(document, geomLine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == lineGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new straight grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    lineGrid.Name = <span class="string">&quot;New Name1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the geometry arc which the grid locates</span></span><br><span class="line">    XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry arc</span></span><br><span class="line">    Grid arcGrid = Grid.Create(document, geomArc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arcGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new curved grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    arcGrid.Name = <span class="string">&quot;New Name2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在Revit中，创建轴网时，轴网将自动按数字或字母顺序命名。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>一些建筑项目，如翻新，分阶段进行。阶段具有以下特征：</p>
<ul>
<li>阶段表示项目生命周期中的不同时间段。</li>
<li>建筑物内图元的寿命由阶段控制。</li>
<li>每个元素都有一个构造阶段，但只有具有有限寿命的元素才有一个破坏阶段。</li>
</ul>
<p>项目中的所有阶段都可以从Document对象中检索。Phase对象包含三个有用的信息：Name、ID和UniqueId。其余属性始终返回null或空集合。</p>
<p>添加到项目中的每个新建模构件都具有“创建的阶段ID”和“拆除的阶段ID”特性。Element.AllowPhases（）方法指示是否可以修改其阶段ID属性。</p>
<p>“创建的阶段ID”特性具有以下特征：</p>
<ul>
<li>它标识添加组件的阶段。</li>
<li>默认值为与当前视图“阶段”值相同的ID。</li>
<li>通过选择与下拉列表相对应的新值来更改“创建的阶段ID”参数。</li>
</ul>
<p>已拆除阶段ID属性具有以下特征：</p>
<ul>
<li>它标识在哪个阶段拆除构件。</li>
<li>默认值为无。</li>
<li>使用拆除工具拆除构件会将特性更新为拆除图元所在视图中的当前阶段ID值。</li>
<li>可以通过将“已拆除的阶段ID”特性设置为其他值来拆除构件。</li>
<li>如果使用Revit Platform API删除某个阶段，则当前阶段中的所有建模构件仍然存在。这些元件的“创建的阶段ID”参数值将更改为“特性”对话框下拉列表中的下一项。 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3840696A-98D6-4898-8004-EFB85A3247E1-low.png" alt="img"></li>
</ul>
<p>图65：阶段创建的组件参数值</p>
<p>下面的代码示例显示当前文档中支持的所有阶段。阶段名称显示在消息框中。</p>
<p>代码区域15-6：展示所有支持的阶段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_Phase</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the phase array which contains all the phases.</span></span><br><span class="line">        PhaseArray phases = doc.Phases;</span><br><span class="line">        <span class="comment">// Format the string which identifies all supported phases in the current document.</span></span><br><span class="line">        String prompt = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != phases.Size)</span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;All the phases in current document list as follow:&quot;</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (Phase ii <span class="keyword">in</span> phases)</span><br><span class="line">                &#123;</span><br><span class="line">                        prompt += <span class="string">&quot;\n\t&quot;</span> + ii.Name;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;There are no phases in current document.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user the information.</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h2><p>设计选项提供了一种在项目中探索备选设计的方法。</p>
<p>设计选项提供了适应项目范围变化或开发供审查的替代设计的灵活性。您可以开始使用主项目模型，然后沿着向客户展示的方式开发变体。大多数图元都可以添加到设计选项中。不能添加到设计选项中的图元被视为主模型的一部分，并且没有设计备选方案。</p>
<p>设计选项的主要用途是作为元素类的属性。请参阅以下示例。</p>
<p>代码区域15-7：使用设计选项</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_DesignOption</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the selected Elements in the Active Document</span></span><br><span class="line">    UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="comment">//Use the DesignOption property of Element</span></span><br><span class="line">        <span class="keyword">if</span> (element.DesignOption != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,element.DesignOption.Name.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下规则适用于设计选项</p>
<ul>
<li>如果元素位于主模型中，则DesignOption属性的值为null。否则，将返回在Revit UI中创建的名称。</li>
<li>ActiveDocument中只能存在一个活动DesignOption元素。<ul>
<li>主选项被视为默认的活动DesignOption。例如，一个设计选项集名为“墙”，该设计选项集中有两个设计选项，分别名为“砖墙”和“玻璃墙”。如果“砖墙”是主选项，则元素迭代器只检索此选项和属于它的元素。“玻璃墙”不活跃。</li>
</ul>
</li>
</ul>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/16%E5%9F%BA%E5%87%86%E5%92%8C%E4%BF%A1%E6%81%AF%E5%85%83%E7%B4%A0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/15%E6%A6%82%E5%BF%B5%E8%AE%BE%E8%AE%A1/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Conceptual_Design_html">概念设计</a></h1><p>本章讨论用于在族文档中创建复杂几何图形的Revit API的概念设计功能。通过添加新对象（点和通过这些点的样条曲线）来支持形状制作。可以分割、填充图案和嵌板化生成的曲面，以创建具有持久参数关系的可构建形状。</p>
<p>本节中的页面</p>
<ul>
<li>点和曲线对象</li>
<li>形状</li>
<li>曲面的几何化</li>
<li>自适应构件</li>
<li>创建.addin清单文件</li>
</ul>
<h2 id="点和曲线对象"><a href="#点和曲线对象" class="headerlink" title="点和曲线对象"></a>点和曲线对象</h2><p>参照点是在概念设计环境的XYZ工作空间中指定位置的元素。可以创建参照点来设计和打印直线、样条曲线和形状。可以将ReferencePoint添加到ReferencePointArray，然后用于创建CurveByPoints，而CurveByPoints又可用于创建形状。</p>
<p>下面的示例演示如何创建CurveByPoints对象。请参见下一节中的“创建放样形状”示例，了解如何从多个CurveByPoints对象创建形状。</p>
<p>代码区域14-1：创建新的CurveByPoints</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体量中创建</span></span><br><span class="line">ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line"></span><br><span class="line">XYZ xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ReferencePoint rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">150</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">CurveByPoints curve = document.FamilyCreate.NewCurveByPoints(rpa);</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-91A84A22-3B88-45F4-B7CE-8D75F685A95A-low.png"></p>
<p>图54：CurveByPoints曲线</p>
<p>参照点可以基于XYZ坐标创建，如上例所示，也可以相对于其他几何图元创建，以便当参照几何图元更改时，这些点会移动。这些点使用PointElementReference类的子类创建。这些子类是：</p>
<ul>
<li>PointOnEdge</li>
<li>PointOnEdgeEdgeIntersection</li>
<li>PointOnEdgeFaceIntersection</li>
<li>PointOnFace</li>
<li>PointOnPlane</li>
</ul>
<p>例如，上一个示例中的最后两行代码在CurveByPoints的中间创建了一个参考点。</p>
<p>可以使用模型线或参照线创建形状。模型线在创建过程中由形状“使用”，不再作为单独的图元存在。另一方面，参照线在形状创建后仍然存在，如果移动它们，可能会改变形状。虽然API没有ReferenceLine类，但可以使用ModelCurve.ChangeToReferenceLine（）方法将模型线更改为参考线。</p>
<p>代码区域14-2：使用参照线创建形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo失败（报错，无效操作）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FormArray <span class="title">CreateRevolveForm</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormArray revolveForms = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create axis for revolve form</span></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ModelCurve axis = MakeLine(document, ptA, ptB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make axis a Reference Line</span></span><br><span class="line">    axis.ChangeToReferenceLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typically this operation produces only a single form, </span></span><br><span class="line">    <span class="comment">// but some combinations of arguments will create multiple froms from a single profile.</span></span><br><span class="line">    revolveForms = document.FamilyCreate.NewRevolveForms(<span class="literal">true</span>, ref_ar, axis.GeometryCurve.Reference, <span class="number">0</span>, Math.PI / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> revolveForms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F5F29826-D2EA-4007-8C3F-8F30975261C4-low.png"></p>
<p>图55：生成的Revolve表单</p>
<h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><h3 id="创建形状"><a href="#创建形状" class="headerlink" title="创建形状"></a>创建形状</h3><p>与族创建类似，概念设计环境提供了创建新形状的功能。可以创建以下类型的形状：拉伸、旋转、放样、放样融合、放样和曲面形状。体量族不使用族创建中使用的“混合”、“拉伸”、“旋转”、“放样”和“放样融合”类，而是将“形状”类用于所有类型的形状。</p>
<p>拉伸形状是从平面的闭合曲线回路创建的。旋转形状是根据轮廓和与轮廓在同一平面上的直线创建的，轮廓是围绕其旋转形状以创建三维形状的轴。放样形状是从沿沿着平面路径放样的二维轮廓创建的。放样融合是从多个轮廓创建的，每个轮廓都是平面的，沿沿着单个曲线放样。放样形状由位于不同平面上的两个或多个截面轮廓创建。单个曲面形状是从轮廓创建的，类似于拉伸，但不指定高度。</p>
<p>下面的示例创建一个简单的拉伸形状。请注意，由于用于创建形状的ModelCurves不会转换为参照线，因此它们将由生成的形状使用。</p>
<p>代码区域14-3：创建拉伸形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateExtrusionForm</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Form extrusionForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The extrusion form direction</span></span><br><span class="line">    XYZ direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    extrusionForm = document.FamilyCreate.NewExtrusionForm(<span class="literal">true</span>, ref_ar, direction);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> profileCount = extrusionForm.ProfileCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extrusionForm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-ACA912B3-A871-4886-8600-A95C293FB2D5-low.png"></p>
<p>图56：所得拉伸形状</p>
<p>下面的示例显示如何使用一系列CurveByPoints对象创建放样形状。</p>
<p>代码区域14-4：创建放样形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateLoftForm</span>(<span class="params">Autodesk.Revit.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Form loftForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">        ReferenceArrayArray ref_ar_ar = <span class="keyword">new</span> ReferenceArrayArray();</span><br><span class="line">        ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ReferencePoint rp = <span class="literal">null</span>;</span><br><span class="line">        XYZ xyz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make first profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        CurveByPoints cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make second profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make third profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">50</span>, <span class="number">5</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line"></span><br><span class="line">        loftForm = document.FamilyCreate.NewLoftForm(<span class="literal">true</span>, ref_ar_ar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loftForm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F7F53FC-51B6-4547-86C4-709C11B72FCA-low.png"></p>
<p>图57：生成的放样形状</p>
<h3 id="形状修改"><a href="#形状修改" class="headerlink" title="形状修改"></a>形状修改</h3><p>一旦创建，可以通过改变形状的子元素（即面、边、曲线或顶点）或整个轮廓来修改形状。修改表单的方法包括：</p>
<ul>
<li>AddEdge</li>
<li>AddProfile</li>
<li>DeleteProfile</li>
<li>DeleteSubElement</li>
<li>MoveProfile </li>
<li>MoveSubElement </li>
<li>RotateProfile</li>
<li>RotateSubElement</li>
<li>ScaleSubElement</li>
</ul>
<p>此外，可以通过添加边或轮廓来修改形状，然后可以使用上面列出的方法进行修改。</p>
<p>下面的示例将给定形状的第一条轮廓曲线移动指定的偏移量。相应的图显示了将此代码应用于上一个示例中的放样形式的结果。</p>
<p>代码区域14-5：移动轮廓</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveForm</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> profileCount = form.ProfileCount;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// modify the first form only</span></span><br><span class="line">                <span class="keyword">if</span> (form.CanManipulateProfile(profileIndex))</span><br><span class="line">                &#123;</span><br><span class="line">                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                form.MoveProfile(profileIndex, offset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BCA27D2B-71B9-40CE-A94E-2858C22B8A08-low.png"></p>
<p>图58：修改后的放样形式</p>
<p>下一个示例演示如何移动给定形状的单个顶点。相应的图演示了此代码对前面的拉伸形状示例的影响</p>
<p>代码区域14-6：移动子元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveSubElement</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// get first profile</span></span><br><span class="line">                ReferenceArray ra = form.get_CurveLoopReferencesOnProfile(profileIndex, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> ra)</span><br><span class="line">                &#123;</span><br><span class="line">                        ReferenceArray ra2 = form.GetControlPoints(r);</span><br><span class="line">                        <span class="keyword">foreach</span> (Reference r2 <span class="keyword">in</span> ra2)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Point vertex = document.GetElement(r2).GetGeometryObjectFromReference(r2) <span class="keyword">as</span> Point;</span><br><span class="line"></span><br><span class="line">                                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">                                form.MoveSubElement(r2, offset);</span><br><span class="line">                                <span class="keyword">break</span>;  <span class="comment">// just move the first point</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图59：修改拉伸的形状</p>
<h2 id="表面的几何化"><a href="#表面的几何化" class="headerlink" title="表面的几何化"></a>表面的几何化</h2><h3 id="分割表面"><a href="#分割表面" class="headerlink" title="分割表面"></a>分割表面</h3><p>形状的面可以用UV网格划分。可以使用DividedSurface.GetReferencesWithDividedSurface（）和DividedSurface.GetDividedSurfaceForReference（）方法（如后续示例所示）访问分割曲面的数据，也可以在形状上创建新的分割曲面，如下所示。</p>
<p>代码区域14-7：划分表面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DivideSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line">    Options opt = application.Create.NewGeometryOptions();</span><br><span class="line">    opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = form.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">        <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (face.Reference != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                DividedSurface ds = DividedSurface.Create(document,face.Reference);</span><br><span class="line">                <span class="comment">// create a divided surface with fixed number of U and V grid lines</span></span><br><span class="line">                SpacingRule srU = ds.USpacingRule;</span><br><span class="line">                srU.SetLayoutFixedNumber(<span class="number">16</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                SpacingRule srV = ds.VSpacingRule;</span><br><span class="line">                srV.SetLayoutFixedNumber(<span class="number">24</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// just divide one face of form</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-68B498E3-3756-47BF-8392-1F12F2F8D4ED-low.png"></p>
<p>图60：由UV网格划分的形状面</p>
<p>通过指定DividedSurface的USpacing和VSpacing属性，可以为U和V网格线定义SpacingRule，方法是指定固定的网格数（如上例所示）、网格之间的固定距离或网格之间的最小或最大间距。每个间距规则都需要其他信息，例如对正和网格旋转。</p>
<p>图案化表面</p>
<p>可以对分割的曲面进行阵列。任何内置平铺填充图案都可以应用于分割表面。平铺图案是指定给DividedSurface的ElementType。平铺图案根据UV栅格布局应用于曲面，因此更改DividedSurface的USpacing和VSpacing属性将影响图案化曲面的显示方式。</p>
<p>下面的示例演示如何使用OctagonRotate图案覆盖分割曲面。相应的图显示了将其应用于上一示例中的分割曲面时的外观。注意这个例子还演示了如何在窗体上获取DividedSurface。</p>
<p>代码区域14-8：图案化表面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TileSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cover surface with OctagonRotate tile pattern</span></span><br><span class="line">    TilePatterns tilePatterns = document.Settings.TilePatterns;</span><br><span class="line">    <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> DividedSurface.GetReferencesWithDividedSurfaces(form))</span><br><span class="line">    &#123;</span><br><span class="line">        DividedSurface ds = DividedSurface.GetDividedSurfaceForReference(document, r);</span><br><span class="line">        ds.ChangeTypeId(tilePatterns.GetTilePattern(TilePatternsBuiltIn.OctagonRotate).Id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图61：应用于分割表面的平铺图案</p>
<p>除了将内置的平铺填充图案应用于分割表面之外，还可以使用“基于幕墙嵌板填充图案的.rft”样板创建自己的体量嵌板族。然后，可以使用DividedSurface.ChangeTypeId（）方法将这些嵌板族载入体量族并应用于分割曲面。</p>
<p>“族”的下列属性特定于幕墙嵌板族：</p>
<ul>
<li>IsCurtainPanelFamily</li>
<li>CurtainPanelHorizontalSpacing -分隔网格的水平间距</li>
<li>CurtainPanelVerticalSpacing -分隔网格的垂直间距</li>
<li>CurtainPanelTilePattern -平铺图案的选择</li>
</ul>
<p>下面的示例演示如何编辑体量嵌板族，然后将其应用于概念体量文档中的形状。若要运行此示例，请首先使用“Curtain Panel Pattern Based.rft”样板创建一个新的族文档。</p>
<p>代码区域14-9：编辑幕墙嵌板族</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Family family = document.OwnerFamily;</span><br><span class="line"><span class="keyword">if</span> (family.IsCurtainPanelFamily == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">    family.CurtainPanelTilePattern == TilePatternsBuiltIn.Rectangle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first change spacing of grids in family document</span></span><br><span class="line">    family.CurtainPanelHorizontalSpacing = <span class="number">20</span>;</span><br><span class="line">    family.CurtainPanelVerticalSpacing = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new points and lines on grid</span></span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = document.Application;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(ReferencePoint)).ToElements();</span><br><span class="line">    <span class="built_in">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    ReferencePoint rp0 = <span class="literal">null</span>, rp1 = <span class="literal">null</span>, rp2 = <span class="literal">null</span>, rp3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        ReferencePoint rp = e <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">        <span class="keyword">switch</span> (ctr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                rp0 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                rp1 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                rp2 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                rp3 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferencePointArray rpAr = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">    rpAr.Append(rp0);</span><br><span class="line">    rpAr.Append(rp2);</span><br><span class="line">    CurveByPoints curve1 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve25 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.25</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeA = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpA = document.FamilyCreate.NewReferencePoint(poeA);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve75 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.75</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeB = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpB = document.FamilyCreate.NewReferencePoint(poeB);</span><br><span class="line"></span><br><span class="line">    rpAr.Clear();</span><br><span class="line">    rpAr.Append(rp1);</span><br><span class="line">    rpAr.Append(rp3);</span><br><span class="line">    CurveByPoints curve2 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointOnEdge poeC = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpC = document.FamilyCreate.NewReferencePoint(poeC);</span><br><span class="line">    PointOnEdge poeD = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpD = document.FamilyCreate.NewReferencePoint(poeD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a curtain family document before calling this command.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8EECE3F0-4C1F-4B31-9133-D3D64676E7FE-low.png"></p>
<p>图62：幕墙嵌板族</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-263500A5-C732-4E47-B9AA-D878AF9E9729-low.png"></p>
<p>图63：指定给分割表面的幕墙嵌板</p>
<h2 id="自适应构件"><a href="#自适应构件" class="headerlink" title="自适应构件"></a>自适应构件</h2><p>自适应组件旨在处理组件需要灵活地适应许多独特的上下文条件的情况。例如，自适应构件可用于通过排列符合用户定义约束的多个构件生成的重复系统中。</p>
<p>下面的代码显示如何将自适应构件族的实例创建到体量族中，并以数学方式设置每个点的位置。</p>
<p>代码区域：创建自适应构件族的实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateAdaptiveComponentInstance</span>(<span class="params">Document document, FamilySymbol symbol</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a new instance of an adaptive component family</span></span><br><span class="line">            FamilyInstance instance = AdaptiveComponentInstanceUtils.CreateAdaptiveComponentInstance(document, symbol);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the placement points of this instance</span></span><br><span class="line">            <span class="keyword">var</span> placePointIds = <span class="keyword">new</span> List&lt;ElementId&gt;();</span><br><span class="line">            placePointIds = AdaptiveComponentInstanceUtils.GetInstancePlacementPointElementRefIds(instance).ToList();</span><br><span class="line">            <span class="built_in">double</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the position of each placement point</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> placePointIds)</span><br><span class="line">            &#123;</span><br><span class="line">                ReferencePoint point = document.GetElement(id) <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">                point.Position = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>*x, <span class="number">10</span>*Math.Cos(x), <span class="number">0</span>);</span><br><span class="line">                x += Math.PI / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>若要批处理创建自适应组件，可以使用FamilyInstanceCreationData构造函数的重载，该构造函数接受两个参数-FamilySymbol和要初始化自适应实例的XYZ自适应点列表。结合使用Autodesk. Rev. Creation. ItemFactoryBase. NewFamilyInstances 2（）方法（该方法采用FamilyInstanceCreationData对象列表），可以一次添加多个自适应构件。这可能比逐个放置单个自适应组件更有效。</p>
<h2 id="创建-addin清单文件"><a href="#创建-addin清单文件" class="headerlink" title="创建.addin清单文件"></a>创建.addin清单文件</h2><p>HelloWorld.dll文件出现在项目输出目录中。如果要在Revit中调用应用程序，请创建清单文件以将其注册到Revit中。</p>
<p>创建清单文件</p>
<ol>
<li><p>在记事本中创建一个新的文本文件。</p>
</li>
<li><p>增加以下案文：</p>
<p>代码区域30-10：为外部命令创建.addin清单文件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HelloWorld</span><br><span class="line">    HelloWorld.HelloWorld</span><br><span class="line">    HelloWorld</span><br><span class="line">    Show Hello World.</span><br><span class="line">    AlwaysVisible</span><br><span class="line">    C:\Samples\HelloWorld\HelloWorld\bin\Debug\HelloWorld.dll</span><br><span class="line">    <span class="number">239B</span>D853<span class="number">-36E4</span><span class="number">-461f</span><span class="number">-9171</span>-C5ACEDA4E723</span><br><span class="line">    ADSK</span><br><span class="line">    Autodesk, Inc, www.autodesk.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：FullClassName包括在项目属性的“应用程序”选项卡上找到的根命名空间。</p>
<p>将文件保存为HelloWorld.addin并将其放在以下位置：</p>
<ul>
<li>C:\ProgramData\Autodesk\Revit\Addins\2018\</li>
</ul>
<p>有关使用清单文件的更多详细信息，请参阅加载项集成。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/15%E6%A6%82%E5%BF%B5%E8%AE%BE%E8%AE%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/14%E6%97%8F%E6%96%87%E6%A1%A3/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="族文档"><a href="#族文档" class="headerlink" title="族文档"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Documents_html">族文档</a></h1><p>本节讨论族以及如何：</p>
<ul>
<li>创建和修改族文档</li>
<li>访问族类型和参数</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>关于族文档</li>
<li>在族中创建图元</li>
<li>族元素的可见性</li>
<li>管理族类型和参数</li>
</ul>
<h2 id="关于族文档"><a href="#关于族文档" class="headerlink" title="关于族文档"></a>关于族文档</h2><h3 id="族"><a href="#族" class="headerlink" title="族"></a>族</h3><p>族对象表示整个Revit族。族文档是表示族的文档(rfa)而不是Revit项目。</p>
<p>使用Revit API的族创建功能，可以创建和编辑族及其类型。当您有来自外部系统的现有数据并希望将其转换为Revit族库时，此功能特别有用。</p>
<p>对系统族编辑的API访问不可用。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>如前一节所述，Family.FamilyCategory属性指示族的类别，如柱、家具、结构框架或窗。</p>
<p>以下代码可用于确定打开的Revit族文档中族的类别。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> categoryName = familyDoc.OwnerFamily.FamilyCategory.Name;</span><br></pre></td></tr></table></figure>

<p>还可以设置FamilyCategory，以允许更改正在编辑的族的类别。</p>
<p> <strong>参数设置</strong> 可以从族文档的OwnerFamily属性访问族参数，如下例所示。</p>
<p>代码区域13-2：打开的Revit族文档的类别</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the owner family of the family document.</span></span><br><span class="line">Family family = familyDoc.OwnerFamily; </span><br><span class="line">Parameter param = family.get_Parameter(BuiltInParameter.FAMILY_WORK_PLANE_BASED);</span><br><span class="line"><span class="comment">// this param is a Yes/No parameter in UI, but an integer value in API</span></span><br><span class="line"><span class="comment">// 1 for true and 0 for false</span></span><br><span class="line"><span class="built_in">int</span> isTrue = param.AsInteger(); </span><br><span class="line"><span class="comment">// param.Set(1); // set value to true.</span></span><br></pre></td></tr></table></figure>

<h3 id="创建族文档"><a href="#创建族文档" class="headerlink" title="创建族文档"></a>创建族文档</h3><p>如果文档是族文档（由IsFamilyDocument属性确定），则可以通过Document类修改Revit族文档并访问族类型和参数。若要在处理Project文档时编辑现有族，请使用Document类中提供的EditFamily（）函数，然后在编辑完成后使用LoadFamily（）将族重新加载回所有者文档。要创建新的族文档，请使用Application.NewFamilyDocument（）：</p>
<p>代码区域13-3：创建新的族文档</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new family document using Generic Model.rft template</span></span><br><span class="line"><span class="built_in">string</span> templateFileName = <span class="string">@&quot;C:\Documents and Settings\All Users\Application Data\Autodesk\RST 2011\Imperial Templates\Generic Model.rft&quot;</span>;</span><br><span class="line"></span><br><span class="line">Document familyDocument = application.NewFamilyDocument(templateFileName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == familyDocument)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Cannot open family document&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套族符号"><a href="#嵌套族符号" class="headerlink" title="嵌套族符号"></a>嵌套族符号</h3><p>可以过滤FamilySymbols的族文档，以将所有FamilySymbols加载到族中。在此代码示例中，列出了给定FamilyInstance的族中的所有嵌套FamilySymbol。</p>
<p>代码区域13-4：在族中获取嵌套的族符号</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetLoadedSymbols</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Symbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get family associated with this</span></span><br><span class="line">                Family family = familyInstance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get Family document for family</span></span><br><span class="line">                Document familyDoc = document.EditFamily(family);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familyDoc &amp;&amp; familyDoc.IsFamilyDocument == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        String loadedFamilies = <span class="string">&quot;FamilySymbols in &quot;</span> + family.Name + <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">                        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">                        ICollection collection = </span><br><span class="line">                                collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">                        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">                        &#123;</span><br><span class="line">                                FamilySymbol fs = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                                loadedFamilies += <span class="string">&quot;\t&quot;</span> + fs.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,loadedFamilies);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在族中创建元素"><a href="#在族中创建元素" class="headerlink" title="在族中创建元素"></a>在族中创建元素</h2><p>FamilyItemFactory类提供了在族文档中创建图元的功能。可以通过Document.FamilyCreate属性访问它。FamilyItemFactory派生自ItemFactoryBase类，该类是一个实用的用于在Revit项目文档和族文档中创建元素。</p>
<p> 本节中的页面</p>
<ul>
<li>创建表单元素</li>
<li>创建注释</li>
</ul>
<h3 id="创建形状元素"><a href="#创建形状元素" class="headerlink" title="创建形状元素"></a>创建形状元素</h3><p>FamilyItemFactory类提供了在族中创建形状图元的功能，例如拉伸、旋转、放样和融合。有关这些3D草图表格的更多信息，请参见3D草图部分。</p>
<p>下面的示例演示如何创建新的Extrusion元素。它将创建一个简单的矩形截面轮廓，然后将新创建的“拉伸”移动到新位置。</p>
<p>代码区域：创建新拉伸</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Extrusion <span class="title">CreateExtrusion</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Extrusion rectExtrusion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// define the profile for the extrusion</span></span><br><span class="line">        CurveArrArray curveArrArray = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray curveArray1 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray2 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray3 = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a rectangular profile</span></span><br><span class="line">        XYZ p0 = XYZ.Zero;</span><br><span class="line">        XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line">        Line line2 = Line.CreateBound(p1, p2);</span><br><span class="line">        Line line3 = Line.CreateBound(p2, p3);</span><br><span class="line">        Line line4 = Line.CreateBound(p3, p0);</span><br><span class="line">        curveArray1.Append(line1);</span><br><span class="line">        curveArray1.Append(line2);</span><br><span class="line">        curveArray1.Append(line3);</span><br><span class="line">        curveArray1.Append(line4);</span><br><span class="line"></span><br><span class="line">        curveArrArray.Append(curveArray1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create solid rectangular extrusion</span></span><br><span class="line">        rectExtrusion = document.FamilyCreate.NewExtrusion(<span class="literal">true</span>, curveArrArray, sketchPlane, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rectExtrusion)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move extrusion to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">-16</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, rectExtrusion.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new Extrusion failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rectExtrusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何从族文档中的实心卵形轮廓创建新放样。</p>
<p>代码区域：创建新放样</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sweep <span class="title">CreateSweep</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sweep sweep = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Define a profile for the sweep</span></span><br><span class="line">        CurveArrArray arrarr = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray arr = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an ovoid profile</span></span><br><span class="line">        XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        arr.Append(Arc.Create(pnt2, <span class="number">1.0</span>d, <span class="number">0.0</span>d, <span class="number">180.0</span>d, XYZ.BasisX, XYZ.BasisY));</span><br><span class="line">        arr.Append(Arc.Create(pnt1, pnt3, pnt2));</span><br><span class="line">        arrarr.Append(arr);</span><br><span class="line">        SweepProfile profile = document.Application.Create.NewCurveLoopsProfile(arrarr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a path for the sweep</span></span><br><span class="line">        XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt5 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Curve curve = Line.CreateBound(pnt4, pnt5);</span><br><span class="line"></span><br><span class="line">        CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        curves.Append(curve);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a solid ovoid sweep</span></span><br><span class="line">        sweep = document.FamilyCreate.NewSweep(<span class="literal">true</span>, curves, sketchPlane, profile, <span class="number">0</span>, ProfilePlaneLocation.Start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != sweep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, sweep.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create a new Sweep.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sweep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-169B9078-7508-4982-B10D-333FF97CA345-low.png"></p>
<p>图50：由上一个示例创建的卵形扫描</p>
<p> FreeFormElement类允许创建从输入实体轮廓创建的非参数化几何体。FreeFormElement可以与其他可组合元素一起参与连接和空切割。元素的平面可以在面法线方向上以交互方式和编程方式偏移。</p>
<p>将子类别转换为形状 在族中创建新形状后，可能需要修改形状的子类别。例如，您可能有一个门族，并且希望创建多个门的子类别，并将不同的子类别指定给族中的不同门类型。 下面的示例演示如何创建新的子类别，为其指定材质，然后将该子类别指定给窗体。</p>
<p>代码区域：指定子类别</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AssignSubCategory</span>(<span class="params">Document document, GenericForm extrusion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new subcategory</span></span><br><span class="line">    Category cat = document.OwnerFamily.FamilyCategory;</span><br><span class="line">    Category subCat = document.Settings.Categories.NewSubcategory(cat, <span class="string">&quot;NewSubCat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new material and assign it to the subcategory</span></span><br><span class="line">    ElementId materialId = Material.Create(document, <span class="string">&quot;Wood Material&quot;</span>);</span><br><span class="line">    subCat.Material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign the subcategory to the element</span></span><br><span class="line">    extrusion.Subcategory = subCat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建注释"><a href="#创建注释" class="headerlink" title="创建注释"></a>创建注释</h3><p>还可以在族中创建新注释（例如尺寸标注和ModelText和TextNote对象）以及曲线注释元素（例如SymbolicCurve、ModelCurve和DetailCurve）。有关注释元素的详细信息，请参见注释元素。</p>
<p>此外，还可以添加新路线，并参照确定路线方向的视图和两个几何图形参照。</p>
<p>以下示例演示如何创建新的弧长标注。</p>
<p>代码区域：创建标注</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateArcDimension</span>(<span class="params">Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.Creation.Application appCreate = document.Application.Create;</span><br><span class="line">    Line gLine1 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    Line gLine2 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arctoDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arcofDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0.8</span>, <span class="number">2.8</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.Creation.FamilyItemFactory creationFamily = document.FamilyCreate;</span><br><span class="line">    ModelCurve modelCurve1 = creationFamily.NewModelCurve(gLine1, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve2 = creationFamily.NewModelCurve(gLine2, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve3 = creationFamily.NewModelCurve(arctoDim, sketchPlane);</span><br><span class="line">    <span class="comment">//get their reference</span></span><br><span class="line">    Reference ref1 = modelCurve1.GeometryCurve.Reference;</span><br><span class="line">    Reference ref2 = modelCurve2.GeometryCurve.Reference;</span><br><span class="line">    Reference arcRef = modelCurve3.GeometryCurve.Reference;</span><br><span class="line"></span><br><span class="line">    Dimension newArcDim = creationFamily.NewArcLengthDimension(document.ActiveView, arcofDim, arcRef, ref1, ref2);</span><br><span class="line">    <span class="keyword">if</span> (newArcDim == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new arc length dimension.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArcDim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-813DEE5B-AD67-4892-934A-EF192F72A5BB-low.png"></p>
<p>图51：产生的弧长尺寸</p>
<p>某些类型的尺寸标注可以使用FamilyParameter进行标记。如果尝试获取或设置Label属性，则无法标记的尺寸标注将引发Autodesk.Revit. Revit.InvalidOperationException。在下面的示例中，在两条线之间创建了一个新的线性尺寸标注，并将其标记为“width”。</p>
<p>代码区域：标注尺寸</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateLinearDimension</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first create two lines</span></span><br><span class="line">    XYZ pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pt2 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Line line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve1 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve2 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now create a linear dimension between them</span></span><br><span class="line">    ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">    ra.Append(modelcurve1.GeometryCurve.Reference);</span><br><span class="line">    ra.Append(modelcurve2.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line"></span><br><span class="line">    Dimension dim = document.FamilyCreate.NewLinearDimension(document.ActiveView, line, ra);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a label for the dimension called &quot;width&quot;</span></span><br><span class="line">    FamilyParameter param = document.FamilyManager.AddParameter(<span class="string">&quot;width&quot;</span>, </span><br><span class="line">        BuiltInParameterGroup.PG_CONSTRAINTS, </span><br><span class="line">        ParameterType.Length, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    dim.FamilyLabel = param;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-802D577E-3791-4286-A288-0B7858C6459C-low.png"></p>
<p>图52：标记的线性尺寸</p>
<h2 id="族元素的可见性"><a href="#族元素的可见性" class="headerlink" title="族元素的可见性"></a>族元素的可见性</h2><p>FamilyElementVisibility类可用于控制族图元在项目文档中的可见性。例如，如果有门族，则可能只希望门开启方向在放置门的项目文档的平面视图中可见，而在三维视图中不可见。通过设置门开启方向的可见性，您可以控制其可见性。FamilyElementVisibility适用于以下具有SetVisibility（）函数的族图元类：</p>
<ul>
<li>GenericForm</li>
<li>SymbolicCurve</li>
<li>ModelText </li>
<li>CurveByPoints</li>
<li>ModelCurve </li>
<li>ReferencePoint </li>
<li>ImportInstance</li>
</ul>
<p>在下面的示例中，生成的族文档将显示文本“Hello World”，其下有一条线。当族载入到Revit项目文档中并放置实例时，在平面视图中，只有该线可见。在3D视图中，将同时显示线条和文本，除非将“详细程度”设置为“粗”，在这种情况下，线条将消失。</p>
<p>代码区域13-10：设置族图元可见性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateAndSetVisibility</span>(<span class="params">Autodesk.Revit.DB.Document familyDocument, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new ModelCurve in the family document</span></span><br><span class="line">    XYZ p0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line"></span><br><span class="line">    ModelCurve modelCurve1 = familyDocument.FamilyCreate.NewModelCurve(line1, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new ModelText along ModelCurve line</span></span><br><span class="line">    ModelText text = familyDocument.FamilyCreate.NewModelText(<span class="string">&quot;Hello World&quot;</span>, <span class="literal">null</span>, sketchPlane, p0, HorizontalAlign.Center, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for text</span></span><br><span class="line">    FamilyElementVisibility textVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    textVisibility.IsShownInTopBottom = <span class="literal">false</span>;</span><br><span class="line">    text.SetVisibility(textVisibility);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for line</span></span><br><span class="line">    FamilyElementVisibility curveVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    curveVisibility.IsShownInCoarse = <span class="literal">false</span>;</span><br><span class="line">    modelCurve1.SetVisibility(curveVisibility);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管理族类型和参数"><a href="#管理族类型和参数" class="headerlink" title="管理族类型和参数"></a>管理族类型和参数</h2><p>族文档提供对FamilyManager属性的访问。FamilyManager类提供对族类型和参数的访问。使用此类，可以添加和删除类型、添加和删除族参数和共享参数、设置不同族类型中的参数值以及定义公式来驱动参数值。</p>
<p><strong>在族中获取种类</strong></p>
<p>FamilyManager可用于遍历族中的种类，如下例所示。</p>
<p>代码区域13-11：获取族中的种类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetFamilyTypesInFamily</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (familyDoc.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get types in family</span></span><br><span class="line">        <span class="built_in">string</span> types = <span class="string">&quot;Family Types: &quot;</span>;</span><br><span class="line">        FamilyTypeSet familyTypes = familyManager.Types;</span><br><span class="line">        FamilyTypeSetIterator familyTypesItor = familyTypes.ForwardIterator();</span><br><span class="line">        familyTypesItor.Reset();</span><br><span class="line">        <span class="keyword">while</span> (familyTypesItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyType familyType = familyTypesItor.Current <span class="keyword">as</span> FamilyType;</span><br><span class="line">            types += <span class="string">&quot;\n&quot;</span> + familyType.Name;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,types);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60AB2EDC-BC4E-4E08-8922-38ECF4B7F991-low.png"></p>
<p>图53：混凝土矩形柱族中的族种类</p>
<p><strong>编辑族种类</strong></p>
<p>FamilyManager提供了遍历族中现有种类以及添加和修改种类及其参数的功能。</p>
<p>下面的示例演示如何添加新种类（familysymbol），设置其参数，然后将新种类分配给FamilyInstance。种类编辑是通过使用Set（）函数在当前种类上完成的。当前种类可从CurrentType属性获得。CurrentType属性可用于在编辑之前设置当前种类，或使用NewType（）函数创建新种类并将其设置为当前种类以进行编辑。</p>
<p>请注意，一旦创建并修改了新种类，就会使用Document.LoadFamily（）将族重新载入到Revit项目中，以使新种类可用。</p>
<p>代码区域13-12：编辑族类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EditFamilyTypes</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// example works best when familyInstance is a rectangular concrete element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">null</span> == document) || (<span class="literal">null</span> == familyInstance.Symbol))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">// invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get family associated with this</span></span><br><span class="line">    Family family = familyInstance.Symbol.Family;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not get the family</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Family document for family</span></span><br><span class="line">    Document familyDoc = document.EditFamily(family);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyDoc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not open a family for edit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// cuould not get a family manager</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start transaction for the family document</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction newFamilyTypeTransaction = <span class="keyword">new</span> Transaction(familyDoc, <span class="string">&quot;Add Type to Family&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> changesMade = <span class="number">0</span>;</span><br><span class="line">        newFamilyTypeTransaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a new type and edit its parameters</span></span><br><span class="line">        FamilyType newFamilyType = familyManager.NewType(<span class="string">&quot;2X2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newFamilyType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// look for &#x27;b&#x27; and &#x27;h&#x27; parameters and set them to 2 feet</span></span><br><span class="line">            FamilyParameter familyParam = familyManager.get_Parameter(<span class="string">&quot;宽度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            familyParam = familyManager.get_Parameter(<span class="string">&quot;高度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == changesMade)   <span class="comment">// set both paramaters?</span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// could not make the change -&gt; should roll back </span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if could not make the change or could not commit it, we return</span></span><br><span class="line">        <span class="keyword">if</span> (newFamilyTypeTransaction.GetStatus() != TransactionStatus.Committed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now update the Revit project with Family which has a new type</span></span><br><span class="line">    LoadOpts loadOptions = <span class="keyword">new</span> LoadOpts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This overload is necessary for reloading an edited family</span></span><br><span class="line">    <span class="comment">// back into the source document from which it was extracted</span></span><br><span class="line">    family = familyDoc.LoadFamily(document, loadOptions);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find the new type and assign it to FamilyInstance</span></span><br><span class="line">        ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol familySymbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != familySymbol) &amp;&amp; familySymbol.Name == <span class="string">&quot;2X2&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (Transaction changeSymbol = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Symbol Assignment&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    changeSymbol.Start();</span><br><span class="line">                    familyInstance.Symbol = familySymbol;</span><br><span class="line">                    changeSymbol.Commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LoadOpts</span> : <span class="title">IFamilyLoadOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnFamilyFound</span>(<span class="params"><span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnSharedFamilyFound</span>(<span class="params">Family sharedFamily, <span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> FamilySource source, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        source = FamilySource.Family;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FamilyManager类提供对所有族参数的访问。这包括族内置参数、类别内置参数和与族类型关联的共享参数。有两种方法可以获取族参数：</p>
<ul>
<li>Parameters property - 获取族中的所有参数</li>
<li>GetParameters（）-按族中所有参数在Revit UI中出现的顺序获取这些参数使用GetParameters（）方法时，Revit UI顺序首先按组确定，然后按各个参数的顺序确定。</li>
</ul>
<p>可以从给定族的API（不支持重新排序参数的钢筋形状族除外）重新排序（在其组内）族参数。这允许参数以最符合逻辑的顺序呈现给用户。排序仅影响同一参数组中的可见参数。属于不同组的参数将保持分离，并且组的顺序不会受到影响。</p>
<p>对参数重新排序的最简单方法是使用FamilyManager.SortParameters（）方法，该方法接受一个指示所需排序顺序的参数。下面的示例按升序对参数进行排序。</p>
<p>代码区域：对族参数排序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisplayParametersInAscendingOrder</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    familyManager.SortParameters(ParametersOrder.Ascending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：排序是一次性操作。当添加新参数时，它们不会自动排序。若要对参数的排序方式进行更多控制，请使用FamilyManager.ReorderParameters（）方法，该方法以新顺序接受族参数列表。此列表必须包含GetParameters（）方法返回的所有参数，包括任何不可见的参数，否则将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/14%E6%97%8F%E6%96%87%E6%A1%A3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/13%E6%97%8F%E5%AE%9E%E4%BE%8B/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="族实例"><a href="#族实例" class="headerlink" title="族实例"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Instances_html">族实例</a></h1><p>在本节中，您将了解以下内容：</p>
<ul>
<li>族与族实例的关系</li>
<li>族和族实例特征</li>
<li>如何载入或创建族和族实例特征</li>
<li>族实例与族符号的关系</li>
</ul>
<p> 本节中的页面</p>
<ul>
<li>Identifying Elements 识别元素</li>
<li>FamilyInstances 族实例</li>
<li>Code Samples 代码示例</li>
<li>FamilySymbol 族符号</li>
<li>Family 族</li>
</ul>
<h2 id="识别元素"><a href="#识别元素" class="headerlink" title="识别元素"></a>识别元素</h2><p>在Revit中，判断元素是否为FamilyInstance的最简单方法是使用属性对话框。</p>
<ul>
<li>如果族名称以“系统族”开头，并且禁用了“载入”按钮，则该族属于“系统族”。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-96BC987E-5C38-45EF-9621-2D6EF89989B1-low.png"></p>
<p>图41：系统族</p>
<ul>
<li>属于构件族的常规FamilyInstance不以System Family开头。</li>
<li>例如，在下图中，桌子家具的族名为Desk。此外，还启用了“加载”按钮。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67F1CF63-64EF-40E4-BF92-284873CDDB31-low.png"></p>
<p>图42：组件族</p>
<p>有一些例外，例如：体量和内建成员。“族”和“类型”字段为空。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A2B06CEE-7E4A-494B-8DE8-7131068F182B-low.png"></p>
<p>图43：体量或内建构件示例</p>
<p>Revit Platform API中的族由三个对象表示：</p>
<ul>
<li>Family </li>
<li>FamilySymbol</li>
<li>FamilyInstance</li>
</ul>
<p>每件对象在族结构中都起着重要的作用。</p>
<p>“族”对象表示整个族，例如单平面门。例如，“单面齐平门族”对应于“单面齐平.rfa”文件。Family对象包含多个FamilySymbols，用于获取所有族符号，以便于将实例从一个符号切换到另一个符号。</p>
<p>FamilySymbol对象表示与Revit UI中的“类型”（例如34”×80”）相对应的一组特定族设置。</p>
<p>FamilyInstance对象表示Revit项目中的实际Type（FamilySymbol）实例。例如，在下图中，FamilyInstance是项目中的一扇门。</p>
<ul>
<li>每个FamilyInstance都有一个FamilySymbol。门是一个34”×80”的实例。</li>
<li>每个FamilySymbol都属于一个Family。34”×80”符号属于单齐平系列。</li>
<li>每个族都包含一个或多个族符号。单齐平系列包含34”×80”符号、34”×84”符号、36”×84”等。</li>
</ul>
<p>注意：虽然大多数组件元素都是通过API类FamilySymbol和FamilyInstance公开的，但也有一些是用特定的API类包装的。例如，AnnotationSymbolType包装FamilySymbol，AnnotationSymbol包装FamilyInstance。</p>
<h2 id="族实例-1"><a href="#族实例-1" class="headerlink" title="族实例"></a>族实例</h2><p>FamilyInstance对象包括梁、支撑、柱、家具、体量等。FamilyInstance对象提供了更详细的属性，以便可以更改项目中的族实例类型和外观。</p>
<h3 id="位置相关属性"><a href="#位置相关属性" class="headerlink" title="位置相关属性"></a>位置相关属性</h3><p>与位置相关的属性显示FamilyInstance对象的物理和几何特征，如方向、旋转和位置。</p>
<h4 id="Orientation-朝向"><a href="#Orientation-朝向" class="headerlink" title="Orientation 朝向"></a>Orientation 朝向</h4><p>对于某些FamilyInstance对象，可以更改面方向或手方向。例如，门可以面向房间或墙壁的外部或内部，并且可以将把手放置在左侧或右侧。下表比较了门、窗和桌子族实例。</p>
<p>表29：比较族实例</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th><strong>Door 门</strong></th>
<th>**Window (Fixed: 36”w × 72”h) **</th>
<th><strong>Desk 书桌</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CanFlipFacing</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
<tr>
<td>CanFlipHand</td>
<td>True</td>
<td>False</td>
<td>False</td>
</tr>
</tbody></table>
<p>如果CanFlipFacing或CanFlipHand为true，则可以分别调用flipFacing（）或flipHand（）方法。这些方法可以分别改变面向方向或手方向。否则，这些方法不执行任何操作并返回False。修改方向时，请记住某些类型的窗可以同时修改手方向和面方向，例如带Trim的3x3平开窗族。门有四种不同的朝向和手方向组合。请参见下图中的组合，下表中列出了相应的布尔值。 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-AC8B1DB7-860B-46D3-A0BD-DBF120980580-low.png"></p>
<p>图44：具有不同面方向和手方向的门</p>
<p>表30：相同类型的不同饰面</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>FacingFlipped</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>True</td>
</tr>
<tr>
<td>HandFlipped</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
</tbody></table>
<h4 id="Orientation-Work-Plane-方位-工作平面"><a href="#Orientation-Work-Plane-方位-工作平面" class="headerlink" title="Orientation - Work Plane 方位-工作平面"></a>Orientation - Work Plane 方位-工作平面</h4><p>也可以更改FamilyInstance的工作平面方向。如果CanFlipWorkPlane为true，则可以设置IsWorkPlaneFlipped属性。尝试为不允许翻转工作平面的FamilyInstance设置此属性将导致异常。</p>
<h4 id="Rotation-Mirrored-旋转-镜像"><a href="#Rotation-Mirrored-旋转-镜像" class="headerlink" title="Rotation - Mirrored 旋转-镜像"></a>Rotation - Mirrored 旋转-镜像</h4><p>镜像属性指示FamilyInstance对象是否已镜像。</p>
<p>表31：门镜像属性</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>Mirrored</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
</tbody></table>
<p>在前面的门示例中，Door 1和Door 2的Mirror属性为False，而Door 3和Door 4的Mirror属性均为True。这是因为在Revit项目中创建门时，默认结果为“门1”或“门2”。要创建类似“门3”或“门4”的门，必须分别翻转“门1”和“门2”的方向。翻转操作类似于镜像变换，这就是为什么“门3”和“门4”镜像属性为True。 有关在Revit中使用Mirror（）方法的详细信息，请参阅“编辑图元”一章。 #### Rotation - CanRotate和rotate（） 族实例布尔CanRotate属性用于测试族实例是否可以旋转180度。这取决于实例所属的族。例如，在下面的图片中，Window 1（Casement 3×3 with Trim：36”×72”）和Door 1（Double-Glass 2：72”×82”）的CanRotate属性为true，而Window 2（Fixed：36“w × 72“h）的CanRotate属性为false。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8E93FD79-81F8-4B3D-B09F-9C9A4A1A556C-low.png"></p>
<p><strong>图45：旋转后的变化</strong> </p>
<p>如果CanRotate为true，则可以调用族实例rotate（）方法，该方法将族实例翻转180度。否则，该方法不执行任何操作并返回False。上图还显示了执行rotate（）方法后的Window 1和Door 1状态。 回想一下本文档前面的旋转图元部分，可以使用ElementTransformUtils.RotateElement（）和ElementTransformUtils.RotateElements（）将族实例（和其他图元）旋转用户指定的角度。</p>
<p><strong>位置</strong> Location属性确定实例在项目中的物理位置。实例可以具有点位置或线位置。 以下特征适用于位置： </p>
<p><em>点位置是LocationPoint类对象-基础、门或桌子都有点位置</em> </p>
<p>线位置是LocationCurve类对象-梁具有线位置。 * 它们都是Location类的子类。 有关位置的详细信息，请参阅编辑元素。</p>
<p>Host和HostFace Host和HostFace都是FamilyInstance属性。 </p>
<p><strong>Host</strong> FamilyInstance对象有一个返回其宿主元素的Host属性。 某些FamilyInstance对象没有宿主元素，如Tables和其他家具，因此Host属性不返回任何内容，因为没有创建主体元素。但是，其他对象（如门和窗）必须具有宿主图元。在这种情况下，Host属性返回窗或门所在的墙元素。请参见下图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-837ECA51-19DE-4B19-A304-A5C26F24EBD0-low.png"></p>
<p>图46：以墙为主体的门和窗 </p>
<p><strong>HostFace</strong> HostFace属性获取对族实例的宿主面的参照，或者如果实例放置在工作平面上，则获取对工作平面下面的几何图形面的参照。如果工作平面未参照其他几何图形，或者实例未以面或工作平面为宿主，则此属性将返回空参照。</p>
<p> <strong>子组件和超级组件</strong> FamilyInstance. GetSubmenentIds（）方法返回加载到该族中的族实例的ElementIds。将“Table-Dining Round w Chairs.rfa”的实例放置在项目中时，GetSubmenuentIds（）方法将返回椅子集的ElementIds。 SuperComponent属性返回族实例的父构件。在“Table-Dining Round w Chairs. rfa”中，每个嵌套椅子的族实例超级组件都是“Table-Dining Round w Chairs. rfa”的实例。</p>
<p>代码区域12-1：从FamilyInstance获取子组件和超级组件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetSubAndSuperComponents</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection subElemSet = familyInstance.GetSubComponentIds();</span><br><span class="line">    <span class="keyword">if</span> (subElemSet != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> subElems = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.ElementId ee <span class="keyword">in</span> subElemSet)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyInstance f = familyInstance.Document.GetElement(ee) <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">            subElems = subElems + f.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Subcomponent count = &quot;</span> + subElemSet.Count + <span class="string">&quot;\n&quot;</span> + subElems);</span><br><span class="line">    &#125;</span><br><span class="line">    FamilyInstance super = familyInstance.SuperComponent <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">    <span class="keyword">if</span> (super != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;SUPER component: &quot;</span> + super.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h3><p>有时，FamilyInstance对象的几何图形会通过连接、剪切、顶盖、延伸或其他在Revit中进行的后期处理进行修改。FamilyInstance.HasModifiedGeometry（）方法标识此FamilyInstance的几何图形是否已从自动生成的默认值修改。GetOriginalGeometry（）方法将返回实例的原始几何体，该几何体在可能发生任何修改之前。若要获取实例的当前几何体，请使用从Element类继承的Geometry属性。</p>
<h3 id="空间元素计算点"><a href="#空间元素计算点" class="headerlink" title="空间元素计算点"></a>空间元素计算点</h3><p>FamilyInstance具有多个成员，用于直接从族实例中阅读有关空间计算点的信息。HasSpatialElementCalculationPoint属性标识此实例是否有一个SpatialElementCalculationPoint用作Revit的搜索点，以标识实例是否位于房间或空间内。如果为true，GetSpatialElementCalculationPoint（）方法将返回此实例的计算点的位置作为XYZ点。</p>
<p>HasSpatialElementFromToCalculationPoints属性标识此实例是否具有一对SpatialElementCalculationPoints，它们用作Revit的搜索点，以标识实例是否位于最多两个房间或空间之间。对于连接两个房间或空间（如门或窗）的族实例，这些点确定哪个房间或空间被视为“从”，哪个被视为“到”。当此属性为true时，GetSpatialElementFromToCalculationPoints（）方法将此实例的计算点的位置作为XYZ点的列表返回。</p>
<h3 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h3><p>本部分中的属性特定于Revit的建筑和结构工程功能。它们在各自的章节中都有详细介绍。</p>
<h4 id="房间信息"><a href="#房间信息" class="headerlink" title="房间信息"></a>房间信息</h4><p>FamilyInstance属性包括Room、FromRoom和ToRoom。有关房间的详细信息，请参阅建筑。</p>
<h4 id="空间信息"><a href="#空间信息" class="headerlink" title="空间信息"></a>空间信息</h4><p>FamilyInstance有一个Space属性，用于标识MEP中保存实例的空间。</p>
<h4 id="结构分析模型"><a href="#结构分析模型" class="headerlink" title="结构分析模型"></a>结构分析模型</h4><p>GetAnalyticalModel（）方法检索族实例结构分析模型。</p>
<p>有关分析模型的详细信息，请参阅结构工程。</p>
<h3 id="创建FamilyInstance对象"><a href="#创建FamilyInstance对象" class="headerlink" title="创建FamilyInstance对象"></a>创建FamilyInstance对象</h3><p>通常，FamilyInstance对象是使用Autodesk.Revit.Creation.Document的12种重载方法之一NewFamilyInstance（）创建的。选择使用哪个重载不仅取决于实例的类别，还取决于放置的其他特征，例如是否应将其作为主体、相对于参照标高放置或直接放置在特定面上。详细信息包含在下面的表32 -使用NewFamilyInstance（）创建实例的选项中。</p>
<p>某些FamilyInstance对象需要创建多个位置。在这些情况下，使用此对象提供的更详细的创建方法更合适（请参见表33 -使用其他方法创建实例的选项）。如果未创建实例，则会引发异常。在调用该方法之前，必须将使用的类型&#x2F;符号加载到项目中。</p>
<p>检查NewFamilyInstance（）的所有重载以确保输入FamilySymbol处于活动状态（FamilySymbol.IsActive）。如果输入FamilySymbol处于非活动状态，则该方法将抛出ArgumentException。文档中未使用的符号可能会被停用，以节省内存和再生时间。当符号处于非活动状态时，其几何图形为空，无法访问。为了访问文档中未激活的符号的几何图形，应首先通过调用FamilySymbol.Activate（）来激活该符号。</p>
<p>表32 -使用NewFamilyInstance（）创建实例的选项</p>
<table>
<thead>
<tr>
<th align="left">Category 类别</th>
<th align="left">NewFamilyInstance() parameters NewFamilyInstance（）参数</th>
<th align="left">Comments注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Air Terminals Boundary Conditions Casework Communication Devices Data Devices Electrical Equipment Electrical Fixtures Entourage Fire Alarm Devices Furniture Furniture Systems Generic Models Lighting Devices Lighting Fixtures Mass Mechanical Equipment Nurse Call Devices Parking Planting Plumbing Fixtures Security Devices Site Specialty Equipment Sprinklers Structural Connections Structural Foundations Structural Stiffeners Telephone Devices</td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例，而不参照标高或宿主元素。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果要在墙壁、地板或天花板上承载</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为主体，并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为宿主并与参照标高关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果要将其关联到参考标高</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, XYZ, XYZ, FamilySymbol XYZ，</td>
<td align="left">如果它是基于面的并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, XYZ, XYZ, FamilySymbol</td>
<td align="left">如果它是基于面的，并且需要以非默认方向，则接受对面的引用，而不是对Face</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的，但接受对面的引用，而不是面</td>
</tr>
<tr>
<td align="left">Columns Structural Columns</td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">创建柱，使其底部位于参照标高上。柱将延伸到模型中的下一个可用标高，或者如果参照标高之上没有合适的标高，则将延伸默认柱高。</td>
</tr>
<tr>
<td align="left">Doors Windows</td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">门和窗必须以墙为宿主。如果可以使用默认方向放置它们，请使用此方法。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果创建的实例需要以非默认方向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果实例需要关联到参照标高</td>
</tr>
<tr>
<td align="left">Structural Framing (Beams, Braces)</td>
<td align="left">Curve, FamilySymbol, Level, StructuralType</td>
<td align="left">根据其曲线创建基于标高的支撑或梁。这是创建梁和支撑的推荐方法</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果它位于图元（地板等）上，并与参考标高相关联</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果它与参考标高相关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果它位于图元（地板等）上</td>
</tr>
<tr>
<td align="left">Detail Component</td>
<td align="left">Line, FamilySymbol, View</td>
<td align="left">仅限于基于二维族线的详图符号</td>
</tr>
<tr>
<td align="left">Generic Annotations</td>
<td align="left">XYZ, FamilySymbol, View</td>
<td align="left">仅显示为二维族符号</td>
</tr>
</tbody></table>
<p>结构实例在创建后长度为零。通过使用LocationCurve.Curve属性设置其曲线（FamilyInstance.Location为LocationCurve）来扩展它。</p>
<p>通过使用Document.NewFamilyList（）一次创建多个族实例，可以简化代码并提高性能。此方法有一个参数，该参数是描述要创建的族实例的FamilyInstanceCreationData对象的列表。</p>
<p>代码区域12-2：批量创建族实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ICollection <span class="title">BatchCreateColumns</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        List fiCreationDatas = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">        ICollection elementSet = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Try to get a FamilySymbol</span></span><br><span class="line">        FamilySymbol familySymbol = <span class="literal">null</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                familySymbol = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol.Category)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;Structural Columns&quot;</span> == familySymbol.Category.Name)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//Create 10 FamilyInstanceCreationData items for batch creation </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ location = <span class="keyword">new</span> XYZ(i * <span class="number">10</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">                        FamilyInstanceCreationData fiCreationData = <span class="keyword">new</span> FamilyInstanceCreationData(location, familySymbol, level, </span><br><span class="line">                                        StructuralType.Column);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> != fiCreationData)</span><br><span class="line">                        &#123;</span><br><span class="line">                                fiCreationDatas.Add(fiCreationData);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fiCreationDatas.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                        <span class="comment">// Create Columns</span></span><br><span class="line">            elementSet = document.Create.NewFamilyInstances2(fiCreationDatas);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Batch creation failed.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No column types found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些族类型的实例最好通过Autodesk.Revit.Creation.Document.NewFamilyInstance（）以外的方法创建。这些列于下表。</p>
<p>表33 -使用其他方法创建实例的选项</p>
<table>
<thead>
<tr>
<th><strong>Category 类别</strong></th>
<th><strong>Creation method 创建方法</strong></th>
<th><strong>Comments</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Air Terminal Tags Area Load Tags Area Tags Casework Tags Ceiling Tags Communication Device Tags Curtain Panel Tags Data Device Tags Detail Item Tags Door Tags Duct Accessory Tags Duct Fitting Tags Duct Tags Electrical Equipment Tags Electrical Fixture Tags Fire Alarm Device Tags Flex Duct Tags Flex Pipe Tags Floor Tags Furniture System Tags Furniture Tags Generic Model Tags Internal Area Load Tags Internal Line Load Tags Internal Point Load Tags Keynote Tags Lighting Device Tags Lighting Fixture Tags Line Load Tags Mass Floor Tags Mass Tags Mechanical Equipment Tags Nurse Call Device Tags Parking Tags Pipe Accessory Tags Pipe Fitting Tags Pipe Tags Planting Tags Plumbing Fixture Tags Point Load Tags Property Line Segment Tags Property Tags Railing Tags Revision Cloud Tags Roof Tags Room Tags Security Device Tags Site Tags Space Tags Specialty Equipment Tags Spinkler Tags Stair Tags Structural Area Reinforcement Tags Structural Beam System Tags Structural Column Tags Structural Connection Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Stiffener Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone Tags on Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode should be TM_ADDBY_CATEGORY and there should be a related tag loaded when try to create a tag，otherwise exception will be thrown（当尝试创建一个标记时，应该有一个相关的标签载入家庭）</td>
</tr>
<tr>
<td>Material Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MATERIAL，并且应加载材质标签族，否则将引发异常</td>
</tr>
<tr>
<td>Multi-Category Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MULTICATEGORY，并且应加载多类别标记族，否则将抛出异常</td>
</tr>
<tr>
<td>Title Blocks</td>
<td>ViewSheet.Create(Document, ElementId)</td>
<td>标题栏将添加到新创建的图纸中。</td>
</tr>
</tbody></table>
<p>使用Document.LoadFamily（）或Document.LoadFamilySymbol（）方法加载族和族符号。某些族（如梁）具有多个端点，插入方式与插入单个点实例的方式相同。插入线性族实例后，可以使用Element.Location属性更改其端点。有关详细信息，请参阅代码示例。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>用于使用Family Data的代码示例。</p>
<p>有关使用Family Object的详细信息，请查看以下代码示例。请注意，在NewFamilyInstance（）方法中，需要StructuralType参数来指定要创建的族实例的类型。以下是一些示例：</p>
<p>表34：NewFamilyInstance（）方法中StructuralType参数的值</p>
<table>
<thead>
<tr>
<th><strong>Type of Family Instance 族实例的类型</strong></th>
<th><strong>Value of StructuralType StructuralType的值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Doors, tables, etc. 门、桌子等</td>
<td>NonStructural 非结构</td>
</tr>
<tr>
<td>Beams 梁</td>
<td>Beam 梁</td>
</tr>
<tr>
<td>Braces 支撑</td>
<td>Brace 支撑</td>
</tr>
<tr>
<td>Columns 柱</td>
<td>Column 柱</td>
</tr>
<tr>
<td>Footings 基础</td>
<td>Footing 基础</td>
</tr>
</tbody></table>
<h3 id="创建桌"><a href="#创建桌" class="headerlink" title="创建桌"></a>创建桌</h3><p>以下函数演示了如何将表族加载到Revit项目中，以及如何从该族中的所有符号创建实例。</p>
<p>如果指定的族以前已加载，则LoadFamily（）方法返回false。因此，在以下情况下，在调用此函数之前，不加载族Table-Dining Round w Chairs.rfa。在本例中，默认情况下，桌是在标高1创建的。</p>
<p>代码区域12-3：创建桌</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTables</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    String fileName = <span class="string">@&quot;C:\ProgramData\Autodesk\RVT 2014\Libraries\US Imperial\Furniture\Tables\Table-Dining Round w Chairs.rfa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to load family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!document.LoadFamily(fileName, <span class="keyword">out</span> family))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to load &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through table symbols and add a new table for each</span></span><br><span class="line">    ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载桌族并放置每个FamilySymbol的一个实例的结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5FE17FC0-A248-47AE-A08A-1BBA3156193B-low.png"></p>
<p>图47：在Revit项目中加载族并创建表格 </p>
<h3 id="创建Beam"><a href="#创建Beam" class="headerlink" title="创建Beam"></a>创建Beam</h3><p> 在此示例中，加载的是族符号而不是族，因为加载单个FamilySymbol比加载包含许多FamilySymbol的族要快。</p>
<p>代码区域12-4：创建梁</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FamilyInstance <span class="title">CreateBeam</span>(<span class="params">Autodesk.Revit.DB.Document document, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the given view&#x27;s level for beam creation</span></span><br><span class="line">    Level level = document.GetElement(view.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a family symbol</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).OfCategory(BuiltInCategory.OST_StructuralFraming);</span><br><span class="line"></span><br><span class="line">    FamilySymbol gotSymbol = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new beam 10&#x27; long starting at origin</span></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.Curve beamLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new beam</span></span><br><span class="line">    FamilyInstance instance = document.Create.NewFamilyInstance(beamLine, gotSymbol,</span><br><span class="line">                                                                level, StructuralType.Beam);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建门"><a href="#创建门" class="headerlink" title="创建门"></a>创建门</h3><p>创建一个长约180’的长墙，并在运行此示例之前选择它。宿主对象必须支持插入实例;否则NewFamilyInstance（）方法将失败。如果没有为必须在宿主中创建的实例提供宿主元素，或者无法将实例插入到指定的宿主元素中，则方法NewFamilyInstance（）不执行任何操作。</p>
<p>代码区域12-5：创建门</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDoorsInWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get wall&#x27;s level for door creation</span></span><br><span class="line">    Level level = document.GetElement(wall.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol))</span><br><span class="line">                                                .OfCategory(BuiltInCategory.OST_Doors)</span><br><span class="line">                                                .ToElements();</span><br><span class="line">    IEnumerator symbolItor = collection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, z);</span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, wall, level, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        y += <span class="number">10</span>;</span><br><span class="line">        z += <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图显示了在Revit中执行上述代码的结果。请注意，如果指定的位置不在指定的标高上，NewFamilyInstance（）方法将使用位置标高而不是标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3175405A-CD58-4A39-8DC8-696E76652DBB-low.png"></p>
<p>图48：将门插入墙壁</p>
<h3 id="使用参考方向创建族实例"><a href="#使用参考方向创建族实例" class="headerlink" title="使用参考方向创建族实例"></a>使用参考方向创建族实例</h3><p>使用参照方向可在特定方向上插入项目。</p>
<p>代码区域12-6：使用参考方向创建族实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a floor to place the beds</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Floor floor = collector.OfClass(<span class="keyword">typeof</span>(Floor)).FirstElement() <span class="keyword">as</span> Floor;</span><br><span class="line"><span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a Bed-Box family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    FilteredElementCollector famCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    famCollector.OfClass(<span class="keyword">typeof</span>(Family));</span><br><span class="line">    ICollection collection = famCollector.ToElements();</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element.Name.CompareTo(<span class="string">&quot;双人床 - 箱式&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            family = element <span class="keyword">as</span> Family;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Enumerate the beds in the Bed-Box family</span></span><br><span class="line">        FilteredElementCollector fsCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection fsCollection = fsCollector.WherePasses(<span class="keyword">new</span> FamilySymbolFilter(family.Id)).ToElements();</span><br><span class="line">        IEnumerator symbolItor = fsCollection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            symbol.Activate();</span><br><span class="line">            XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">0</span>);</span><br><span class="line">            XYZ direction = <span class="keyword">new</span> XYZ();</span><br><span class="line">            <span class="keyword">switch</span> (i % <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, direction, floor, StructuralType.NonStructural);</span><br><span class="line">            x += <span class="number">10</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一个代码的结果显示在下图中：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-86B0A1C3-988D-4C4B-BA8E-3C8C9BDEAAE0-low.png"></p>
<p>图49：使用不同的参照方向创建族实例</p>
<h2 id="族符号"><a href="#族符号" class="headerlink" title="族符号"></a>族符号</h2><p>FamilySymbol类表示族中的单个类型。</p>
<p>每个族可以包含一个或多个族符号。每个FamilyInstance都有一个关联的FamilySymbol，可以从其Symbol属性访问。</p>
<h3 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h3><p>某些类型的族（门、窗和幕墙嵌板）包含下面窗的“类型属性”窗口中所示的热属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/FamilyThermalProperties2-76173.jpg"></p>
<p>FamilySymbol的热属性由FamilyThermalProperties类表示，并使用FamilySymbol.GetThermalProperties（）方法检索。可以使用SetThermalProperties（）设置FamilySymbol的FamilyThermalProperties。FamilyThermalProperties类本身的属性是只读的。</p>
<p>计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 传热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
</tbody></table>
<p>AnalyticConstructionTypeId属性是构造gbXML类型，并返回与Constructions.xml中constructionType节点的“id”属性对应的值。静态FamilyThermalProperties.Find（）方法将通过Constructions.xml中constructionType节点的“id”属性查找FamilyThermalProperties。</p>
<p> #FamilyType参数 </p>
<p>FamilySymbol的某些参数可以是FamilyType参数。对于这些参数，可以使用Family.GetFamilyTypeParameterValues（）方法获取参数的所有适用值。返回的值是与给定参数的定义所指定的类别相匹配的所有族类型的ElementId。这些元素属于类ElementType或NestedFamilyTypeReference。第二种变体适用于嵌套在族中的类型，因此无法以其他方式访问。NestedFamilyTypeReference元素仅存储有关嵌套FamilyType的基本信息，例如Type的名称、Family的名称和Category。这些元素非常低级，因此被标准元素过滤器绕过，因此获取它们的主要方法是通过Family.GetFamilyTypeParameterValues（）方法。 以下示例演示如何获取FamilySymbol的FamilyType参数的所有族类型参数值。然后将参数的值更改为另一个值。此更改将影响使用加载的FamilySymbol的所有FamilySymbol。</p>
<p>代码区域：获取嵌套的FamilyTypes</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNestedFamilyTypes</span>(<span class="params">FamilyInstance instance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find one FamilyType parameter and all values applicable to it</span></span><br><span class="line"></span><br><span class="line">    Parameter aTypeParam = <span class="literal">null</span>;</span><br><span class="line">    ISet values = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Family family = instance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter param <span class="keyword">in</span> instance.Symbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (param.Definition.ParameterType == ParameterType.FamilyType)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            aTypeParam = param;</span><br><span class="line"></span><br><span class="line">            values = family.GetFamilyTypeParameterValues(param.Id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aTypeParam == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;The selected family has no FamilyType parameter defined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (values == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;A FamilyType parameter does not have any applicable values!?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId newValue = values.Last();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newValue != aTypeParam.AsElementId())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(instance.Document, <span class="string">&quot;Setting parameter value&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                trans.Start();</span><br><span class="line">                aTypeParam.Set(newValue);</span><br><span class="line">                trans.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="族"><a href="#族" class="headerlink" title="族"></a>族</h2><p>“族”类表示整个Revit族。它包含FamilySymbols使用的FamilySymbols。</p>
<h3 id="载入族"><a href="#载入族" class="headerlink" title="载入族"></a>载入族</h3><p>Document类包含LoadFamily（）和LoadFamilySymbol（）方法。</p>
<ul>
<li>LoadFamily（）将整个族及其所有类型或符号加载到项目中。</li>
<li>LoadFamilySymbol（）仅将指定的族符号从族文件载入到项目中。</li>
</ul>
<p><strong>注意：</strong>要提高应用程序的性能并减少内存使用，请尽可能加载特定的FamilySymbol，而不是整个Family对象。</p>
<ul>
<li>使用Options.Application对象GetLibraryPaths（）方法检索族文件路径。</li>
<li>Options.Application对象是使用Application对象的Options属性检索的。</li>
<li>在LoadFamilySymbol（）中，输入参数Name与FamilySymbol对象Name属性返回的字符串值相同。</li>
</ul>
<p>有关详细信息，请参阅代码示例。</p>
<p>类别</p>
<p>FamilyCategory属性指示族的类别，例如柱、家具、结构框架或窗。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/13%E6%97%8F%E5%AE%9E%E4%BE%8B/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">2</span>
    
    <a class="page-num" href="/page/3">
        3
    </a>
    
    
    <a class="page-num" href="/page/4">
        4
    </a>
    
    
    
    <a class="page-num" href="/page/3/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">XH</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 funtim
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;XH
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
