
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>funtim</title>
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>FUNTIM</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;FUNTIM</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>funtim</h1>
                <h3>hello</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/12/28/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="墙、楼板、天花板、屋顶和洞口"><a href="#墙、楼板、天花板、屋顶和洞口" class="headerlink" title="墙、楼板、天花板、屋顶和洞口"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Walls_Floors_Ceilings_Roofs_and_Openings_html">墙、楼板、天花板、屋顶和洞口</a></h1><p>元素和表示内置位置构造的相应ElementType。</p>
<p>以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。</p>
<p>本节中的页面</p>
<ul>
<li>墙</li>
<li>楼板、天花板和基础</li>
<li>屋顶</li>
<li>幕墙</li>
<li>其他元素</li>
<li>复合结构</li>
<li>洞口</li>
<li>热属性</li>
</ul>
<h2 id="墙"><a href="#墙" class="headerlink" title="墙"></a>墙</h2><p>WallType.Kind枚举表示四种墙：</p>
<ul>
<li>Stacked 叠层墙</li>
<li>Curtain 幕墙</li>
<li>Basic 基本</li>
<li>Unknown 未知</li>
</ul>
<p>Wall和WallType类与基本墙类型一起使用，同时为叠层墙和幕墙提供有限的功能。有时您需要检查墙以确定墙类型。例如，不能使用API从叠层墙获取子墙。WallKind是只读的，由系统系列设置。</p>
<p>Wall.Flipped属性和Wall.flip（）方法可以访问和控制墙的方向。在下面的示例中，将在调用flip（）方法之前和之后比较Wall。</p>
<ul>
<li>之前的Orientation属性为（0.0，1.0，0.0）。</li>
<li>翻转调用后的Orientation属性为（0.0，-1.0，0.0）。</li>
<li>“墙定位线（WALL_KEY_REF_PARAM）”参数为3，表示下表中的“饰面：内部”。</li>
<li>以该线为参照，墙将被移动，但“位置”不会更改。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4BFD801E-18BC-4021-8371-C29AF13CF7EE-low.png"></p>
<p><strong>图33：原始墙</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-85CF3DAD-C029-41C5-ACC6-1FEC8CA304E4-low.png"></p>
<p><strong>图34：翻转后的墙</strong></p>
<p><strong>表24：墙位置线</strong></p>
<table>
<thead>
<tr>
<th><strong>Location Line Value 定位线值</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>墙中心线</td>
</tr>
<tr>
<td>1</td>
<td>核心层中心线</td>
</tr>
<tr>
<td>2</td>
<td>表面：外部</td>
</tr>
<tr>
<td>3</td>
<td>表面：内部</td>
</tr>
<tr>
<td>4</td>
<td>核心面：外部</td>
</tr>
<tr>
<td>5</td>
<td>核心面：内部</td>
</tr>
</tbody></table>
<p>Wall类中有五个静态覆盖方法可用于创建Wall：</p>
<p>表25：Create（）重载</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, Curve, WallType, Level, Double, Double, Boolean, Boolean)</td>
<td>使用指定的墙类型、高度和偏移在项目中创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , Boolean)</td>
<td>使用默认墙样式在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, Curve, ElementId, Boolean)</td>
<td>使用默认墙样式在项目中由ElementId指定的标高上创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean)</td>
<td>使用指定的墙类型在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean, XYZ)</td>
<td>使用指定的墙类型和法向量在项目中创建非矩形轮廓墙。</td>
</tr>
</tbody></table>
<p>WallType墙功能（WALL_ATTR_EXTERIOR）参数会影响创建的墙实例“房间边界和结构用途”参数。WALL_ATTR_EXTERIOR值是一个整数：</p>
<p><strong>表26：墙功能</strong></p>
<table>
<thead>
<tr>
<th><strong>Wall Function 墙功能</strong></th>
<th><strong>Interior 内部</strong></th>
<th><strong>Exterior 外部</strong></th>
<th><strong>Foundation 基础墙</strong></th>
<th><strong>Retaining 挡土墙</strong></th>
<th><strong>Soffit 檐底板</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Value 值</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>以下规则适用于由API创建的墙：</p>
<ul>
<li>如果输入结构参数为true或Wall Function（WALL_ATTR_EXTERIOR）参数为Foundation，则Wall StructuralUsage参数为Bearing;否则为NonBearing。</li>
<li>如果墙功能（WALL_ATTR_EXTERIOR）参数为“Retaining”，则创建的墙房间边界（WALL_ATTR_ROOM_BOUNDING）参数为false。</li>
</ul>
<p>有关与结构相关的函数（如AnalyticalModel属性）的详细信息，请参见结构工程。</p>
<h2 id="楼板、天花板和基础"><a href="#楼板、天花板和基础" class="headerlink" title="楼板、天花板和基础"></a>楼板、天花板和基础</h2><p>与楼板、天花板和基础关联的类。</p>
<p>楼板、天花板和基础相关的API项目包括：</p>
<p>表28：API中的地板、天花板和基础</p>
<table>
<thead>
<tr>
<th><strong>Object 对象</strong></th>
<th><strong>Element Type 元素类型</strong></th>
<th><strong>ElementType Type ElementType类型</strong></th>
<th><strong>Element Creation 元素创建</strong></th>
<th><strong>Other 其他</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Floor</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()&#x2F;NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Ceiling</td>
<td>Ceiling</td>
<td>CeilingType</td>
<td>No</td>
<td>Category &#x3D; OST_Ceilings</td>
</tr>
<tr>
<td>Wall Foundation</td>
<td>WallFoundation</td>
<td>WallFoundationType</td>
<td>No</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Isolated Foundation</td>
<td>FamilyInstance</td>
<td>FamilySymbol</td>
<td>NewFamilyInstance()</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Foundation Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()</td>
<td>Category &#x3D; OST_StructuralFoundation FloorType.IsFoundationSlab &#x3D; true</td>
</tr>
</tbody></table>
<p>注意：Floor和Ceiling派生自CeilingAndFloor类。以下规则适用于Floor：</p>
<ul>
<li>从基础设计栏创建的元素具有相同的类别OST_StructuralFoundation，但对应于不同的类。</li>
<li>FloorType IsFoundationSlab属性将FloorType类别设置为OST_StructuralFoundation或不设置。</li>
</ul>
<p>检索FloorType以使用NewFloor创建楼板或基础底板时，请使用以下方法：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-26C2760B-04F0-4690-AF22-6EB1A0CDD933-low.png"></p>
<p>图35：创建基础和楼板</p>
<p>当前，API不提供对Floor类中的地板坡度箭头的访问。但是，在使用Revit的结构功能时，可以使用NewSlab（）创建斜板：</p>
<p>代码区域11-1：NewSlab（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Floor <span class="title">NewSlab</span>(<span class="params">CurveArray profile, Level level, Line slopedArrow, <span class="built_in">double</span> slope,<span class="built_in">bool</span> isStructural</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用slopedArrow参数创建坡度箭头。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5589AB8C-03FB-4FE6-BB20-065A37058854-low.png"></p>
<p>图36：NewSlab中的slopedArrow参数</p>
<p>NewSlab（）中斜率参数的单位是rise&#x2F;run。</p>
<p>Floor.FloorType属性是使用Floor.GetTypeId（）方法的替代方法。有关与结构相关的成员（如GetSpanDirectionSymbolIds（）方法和SpanDirectionAngle属性）的详细信息，请参见结构工程部分。</p>
<p>在Revit中编辑独立基础时，可以执行以下操作：</p>
<ul>
<li>您可以选取宿主，例如楼板。但是，FamilyInstance对象Host属性始终返回null。</li>
<li>删除宿主楼板时，基础不会随之删除。</li>
<li>Foundation 宿主可通过Host（MANANCE_FREE_HOST_PARAM）参数访问。</li>
<li>使用另一个相关的“偏移”（Offset_FREE_HOST_OFFSET_PARAM）参数控制宿主元素的基础偏移。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FECE5EE-DCFE-42E5-B3F8-868B44E774D5-low.png"></p>
<p>图37：为FoundationSlab（FamilyInstance）选择宿主</p>
<p>条形基础由API中的WallFoundation类表示。API提供对WallFoundation和WallFoundationType的有限访问，但使用GetAnalyticalModel（）方法时除外（请参阅“结构工程”部分中的分析模型）。例如，附着的墙不能用于Revit的建筑功能。使用Revit的结构功能，可以使用AnalyticalModel类中的GetAnalyticalModelSupports（）方法显示Wall类和WallFoundation类之间的关系。有关详细信息，请参见“结构工程”部分中的分析模型。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-03EA5485-1F1B-429D-8917-02B86A50E627-low.png"></p>
<h3 id="修改板"><a href="#修改板" class="headerlink" title="修改板"></a>修改板</h3><p>您可以使用SlabShapeEditor类修改基于板的元素的形式。此类允许您：</p>
<ul>
<li>操作选定的基于板的元素上的一个或多个点或边</li>
<li>在元素上添加点以更改元素的几何图形</li>
<li>添加线性边并将板的现有面拆分为更小的子面域</li>
<li>删除形状修改器并将图元几何图形重置回未修改的形状。</li>
</ul>
<p>下面是将选定的已修改地板恢复为其原始形状的示例：</p>
<p>代码区域11-2：恢复板的形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetSlabShapes</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        Selection choices = uidoc.Selection;</span><br><span class="line">        ElementSet collection = choices.Elements;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Floor floor = elem <span class="keyword">as</span> Floor;</span><br><span class="line">                <span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        SlabShapeEditor slabShapeEditor = floor.SlabShapeEditor;</span><br><span class="line">                        slabShapeEditor.ResetSlabShape();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关使用SlabShapeEditor和相关类的详细示例，请参见Revit SDK中包含的SlabShapeEditing示例应用程序。</p>
<h2 id="屋顶"><a href="#屋顶" class="headerlink" title="屋顶"></a>屋顶</h2><p>Revit API中屋顶的表示。</p>
<p>Revit Platform API中的屋顶均派生自RoofBase对象。有两个类：</p>
<ul>
<li>FootPrintRoof -表示由建筑物迹线区构成的屋顶</li>
<li>ExtrusionRoof -表示由拉伸轮廓制成的屋顶</li>
</ul>
<p>两者都有一个RoofType属性，用于获取或设置屋顶的类型。此示例说明如何基于某些选定的墙创建迹线屋顶：</p>
<p>代码区域11-3：创建迹线屋顶</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before invoking this sample, select some walls to add a roof over.</span></span><br><span class="line"><span class="comment">// Make sure there is a level named &quot;Roof&quot; in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the Roof level</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Level));</span><br><span class="line"><span class="keyword">var</span> elements = <span class="keyword">from</span> element <span class="keyword">in</span> collector <span class="keyword">where</span> element.Name == <span class="string">&quot;Roof&quot;</span> <span class="keyword">select</span> element;</span><br><span class="line">Level level = elements.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(RoofType));</span><br><span class="line">RoofType roofType = collector.FirstElement() <span class="keyword">as</span> RoofType; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the handle of the application</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the footprint for the roof based on user selection</span></span><br><span class="line">CurveArray footprint = application.Create.NewCurveArray();</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        Wall wall = element <span class="keyword">as</span> Wall;</span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LocationCurve wallCurve = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">            footprint.Append(wallCurve.Curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModelCurve modelCurve = element <span class="keyword">as</span> ModelCurve;</span><br><span class="line">        <span class="keyword">if</span> (modelCurve != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            footprint.Append(modelCurve.GeometryCurve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You should select a curve loop, or a wall loop, or loops combination \nof walls and curves to create a footprint roof.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModelCurveArray footPrintToModelCurveMapping = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line">FootPrintRoof footprintRoof = document.Create.NewFootPrintRoof(footprint, level, roofType, <span class="keyword">out</span> footPrintToModelCurveMapping);</span><br><span class="line">ModelCurveArrayIterator iterator = footPrintToModelCurveMapping.ForwardIterator();</span><br><span class="line">iterator.Reset();</span><br><span class="line"><span class="keyword">while</span> (iterator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    ModelCurve modelCurve = iterator.Current <span class="keyword">as</span> ModelCurve;</span><br><span class="line">    footprintRoof.set_DefinesSlope(modelCurve, <span class="literal">true</span>);</span><br><span class="line">    footprintRoof.set_SlopeAngle(modelCurve, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关如何创建ExtrusionRoof的示例，请参见Revit API SDK附带的NewRoof示例应用程序。</p>
<p>天沟、筋膜檐沟和封檐带图元派生自表示屋顶的HostedSweep类。可以通过API创建、删除或修改它们。若要创建这些元素，请使用Document.Create.NewFascia（）或Document.Create.NewGutter（）重写之一。有关如何创建新檐沟和封檐带的示例，请参见SDK示例中包含的NewHostedSweep应用程序。下面是一个代码片段，显示了您可以修改gutter元素的属性。</p>
<p>代码区域11-4：修改天沟</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ModifyGutter</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ElementSet collection = uidoc.Selection.Elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem <span class="keyword">is</span> Gutter)</span><br><span class="line">                &#123;</span><br><span class="line">                        Gutter gutter = elem <span class="keyword">as</span> Gutter;</span><br><span class="line">                        <span class="comment">// convert degrees to rads:</span></span><br><span class="line">                        gutter.Angle = <span class="number">45.00</span> * Math.PI / <span class="number">180</span>;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Changed gutter angle&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幕墙"><a href="#幕墙" class="headerlink" title="幕墙"></a>幕墙</h2><p>幕墙、幕墙系统和幕墙屋顶是CurtainGrid对象的主体图元。幕墙只能有一个CurtainGrid，而幕墙系统和幕墙屋顶可以包含一个或多个CurtainGrid。有关如何创建CurtainSystem的示例，请参见Revit SDK附带的CurtainSystem示例应用程序。有关创建幕墙并使用网格线填充幕墙的示例，请参见CurtainWallGrid示例应用程序。</p>
<h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><p>有些元素不是HostObject（也没有特定的类），但它们是可以承载其他对象的特殊情况。例如，ramp及其关联的元素类型在API中没有特定的类，而是在OST_Ramp类别中表示为Element和ElementType。</p>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>描述墙、楼板、屋顶或天花板的内部结构。</p>
<p>墙、楼板、天花板和屋顶都是API类HostObject的子对象。HostObject（及其相关类型类HostObjAttributes）提供对CompoundStructure的只读访问。复合结构由有序层的集合组成，对于墙来说，从外部到内部，或者对于地板，屋顶或天花板来说，从顶部到底部。这些层的属性决定了相关墙、楼板、屋顶或天花板的整体结构的厚度、材质和功能。</p>
<p>层可以通过GetLayers（）方法访问，并使用SetLayers（）完全替换。</p>
<p>通常，这些层是平行的，并以固定的层宽度延伸整个主体对象。然而，对于墙，结构也可以是“垂直复合”的，其中层在距墙的顶部和底部的指定垂直距离处变化。使用CompoundStructure.IsVerticallyCompound来标识它们。对于垂直复合结构，该结构通过矩形描述垂直截面，该矩形被划分为多边形区域，多边形区域的边都是垂直或水平段。映射将这些区域中的每一个与CompoundStructure中的层的索引相关联，该层的索引确定该区域的属性。</p>
<p>可以使用复合结构来找到不同层边界的几何位置。方法CompoundStructure.GetOffsetForLocationLine（）提供从中心定位线到任何定位线选项（芯体中心线、任一侧的饰面面或芯体侧）的偏移。</p>
<p>有了到定位线的偏移，您可以从已知位置开始，使用CompoundStructure.GetLayerWidth（）获取每个边界层的宽度，从而获取每个层边界的位置。</p>
<p>使用CompoundStructure的一些注意事项：</p>
<ul>
<li>元素的总宽度是每个CompoundStructureLayer的宽度之和。您无法直接更改元素的总宽度，但可以通过更改CompoundStructureLayer宽度来更改它。指定的可变长度层的索引（如果已分配）可以从CompoundStructure.VariableLayerIndex获得。</li>
<li>必须将CompoundStructure设置回HostObjAttributes实例（使用HostObjAttributes.SetCompoundStructure（）方法），以便存储任何更改。</li>
<li>对HostObjAttributes的更改会影响当前文档中的每个实例。如果需要新的层组合，则需要创建新的HostObjAttributes（使用ElementType.Duplicate（））并将新的CompoundStructure分配给它。</li>
<li>CompoundStructureLayer DeckProfileId和DeckEmbeddingType属性仅适用于Revit结构要素中的Slab。有关详细信息，请参阅结构工程。</li>
</ul>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>HostObjAttributes中的每个CompoundStructureLayer通常与某种类型的材质一起显示。如果CompoundStructureLayer.MaterialId返回-1，则表示该Material与Category相关。有关详细信息，请参阅材料。获取CompoundStructureLayer材质的示例代码如下：</p>
<p>代码区域11-5：获取CompoundStructureLayer材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetWallLayerMaterial</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get WallType of wall</span></span><br><span class="line">        WallType aWallType = wall.WallType;</span><br><span class="line">        <span class="comment">// Only Basic Wall has compoundStructure</span></span><br><span class="line">        <span class="keyword">if</span> (WallKind.Basic == aWallType.Kind)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get CompoundStructure</span></span><br><span class="line">                CompoundStructure comStruct = aWallType.GetCompoundStructure();</span><br><span class="line">                Categories allCategories = document.Settings.Categories;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the category OST_Walls default Material; </span></span><br><span class="line">                <span class="comment">// use if that layer&#x27;s default Material is </span></span><br><span class="line">                Category wallCategory = allCategories.get_Item(BuiltInCategory.OST_Walls);</span><br><span class="line">                Autodesk.Revit.DB.Material wallMaterial = wallCategory.Material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (CompoundStructureLayer structLayer <span class="keyword">in</span> comStruct.GetLayers())</span><br><span class="line">                &#123;</span><br><span class="line">                        Autodesk.Revit.DB.Material layerMaterial = </span><br><span class="line">                                document.GetElement(structLayer.MaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If CompoundStructureLayer&#x27;s Material is specified, use default</span></span><br><span class="line">                        <span class="comment">// Material of its Category</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">switch</span> (structLayer.Function)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish1:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish1).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish2:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish2).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Membrane:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsMembrane).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Structure:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsStructure).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Substrate:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsSubstrate).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Insulation:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsInsulation).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="literal">default</span>:</span><br><span class="line">                                                <span class="comment">// It is impossible to reach here</span></span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">// CompoundStructureLayer&#x27;s default Material is its SubCategory</span></span><br><span class="line">                                        layerMaterial = wallMaterial;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Layer Material: &quot;</span> + layerMaterial);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时只需要“结构”层的材料。与其在每个层中查找其函数为MaterialFunctionAssignment.Structure的层，不如使用CompoundStructure.StructuralMaterialIndex属性查找其材料定义了类型的结构属性的层的索引，以便进行分析。<br>注意：调用SetLayers（）时，StructuralMaterialIndex值将被清除，需要重置。</p>
<h2 id="洞口"><a href="#洞口" class="headerlink" title="洞口"></a>洞口</h2><p>在Revit Platform API中，Opening对象派生自Element对象，并包含所有Element对象属性和方法。若要检索项目中的所有Openings，请使用Document.ElementIterator查找Elements.Opening对象。</p>
<h3 id="常规属性"><a href="#常规属性" class="headerlink" title="常规属性"></a>常规属性</h3><p>本节说明如何使用洞口属性。</p>
<ul>
<li><p>Isolation Boundary-确定洞口是否具有矩形边界。</p>
<ul>
<li>如果为true，则表示Opening具有矩形边界，并且可以从Opening BoundaryRect属性获取IList集合。否则，属性返回null。</li>
<li>如果为false，则可以从BoundaryCurves属性获取CurveArray对象。</li>
</ul>
</li>
<li><p>BoundaryCurves -如果开口边界不是矩形，则此属性检索几何信息;否则返回null。该属性返回一个CurveArray对象，其中包含表示Opening对象边界的曲线。有关曲线的更多详细信息，请参阅几何体。</p>
</li>
<li><p>BoundaryRect -如果开口边界是矩形，则可以使用此属性获取几何信息;否则返回null。</p>
<ul>
<li>该属性返回一个包含XYZ坐标的IList集合。</li>
<li>IList集合通常包含矩形边界的最小（左下）和最大（右上）坐标。</li>
</ul>
</li>
<li><p>Host -host属性检索Opening host元素。主体图元是由Opening对象剪切的图元。</p>
<p><strong>注意：</strong>如果洞口对象的类别为竖井洞口，则洞口主体为空。</p>
</li>
</ul>
<p>下面的示例说明如何检索现有的Opening属性。</p>
<p>代码区域11-6：检索现有洞口属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Opening</span>(<span class="params">Opening opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Opening:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the host element of this opening</span></span><br><span class="line">    message += <span class="string">&quot;\nThe id of the opening&#x27;s host element is : &quot;</span> + opening.Host.Id.IntegerValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the information whether the opening has a rect boundary</span></span><br><span class="line">    <span class="comment">//If the opening has a rect boundary, we can get the geometry information from BoundaryRect property.</span></span><br><span class="line">    <span class="comment">//Otherwise we should get the geometry information from BoundaryCurves property</span></span><br><span class="line">    <span class="keyword">if</span> (opening.IsRectBoundary)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening has a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">//array contains two XYZ objects: the max and min coords of boundary</span></span><br><span class="line">        IList boundaryRect = opening.BoundaryRect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the min coordinate point</span></span><br><span class="line">        XYZ point = opening.BoundaryRect[<span class="number">0</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMin coordinate point:(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the Max coordinate point</span></span><br><span class="line">        point = opening.BoundaryRect[<span class="number">1</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMax coordinate point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening doesn&#x27;t have a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve number</span></span><br><span class="line">        <span class="built_in">int</span> curves = opening.BoundaryCurves.Size;</span><br><span class="line">        message += <span class="string">&quot;\nNumber of curves is : &quot;</span> + curves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; curves; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.Curve curve = opening.BoundaryCurves.get_Item(i);</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nCurve start point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;; Curve end point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建洞口"><a href="#创建洞口" class="headerlink" title="创建洞口"></a>创建洞口</h3><p>在Revit Platform API中，使用Document.NewOpening（）方法在项目中创建洞口。有四种方法重载可用于在不同的宿主元素中创建洞口：</p>
<p>代码区域11-7：NewOpening（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a beam, brace and column. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element famInstElement, CurveArray profile, eRefFace iFace</span>)</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a roof, floor and ceiling. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element hostElement, CurveArray profile, <span class="built_in">bool</span> bPerpendicularFace</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening Element. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Level bottomLevel, Level topLevel, CurveArray  profile</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create an opening in a straight wall or arc wall. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Wall, XYZ pntStart, XYZ pntEnd</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在梁、支撑或柱中创建洞口-用于在族实例中创建洞口。iFace参数指示放置洞口的面。</li>
<li>创建屋顶、楼板或天花板洞口-用于在屋顶、楼板或天花板中创建洞口。</li>
<li>bPerceptiularFace参数指示洞口是垂直于面还是垂直于面。</li>
<li>如果该参数为true，则洞口垂直于主体图元面。请参见下图：</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EED350DF-2DD4-4562-998D-C020C739D6F8-low.png"></p>
<p>图40：垂直于主体元素切割的开口</p>
<ul>
<li>创建新洞口图元-用于在项目中创建竖井洞口。但是，请确保topLevel高于bottomLevel;否则将引发异常。</li>
<li>在直墙或弧形墙中创建洞口-用于在墙中创建矩形洞口。pntStart和pntEnd的坐标应该是可以塑造矩形的角坐标。例如，矩形的左下角和右上角。否则会引发异常。</li>
</ul>
<p>注意：使用“洞口”命令只能创建矩形墙洞口。要在墙上创建一些孔，请编辑墙轮廓而不是“洞口”命令。</p>
<h2 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h2><p>某些部件类型（如墙、楼板、天花板、屋顶和建筑地坪）具有计算和可设置的热属性，这些热属性由ThermalProperties类表示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ThermalProperties-76171.jpg"></p>
<p>hermalProperties类具有上面显示的值的属性。吸收率和粗糙度是可修改的，而传热系数、热阻和热质量是只读的。这些计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 导热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
<tr>
<td>ThermalMass 热质量</td>
<td>kilogram feet-squared per second squared kelvin (kg ft^2&#x2F;(s^2 K))</td>
</tr>
</tbody></table>
<p>可以使用以下类型的ThermalProperties属性检索热属性：</p>
<ul>
<li>WallType </li>
<li>FloorType</li>
<li>CeilingType </li>
<li>RoofType </li>
<li>BuildingPadType</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/11%E4%BA%8B%E5%8A%A1/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Transactions_html">事务</a></h1><p>事务是类似于上下文的对象，可封装对Revit模型所做的任何更改。只有在存在打开的活动事务处理时，才能对文档进行任何更改。尝试在事务之外更改文档将引发异常。在提交活动事务之前，更改不会成为模型的一部分。因此，事务中的所有更改都可以显式或隐式回滚（通过析构函数）。在任何给定时间，每个文档只能打开一个事务。一个事务可以由一个或多个操作组成。</p>
<p>Revit API中有三个与事务相关的主要类：</p>
<ul>
<li>Transaction 事务</li>
<li>SubTransaction 子事务</li>
<li>TransactionGroup 事务组</li>
</ul>
<p>本节将更深入地讨论这些类中的每一个类。对文档进行更改时只需要Transaction类。其他类可用于更好地组织更改。</p>
<p>***注意:***如果事务是从外部线程或外部非模态对话框启动的，则会引发异常。事务只能从支持的API工作流启动，例如外部命令、事件、更新程序或回调的一部分。</p>
<p><strong>本节中的页面</strong></p>
<ul>
<li>Transaction Classes 事务类</li>
<li>Transactions in Events 事件中的事务</li>
<li>Failure Handling Options 故障处理选项</li>
<li>Getting Element Geometry and AnalyticalModel<br>获取元素几何图形和分析模型</li>
<li>Temporary transactions 临时事务</li>
</ul>
<h2 id="Transaction-Classes-事务类"><a href="#Transaction-Classes-事务类" class="headerlink" title="Transaction Classes 事务类"></a>Transaction Classes 事务类</h2><p>三个事务对象共享通用方法：</p>
<p>表51：通用事务对象方法</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Start</td>
<td>将启动上下文</td>
</tr>
<tr>
<td>Commit</td>
<td>结束上下文并将所有更改提交到文档</td>
</tr>
<tr>
<td>Rollback</td>
<td>结束上下文并放弃对文档的所有更改</td>
</tr>
<tr>
<td>GetStatus</td>
<td>返回事务对象的当前状态</td>
</tr>
</tbody></table>
<p>除了返回当前状态的GetStatus（）方法外，Start、Commit和RollBack方法还返回TransactionStatus，指示该方法是否成功。可用的TransactionStatus值包括：</p>
<p>表52：TransactionStatus值</p>
<table>
<thead>
<tr>
<th><strong>Status 状态</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Uninitialized</td>
<td>对象实例化后的初始值;上下文尚未启动</td>
</tr>
<tr>
<td>Started</td>
<td>事务对象已成功启动（调用了Start）</td>
</tr>
<tr>
<td>RolledBack</td>
<td>事务对象已成功回滚（调用了Rollback）</td>
</tr>
<tr>
<td>Committed</td>
<td>已成功提交事务对象（调用了Commit）</td>
</tr>
<tr>
<td>Pending</td>
<td>试图提交或回滚事务对象，但由于失败，该过程尚未完成，正在等待最终用户的响应（在非模态对话框中）。一旦故障处理完成，状态将自动更新（为Committed或RolledBack状态）。</td>
</tr>
</tbody></table>
<h3 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h3><p>事务是对Revit模型进行任何更改所需的上下文。一次只能打开一个事务;不允许嵌套。每个事务都必须有一个名称，一旦事务成功提交，该名称将列在Revit的“撤消”菜单中。</p>
<p>代码区域23-1：使用事务</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatingSketch</span>(<span class="params">UIApplication uiApplication</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = uiApplication.Application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few geometry lines. These lines are transaction (not in the model),</span></span><br><span class="line">    <span class="comment">// therefore they do not need to be created inside a document transaction.</span></span><br><span class="line">    XYZ Point1 = XYZ.Zero;</span><br><span class="line">    XYZ Point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point3 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point4 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Line geomLine1 = Line.CreateBound(Point1, Point2);</span><br><span class="line">    Line geomLine2 = Line.CreateBound(Point4, Point3);</span><br><span class="line">    Line geomLine3 = Line.CreateBound(Point1, Point4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This geometry plane is also transaction and does not need a transaction</span></span><br><span class="line">    XYZ origin = XYZ.Zero;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to a sketch plane with model curves in it, we need</span></span><br><span class="line">    <span class="comment">// to start a transaction because such operations modify the model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start(<span class="string">&quot;Create model curves&quot;</span>) == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">            SketchPlane sketch = SketchPlane.Create(document,geomPlane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a ModelLine elements using the geometry lines and sketch plane</span></span><br><span class="line">            ModelLine line1 = document.Create.NewModelCurve(geomLine1, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line2 = document.Create.NewModelCurve(geomLine2, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line3 = document.Create.NewModelCurve(geomLine3, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ask the end user whether the changes are to be committed or not</span></span><br><span class="line">            TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">            taskDialog.MainContent = <span class="string">&quot;Click either [OK] to Commit, or [Cancel] to Roll back the transaction.&quot;</span>;</span><br><span class="line">            TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Cancel;</span><br><span class="line">            taskDialog.CommonButtons = buttons;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TaskDialogResult.Ok == taskDialog.Show())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed != transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Failure&quot;</span>, <span class="string">&quot;Transaction could not be committed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SubTransaction-子事务"><a href="#SubTransaction-子事务" class="headerlink" title="SubTransaction 子事务"></a>SubTransaction 子事务</h3><p>SubTransaction可以用来封装一组模型修改操作。子事务是可选的。修改模型时不需要它们。它们是一种方便的工具，允许将较大的任务逻辑拆分为较小的任务。子事务只能在已经打开的事务中创建，并且必须在事务关闭（提交或回滚）之前关闭（提交或回滚）。与事务不同，子事务可以嵌套，但任何嵌套的子事务都必须在封闭子事务之前关闭。子事务没有名称，因为它们不显示在Revit的“撤消”菜单上。</p>
<h3 id="TransactionGroup事务组"><a href="#TransactionGroup事务组" class="headerlink" title="TransactionGroup事务组"></a>TransactionGroup事务组</h3><p>TransactionGroup允许将几个独立的事务分组在一起，这使组的所有者有机会一次处理多个事务。当一个事务组要被关闭时，它可以被回滚，这意味着属于该组的所有以前提交的事务都将被回滚。如果不回滚，则可以提交或同化组。在前一种情况下，所有提交的事务（在组内）将保持原样。在后一种情况下，组内的事务将被合并到一个单独的事务中，该事务将使用组的名称。</p>
<p>事务组只能在没有打开的事务时启动，并且必须在关闭所有封闭的事务（回滚或提交）后关闭。事务组可以嵌套，但必须在封闭组关闭之前关闭任何嵌套组。事务组是可选的。修改模型时不需要这些参数。</p>
<p>下面的示例演示如何使用Assimilate（）方法使用TransactionGroup来合并两个单独的Transactions。下面的代码将导致单个Undo项添加到Undo菜单，名称为“Level and Grid”。</p>
<p>代码区域23-2：将多个事务合并到一个TransactionGroup中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CompoundOperation</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction group should be enclosed in a &#x27;using&#x27; block or guarded within</span></span><br><span class="line">    <span class="comment">// a try-catch-finally blocks to guarantee that the group does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (TransactionGroup transGroup = <span class="keyword">new</span> TransactionGroup(document, <span class="string">&quot;Level and Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transGroup.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We are going to call two methods, each having its own local transaction.</span></span><br><span class="line">            <span class="comment">// For our compound operation to be considered successful, both the individual</span></span><br><span class="line">            <span class="comment">// transactions must succeed. If either one fails, we will roll our group back,</span></span><br><span class="line">            <span class="comment">// regardless of what transactions might have already been committed.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CreateLevel(document, <span class="number">25.0</span>) &amp;&amp; CreateGrid(document, <span class="keyword">new</span> XYZ(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The process of assimilating will merge the two (or any number of) committed</span></span><br><span class="line">                <span class="comment">// transaction together and will assign the grid&#x27;s name to the one resulting transaction,</span></span><br><span class="line">                <span class="comment">// which will become the only item from this compound operation appearing in the undo menu.</span></span><br><span class="line">                transGroup.Assimilate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Since we could not successfully finish at least one of the individual</span></span><br><span class="line">                <span class="comment">// operation, we are going to roll the entire group back, which will</span></span><br><span class="line">                <span class="comment">// undo any transaction already committed while this group was open.</span></span><br><span class="line">                transGroup.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document, <span class="built_in">double</span> elevation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Level&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != Level.Create(document, elevation))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">return</span> (TransactionStatus.Committed == transaction.Commit());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the level, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document, XYZ p1, XYZ p2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We create a line and use it as an argument to create a grid</span></span><br><span class="line">            Line gridLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != gridLine) &amp;&amp; (<span class="literal">null</span> != Grid.Create(document, gridLine)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed == transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the grid, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件中的事务"><a href="#事件中的事务" class="headerlink" title="事件中的事务"></a>事件中的事务</h2><h3 id="在事件期间修改文档"><a href="#在事件期间修改文档" class="headerlink" title="在事件期间修改文档"></a>在事件期间修改文档</h3><p>事件不会自动打开事务。因此，文档不会在事件期间被修改，除非事件的某个处理程序通过在事务内部进行更改来修改文档。如果事件处理程序打开一个事务，则要求它也关闭它（提交它或回滚它），否则所有更改都将被丢弃。</p>
<p>请注意，在某些事件（例如DocumentClosing事件）期间，不允许修改活动文档。如果事件处理程序试图在此类事件期间进行修改，则将引发异常。事件文档指示事件是否为只读。</p>
<h3 id="DocumentChanged事件"><a href="#DocumentChanged事件" class="headerlink" title="DocumentChanged事件"></a>DocumentChanged事件</h3><p>DocumentChanged事件在每个事务提交、撤消或重做后引发。这是一个只读事件，旨在使外部数据与Revit数据库的状态保持同步。若要更新Revit数据库以响应图元中的更改，请使用动态模型更新框架。</p>
<h2 id="失败处理选项"><a href="#失败处理选项" class="headerlink" title="失败处理选项"></a>失败处理选项</h2><p>失败处理选项是在事务结束时如何处理失败（如果有）的选项。在使用Transaction.SetFailureHandlingOptions（）方法调用Transaction.Commit（）或Transaction.RollBack（）之前，可以随时设置失败处理选项。但是，在提交或回滚事务后，这些选项将返回到各自的默认设置。</p>
<p>SetFailureHandlingOptions（）方法接受FailureHandlingOptions对象作为参数。无法创建此对象，必须使用GetFailureHandlingOptions（）方法从事务中获取它。通过调用相应的Set方法（如SetClearAfterRollback（））来设置选项。以下各节将更详细地讨论故障处理选项。</p>
<h3 id="ClearAfterRollback"><a href="#ClearAfterRollback" class="headerlink" title="ClearAfterRollback"></a>ClearAfterRollback</h3><p>此选项控制是否应在回滚事务后清除所有警告。默认值为False。</p>
<h3 id="DelayedMiniWarnings-DelayedMinimax"><a href="#DelayedMiniWarnings-DelayedMinimax" class="headerlink" title="DelayedMiniWarnings DelayedMinimax"></a>DelayedMiniWarnings DelayedMinimax</h3><p>此选项控制是否在当前正在结束的事务结束时显示小警告（如果有），或者是否应将其推迟到下一个事务结束时显示。当不希望在每个步骤结束时显示中间警告，而希望等到整个链完成时，通常在事务链中使用此方法。</p>
<p>多个事务可能会延迟验证。第一个未将此选项设置为True的事务将显示其自己的所有警告（如果有）以及可能从以前的事务累积的所有警告。默认值为False。</p>
<p>注意：此选项在模态模式下被忽略（请参阅下面的ForcedModalHandling）。</p>
<h3 id="ForcedModalHandling"><a href="#ForcedModalHandling" class="headerlink" title="ForcedModalHandling"></a>ForcedModalHandling</h3><p>此选项控制最终的故障是以模态方式还是以非模态方式处理。预设值为True。请注意，如果设置了非模态故障处理，则处理事务可能会异步完成，这意味着从Commit或RollBack调用返回时，事务将尚未完成（状态将为“Pending”）。</p>
<h3 id="SetFailuresPreprocessor"><a href="#SetFailuresPreprocessor" class="headerlink" title="SetFailuresPreprocessor"></a>SetFailuresPreprocessor</h3><p>如果提供此接口，则在事务结束时发现失败时调用此接口。预处理器可以检查当前的故障，甚至尝试解决它们。有关详细信息，请参阅故障发布和处理。</p>
<h3 id="SetTransactionFinalizer"><a href="#SetTransactionFinalizer" class="headerlink" title="SetTransactionFinalizer"></a>SetTransactionFinalizer</h3><p>终结器是一个接口，如果提供了该接口，则可用于在事务结束时执行自定义操作。请注意，它不会在调用Commit（）或RollBack（）方法时调用，而是仅在提交或回滚过程完成后调用。事务终结器必须实现<em>ITransactionFinalizer</em>接口，该接口需要定义两个函数：</p>
<ul>
<li>OnCommitted - called at the end of committing a transaction<br>OnCommitted -在提交事务结束时调用</li>
<li>OnRolledBack - called at the end of rolling back a transaction<br>OnRolledBack -在回滚事务结束时调用</li>
</ul>
<p><em><strong>注意：</strong></em>由于终结器是在事务完成后调用的，因此除非启动新事务，否则无法从终结器修改文档。</p>
<h2 id="获取元素几何图形和分析模型"><a href="#获取元素几何图形和分析模型" class="headerlink" title="获取元素几何图形和分析模型"></a>获取元素几何图形和分析模型</h2><p>创建新图元或修改图元后，需要重新生成和自动连接图元以将更改传播到整个模型中。如果不进行再生（以及相关的自动连接），则无法获得“几何”属性和“元素的分析模型”（在创建新元素的情况下），或者它们可能无效。在访问图元的“几何”或“分析模型”之前，了解再生发生的方式和时间非常重要。</p>
<p>尽管再生和自动连接对于传播模型中所做的更改是必要的，但这可能很耗时。最好是这些事件只在必要时发生。</p>
<p>当修改模型的事务成功提交时，或者调用Document.Regenerate（）或Document.AutoJoinElements（）方法时，自动进行重新生成和自动联接。Regenerate（）和AutoJoinElements（）只能在打开的事务中调用。应该注意的是，Regeneration（）方法可能会失败，在这种情况下，RegenerationFailedException将被抛出。如果发生这种情况，则需要通过回滚当前事务或子事务来回滚对文档的更改。</p>
<p>有关更多信息，请参见分析模型和几何形状。</p>
<p>下面的示例程序演示了事务如何填充这些属性：</p>
<p>代码区域23-3：填充几何和分析模型属性的事务处理</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransactionDuringElementCreation</span>(<span class="params">UIApplication uiApplication, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a location line for the wall creation</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Autodesk.Revit.DB.Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction wallTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating wall&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// To create a wall, a transaction must be first started</span></span><br><span class="line">       <span class="keyword">if</span> (wallTransaction.Start() == TransactionStatus.Started)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// Create a wall using the location line</span></span><br><span class="line">           Wall wall = Wall.Create(document, geomLine, level.Id, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// the transaction must be committed before you can</span></span><br><span class="line">           <span class="comment">// get the value of Geometry and AnalyticalModel.</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (wallTransaction.Commit() == TransactionStatus.Committed)</span><br><span class="line">           &#123;</span><br><span class="line">               Autodesk.Revit.DB.Options options = uiApplication.Application.Create.NewGeometryOptions();</span><br><span class="line">               Autodesk.Revit.DB.GeometryElement geoelem = wall.get_Geometry(options);</span><br><span class="line">               Autodesk.Revit.DB.Structure.AnalyticalModel analyticalmodel = wall.GetAnalyticalModel();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例的事务时间轴如下所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A7296713-19E7-4C50-A7B6-F3F7893A8EDD-low.png"></p>
<h2 id="临时事务"><a href="#临时事务" class="headerlink" title="临时事务"></a>临时事务</h2><p>并不总是需要提交事务。事务框架还允许回滚事务。这在事务处理过程中出现错误时很有用，但也可以直接用作创建临时事务的技术。</p>
<p>使用临时事务对于某些类型的分析可能很有用。例如，如果应用程序希望在墙或其他对象被洞口剪切之前从其提取几何属性，则应将临时事务与Document.Delete（）结合使用。当应用程序删除剪切目标元素的元素时，剪切元素的几何图形将恢复到其原始状态（在重新生成文档之后）。</p>
<p>要使用临时事务处理，请执行以下操作：</p>
<ol>
<li>使用Transaction构造函数实例化Transaction，并为其分配一个名称。</li>
<li>调用Transaction.Start（）</li>
<li>对文档进行临时更改（元素修改、删除或创建）</li>
<li>重新生成文档</li>
<li>提取所需的几何图形和属性</li>
<li>调用Transaction.RollBack（）将文档还原到以前的状态。</li>
</ol>
<p>这种技术也适用于子事务。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/11%E4%BA%8B%E5%8A%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/10%E8%A7%86%E5%9B%BE/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Views_html">视图</a></h1><p>视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。</p>
<p>Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。</p>
<p>在以下部分中，您将了解如何生成视图、Revit 支持的视图类型、每个视图的功能以及用户界面中视图窗口的可用功能。</p>
<p>Pages in this section 此部分中的页面</p>
<ul>
<li>About views 关于视图</li>
<li>View Graphics 视图图形</li>
<li>View Types 视图类型</li>
<li>Revisions 修改</li>
<li>View Filters 视图筛选器</li>
<li>View Cropping 视图裁剪</li>
<li>Displaced Views 置换视图</li>
<li>UIView</li>
</ul>
<h2 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h2><p>Revit API 提供对视图属性的访问，以及以编程方式创建和删除视图的功能。</p>
<p>本节是一个高级概述，其中包括以下内容：</p>
<ul>
<li>视图是如何生成的</li>
<li>视图类型</li>
<li>查看导航工具</li>
<li>创建和删除视图。</li>
</ul>
<h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>下图说明了视图是如何生成的。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EBFC1A8B-6618-4D25-BAEF-AD97A02830F5-low.png"></p>
<p>图 94： 创建视图过程</p>
<p>每个视图都是通过将三维对象投影到二维投影平面上来生成的。投影分为两个基本类：</p>
<ul>
<li>Perspective 透视</li>
<li>Parallel 平行</li>
</ul>
<p>确定投影类型后，必须指定需要 3D 模型和渲染场景的条件。有关投影的更多信息，请参阅 View3D 部分。</p>
<p>世界坐标包括以下内容：</p>
<ul>
<li>观看者的眼睛位置</li>
<li>显示投影的视图平面位置。</li>
</ul>
<p>Revit 使用两个坐标系：</p>
<ul>
<li>建筑所在的全局空间或模型空间坐标</li>
<li>视图坐标系。</li>
</ul>
<p>视图坐标系表示模型在观察者视图中的呈现方式。它的原点是查看者的眼睛位置，其在模型空间中的坐标由View.Origin属性检索。X、Y和Z轴分别由View.RightDirection、View.UpDirection和View.ViewDirection属性表示。</p>
<ul>
<li>View.RightDirection 朝向屏幕右侧。</li>
<li>View.UpDirection 朝向屏幕的上方。</li>
<li>View.ViewDirection 从屏幕到观察者的方向。</li>
</ul>
<p>视图坐标系是右手坐标系。有关详细信息，请参见View3D和View3D中的平行投影图片。</p>
<p>在投影到投影平面上之前，将排除3D模型空间中不显示的某些部分，例如位于查看器后面或距离太远而无法清晰显示的部分。此操作需要裁剪视图。以下规则适用于裁剪：</p>
<ul>
<li>Elements outside of the crop region are no longer in the view.<br>裁剪区域之外的图元将不再位于视图中。</li>
<li>View.GetCropRegionShapeManager方法返回ViewCropRegionShapeManager，它提供裁剪区域的边界信息，裁剪区域可以是矩形，也可以不是矩形。</li>
<li>View.CropBoxVisible属性确定裁剪框在视图中是否可见。</li>
<li>View.CropBoxActive属性确定裁剪框是否实际用于裁剪视图。</li>
</ul>
<p>裁剪后，模型将投影到投影平面上。以下规则适用于投影：</p>
<ul>
<li>投影内容映射到屏幕视图端口进行显示。</li>
<li>在映射过程中，投影内容会被缩放，以便在屏幕上正确显示。</li>
<li>View.Scale属性是实际模型大小与视图大小的比率。</li>
<li>图纸上的视图边界是裁剪区域，它是裁剪形状在投影平面上的投影。</li>
<li>裁剪区域的大小和位置由View.Outline属性确定。</li>
</ul>
<h3 id="视图导航工具"><a href="#视图导航工具" class="headerlink" title="视图导航工具"></a>视图导航工具</h3><p>您可以访问有关当前在View Cube设置中设置的主视图摄影机的信息。文档只能设置一个主视图摄像机。这对应于用户调用ViewCube UI命令以在ViewCube右键单击关联菜单中“将当前视图设置为主视图”时保存的视图方向和其他摄影机参数。</p>
<p>通过调用静态方法ViewNavigationToolSettings.GetViewNavigationToolSettings（）访问ViewNavigationToolSettings，该方法将返回与文档关联的ViewNavigationToolSettings元素。</p>
<p>ViewNavigationToolSettings将允许您查询是否已使用IsHomeCameraSet（）方法设置主视图，该方法返回指示主视图设置的当前状态的布尔值。</p>
<p>通过使用ViewNavigationToolSettings.GetHomeCamera（）方法获取主摄影机的副本，可以访问有关在ViewCube中设置的主摄影机的只读信息。如果HomeCamera尚未设置，则此函数返回“否”。HomeCamera类提供有关相机和模型中存储的主视图方向（如EyePosition和UpDirection）的视图的信息。</p>
<h3 id="创建和删除视图"><a href="#创建和删除视图" class="headerlink" title="创建和删除视图"></a>创建和删除视图</h3><p>Revit Platform API提供了多种方法来创建从Autodesk.Revit.DB.View类派生的相应视图图元。大多数视图类型都是使用派生视图类的静态方法创建的。如果视图创建成功，这些方法返回对视图的引用，否则返回null。在下面的部分中，将针对每个视图类描述这些方法。</p>
<p>也可以使用View.Duplicate（）方法创建视图。可以从现有视图创建新视图，并可以选择新视图是从属视图还是具有详图。以下示例演示如何创建新的依赖视图。</p>
<p>代码区域：创建依赖视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">CreateDependentCopy</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    View dependentView = <span class="literal">null</span>;</span><br><span class="line">    ElementId newViewId = ElementId.InvalidElementId;</span><br><span class="line">    <span class="keyword">if</span> (view.CanViewBeDuplicated(ViewDuplicateOption.AsDependent))</span><br><span class="line">    &#123;</span><br><span class="line">        newViewId = view.Duplicate(ViewDuplicateOption.AsDependent);</span><br><span class="line">        dependentView = view.Document.GetElement(newViewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != dependentView)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dependentView.GetPrimaryViewId() == view.Id)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Dependent View&quot;</span>, <span class="string">&quot;Dependent view created successfully!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dependentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Document.Delete（）方法和视图ID删除视图。您还可以删除与视图关联的元素。例如，删除标高图元会导致Revit删除相应的平面视图，或删除相机图元会导致Revit删除相应的三维视图。</p>
<p>依赖视图 如上所述，可以使用View.Duplicate（）方法并传入ViewDuplicationOption枚举器的AsDependent值来创建依赖视图。从属视图将与主视图和所有其他从属视图保持同步，以便在一个视图中进行视图特定更改（如视图比例和注释）时，这些更改将反映在所有视图中。并非所有视图类型都可以复制，并且不能从另一个从属视图创建从属视图。使用View.CanViewBeDuplicated（）确保可以从视图生成依赖视图。此方法采用ViewDuplicationOption枚举来检查是否可以以特定方式复制视图。可以将视图复制为独立视图，但不能复制为从属视图。 从属视图具有有效的主视图元素ID，可以从方法View.GetPrimaryViewId（）获得该ID。独立视图的主视图ID为InvalidElementId。可以使用View.ConvertToIndependent（）方法将依赖视图转换为独立视图。如果视图不是依赖的，这个方法将抛出一个异常。</p>
<p>代码区域：使依赖视图独立</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeViewIndependent</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Independent views will have an InvalidElementId for the Primary View Id</span></span><br><span class="line">    <span class="keyword">if</span> (view.GetPrimaryViewId() != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        view.ConvertToIndependent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图图形"><a href="#视图图形" class="headerlink" title="视图图形"></a>视图图形</h2><p>视图的许多图形元素和显示选项都是通过API公开的。</p>
<p>视图类具有用于获取和设置显示样式设置和详细程度设置的属性。View. DisplayStyle属性使用DisplayStyle枚举，并与Revit窗口底部可用的显示选项相对应，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DisplayStyles.jpg"></p>
<p>注意：不能从Revit AP将显示样式设置为光线跟踪，因为此显示样式会将Revit置于功能有限的受限模式。View. DetailLevel属性使用ViewDetailLevel枚举，并对应于Revit窗口底部可用的详细程度选项，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DetailLevel.jpg"></p>
<p>ViewDetailLevel枚举在给定View不使用详细级别的情况下包含Undefined。</p>
<h3 id="Thin-Lines-细线"><a href="#Thin-Lines-细线" class="headerlink" title="Thin Lines 细线"></a>Thin Lines 细线</h3><p>“细线”选项（在Revit UI的“视图”选项卡的“图形”面板上可用）控制如何在视图中绘制线。通常，在小比例视图中放大模型时，元素线看起来比实际粗得多。启用“细线”时，无论缩放级别如何，所有线条都将绘制为单一宽度。此选项通过ThinLinesOptions实用程序类提供，该类具有一个名为AreThinLinesEnabled的属性。它是影响整个Revit任务的静态属性。</p>
<h3 id="临时视图模式"><a href="#临时视图模式" class="headerlink" title="临时视图模式"></a>临时视图模式</h3><p>TemporaryViewModes类允许控制临时视图模式。可以从View.TemporaryViewModes属性访问它。对于不支持临时视图模式的视图，此属性将为空。RevealConstraints、RevealHiddenElements和WorksharingDisplay属性可用于获取和设置相应视图中这些模式的当前状态。请注意，某些模式仅在某些视图和&#x2F;或特定上下文中可用。另外，在当前上下文中不一定启用可用模式。TemporaryViewModes方法IsModeAvailable（）和IsModeEnabled（）可用于测试特定模式在使用前是否可用和启用。这些方法采用TemporaryViewMode枚举。可能的选项如下所示。</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RevealHiddenElements</td>
<td>显示隐藏元素模式</td>
</tr>
<tr>
<td>TemporaryHideIsolate</td>
<td>临时隐藏&#x2F;隔离模式</td>
</tr>
<tr>
<td>WorksharingDisplay</td>
<td>工作共享显示模式</td>
</tr>
<tr>
<td>TemporaryViewProperties</td>
<td>临时视图属性模式</td>
</tr>
<tr>
<td>Raytrace</td>
<td>在交互式光线跟踪中显示模型的模式</td>
</tr>
<tr>
<td>ExplodedView</td>
<td>以分解视图显示模型并允许用户更改&#x2F;配置的模式</td>
</tr>
<tr>
<td>RevealConstraints</td>
<td>显示模型中元素之间约束的模式</td>
</tr>
</tbody></table>
<p>代码区域：显示视图中的隐藏元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">RevealHiddenElementsInView</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> hiddenRevealed = <span class="literal">false</span>;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Invalid View&quot;</span>, <span class="string">&quot;This view does not support temporary view modes.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Mode must be available and enabled to be activated</span></span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeEnabled(TemporaryViewMode.RevealHiddenElements) &amp;&amp; viewModes.IsModeAvailable(TemporaryViewMode.RevealHiddenElements))</span><br><span class="line">        &#123;</span><br><span class="line">            viewModes.RevealHiddenElements = <span class="literal">true</span>;</span><br><span class="line">            hiddenRevealed = viewModes.RevealHiddenElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hiddenRevealed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IsModeActive（）方法测试给定的模式当前是否在视图中处于活动状态。使用DeactivateAllModes（）方法停用所有当前活动的视图，或使用DeactiveMode（）停用特定模式。 PreviewFamilyVisibility属性获取和设置关联视图中PreviewFamilyVisibility模式的当前状态。仅当视图的文档位于族编辑器的环境中时，此模式才可用。此属性是PreviewFamilyVisibilityMode枚举值而不是bool。此模式的可能状态为：</p>
<table>
<thead>
<tr>
<th>**Member Name **</th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Off</td>
<td>未应用图元可见性。所有族元素均可见。</td>
</tr>
<tr>
<td>On</td>
<td>视图的图元可见性应用于仅显示可见图元。由参照平面剪切的图元将显示其各自的剪切几何图元。</td>
</tr>
<tr>
<td>Uncut</td>
<td>视图的图元可见性应用于在实例未被剪切时显示可见的图元。请注意，此状态仅在某些视图（如楼层平面和天花板）中可用。</td>
</tr>
</tbody></table>
<p>即使视图的PreviewFamilyVisibility模式可用并已启用，也并非所有状态在所有视图中都有效。在将这些状态之一应用于视图之前，调用IsValidState（）以确保可以应用它。</p>
<p>代码区域：关闭预览族可见性模式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnOffFamilyVisibilityMode</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeAvailable(TemporaryViewMode.PreviewFamilyVisibility) &amp;&amp; viewModes.IsModeEnabled(TemporaryViewMode.PreviewFamilyVisibility))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModes.IsValidState(PreviewFamilyVisibilityMode.Off))</span><br><span class="line">            &#123;</span><br><span class="line">                viewModes.PreviewFamilyVisibility = PreviewFamilyVisibilityMode.Off;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次打开视图时，其PreviewFamilyVisibility模式的状态将根据默认设置确定，该默认设置通过静态TemporaryViewModes属性PreviewFamilyVisibilityDefaultOnState和PreviewFamilyVisibilityDefaultUncutState进行控制，如下所示。</p>
<p>代码区域：设置默认预览族可见性状态</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDefaultPreviewFamilyVisibilityState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultOnState = <span class="literal">true</span>;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultUncutState = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreviewFamilyVisibilityDefaultOnState值控制是否默认打开每个新打开的视图的PreviewFamilyVisibility模式。此属性适用于所有类型的视图。同时支持剪切和未剪切预览的视图（如楼层平面）将使用由PreviewFamilyVisibilityDefaultUncutState属性指示的剪切&#x2F;未剪切状态，但前提是PreviewFamilyVisibilityDefaultOnState属性设置为true。 这些设置适用于整个应用程序，而不是单个族文档;这些值在Revit任务之间保持不变。尽管允许随时设置该值，但在Revit应用程序初始化后所做的任何更改在下一个Revit任务之前都不会生效。 请注意，一旦显式修改PreviewFamilyVisibility属性，即使在关闭视图并稍后再次重新打开之后，应用的设置也会对相应视图保持有效。</p>
<p>视图中元素可见性 </p>
<p>视图跟踪可见元素。所有在视图中可见的图形化元素都可以使用FilteredElementCollector进行检索，该Collector是用文档和视图的id构造的。然而，集合中的某些元素可能被其他元素隐藏或覆盖。可以通过旋转视图或移除覆盖它们的图元来查看它们。删除这些可见图元可能需要Revit重新生成视图的几何图形。当您的代码第一次为给定视图使用此构造函数时，或者当您的代码第一次为显示设置刚刚更改的视图使用此构造函数时，您可能会遇到显著的性能下降。 可以在特定视图中隐藏单个图元。方法Element.IsHidden（）指示元素是否在给定视图中隐藏，Element.CanBeHidden（）返回元素是否可以隐藏。要隐藏单个元素，请使用View.HideElements（），它接受与要隐藏的元素相对应的ElementId集合。 元素可见性也可以按类别更改。 GetCategoryHidden（）方法查询类别ID以确定它在视图中是隐藏还是可见。 方法的作用是：将特定类别中的所有元素设置为隐藏或可见。 * CanCategoryBeHidden（）方法指示是否可以在视图中隐藏特定类别的元素。 基于视图的FilteredElementCollector将仅包含当前视图中可见的元素。不能检索非图形元素或不可见元素。基于文档的FilteredElementCollector检索文档中的所有元素，包括不可见元素和非图形元素。例如，在空项目中创建默认三维视图时，视图中没有元素，但文档中有许多元素，所有这些元素都不可见。 下面的代码示例计算活动文档和活动视图中墙类别元素的数量。活动视图中的元素数量与文档中的元素数量不同，因为文档包含非图形墙类别元素。</p>
<p>代码区域：计算活动视图中的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountElements</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    FilteredElementCollector viewCollector = </span><br><span class="line">        <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document, uiDoc.ActiveView.Id);</span><br><span class="line">    viewCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within active View: &quot;</span></span><br><span class="line">        + viewCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector docCollector = <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document);</span><br><span class="line">    docCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within document: &quot;</span></span><br><span class="line">        + docCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时视图模式会影响图元的可见性。IsInTemporaryViewMode（）方法可用于确定View是否处于临时视图模式。方法View.IsElementVisibleInTemporaryViewMode（）标识元素在指定的视图模式中是否应可见。这仅适用于TemporaryHideIsolate和AnalyticalModel视图模式。其他模式将导致异常。 </p>
<p>深度提示 ViewDisplayDepthCueing类提供了对剖面视图和立面视图中远处对象显示的控制。当景深效果处于活动状态时，随着与观察者距离的增加，对象会融入背景色（淡入淡出）。可以使用View.GetDepthCueing（）检索视图的当前深度提示设置。如果对返回的ViewDisplayDepthCueing进行了更改，则在调用View.SetDepthCueing（）之前，这些更改不会应用于视图。 ViewDisplayDepthCueing类具有以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EnableDepthCueing</td>
<td>为True，则启用深度提示。</td>
</tr>
<tr>
<td>StartPercentage</td>
<td>指示深度提示开始的位置。值为0表示深度提示从视图的前剪辑平面开始。</td>
</tr>
<tr>
<td>EndPercentage</td>
<td>指示深度提示结束的位置。比结束平面更远的对象将与结束平面处的对象淡入淡出相同的量。值100表示远剪裁平面。</td>
</tr>
<tr>
<td>FadeTo</td>
<td>指示通过深度提示淡入淡出对象的最大量。值为100表示完全不可见。</td>
</tr>
</tbody></table>
<p>SetStartEndPerception（）方法可用于在一次调用中设置开始和结束百分比。 下面的示例演示如何获取当前深度提示、更改其属性并将其设置回视图。请注意，并非所有视图都可以使用深度提示。</p>
<p>代码区域：更改视图的深度提示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustDepthCueing</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.CanUseDepthCueing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(view.Document, <span class="string">&quot;Change depth cueing&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            ViewDisplayDepthCueing depthCueing = view.GetDepthCueing();</span><br><span class="line">            depthCueing.EnableDepthCueing = <span class="literal">true</span>;</span><br><span class="line">            depthCueing.FadeTo = <span class="number">50</span>;    <span class="comment">// set fade to percent</span></span><br><span class="line">            depthCueing.SetStartEndPercentages(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">            view.SetDepthCueing(depthCueing);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h2><p>不同类型的Revit视图由Revit API中的不同类表示。有关每种视图类型的详细信息，请参阅以下主题。</p>
<p>本节中的页面</p>
<ul>
<li>概述</li>
<li>3D视图</li>
<li>视图平面</li>
<li>视图图纸</li>
<li>剖面图</li>
<li>图纸</li>
<li>图表</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个项目模型可以有几种视图类型。在API中，有三种方法对视图进行分类。第一种方法是使用视图元素View.ViewType属性。它返回指示视图类型的枚举值。下表列出了所有可用的视图类型。</p>
<p>表44：Autodesk.Revit.DB.ViewType</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaPlan</td>
<td>区域视图。</td>
</tr>
<tr>
<td>CeilingPlan</td>
<td>天花板反射平面图。</td>
</tr>
<tr>
<td>ColumnSchedule</td>
<td>柱表视图。</td>
</tr>
<tr>
<td>CostReport</td>
<td>成本报告视图。</td>
</tr>
<tr>
<td>Detail</td>
<td>局部视图。</td>
</tr>
<tr>
<td>DraftingView</td>
<td>草图视图。</td>
</tr>
<tr>
<td>DrawingSheet</td>
<td>图纸工作表。</td>
</tr>
<tr>
<td>Elevation</td>
<td>立面视图。</td>
</tr>
<tr>
<td>EngineeringPlan</td>
<td>工程视图。</td>
</tr>
<tr>
<td>FloorPlan</td>
<td>楼层平面视图。</td>
</tr>
<tr>
<td>Internal</td>
<td>Revit的内部视图。</td>
</tr>
<tr>
<td>Legend</td>
<td>图例视图。</td>
</tr>
<tr>
<td>LoadsReport</td>
<td>荷载报告视图。</td>
</tr>
<tr>
<td>PanelSchedule</td>
<td>配电盘明细表视图。</td>
</tr>
<tr>
<td>PressureLossReport</td>
<td>压力损失报告视图。</td>
</tr>
<tr>
<td>Rendering</td>
<td>渲染视图。</td>
</tr>
<tr>
<td>Report</td>
<td>报告视图。</td>
</tr>
<tr>
<td>Schedule</td>
<td>视图表。</td>
</tr>
<tr>
<td>Section</td>
<td>剖面视图。</td>
</tr>
<tr>
<td>ThreeD</td>
<td>3D视图。</td>
</tr>
<tr>
<td>Undefined</td>
<td>未定义&#x2F;未指定视图。</td>
</tr>
<tr>
<td>Walkthrough</td>
<td>Walkthrough视图。</td>
</tr>
</tbody></table>
<p>分类视图的第二种方法是按类类型。下表列出了项目浏览器中的视图类型和相应视图。</p>
<p>表45：项目浏览器视图</p>
<table>
<thead>
<tr>
<th><strong>Project Browser Views 项目浏览器视图</strong></th>
<th><strong>View Type 视图类型</strong></th>
<th><strong>Class Type 类类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Area Plans</td>
<td>ViewType.AreaPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Ceiling Plans</td>
<td>ViewType.CeilingPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Graphic Column Schedule</td>
<td>ViewType.ColumnSchedule</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Detail Views</td>
<td>ViewType.Detail</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Drafting Views</td>
<td>ViewType.DraftingView</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Sheets</td>
<td>ViewType.DrawingSheet</td>
<td>Elements.ViewSheet</td>
</tr>
<tr>
<td>Elevations</td>
<td>ViewType.Elevation</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Structural Plans</td>
<td>ViewType.EngineeringPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Floor Plans</td>
<td>ViewType.FloorPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Legends</td>
<td>ViewType.Legend</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.LoadsReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PanelSchedule</td>
<td>Elements.PanelScheduleView</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PresureLossReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Renderings</td>
<td>ViewType.Rendering</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Reports</td>
<td>ViewType.Report</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Schedules&#x2F;Quantities</td>
<td>ViewType.Schedule</td>
<td>Elements.ViewSchedule</td>
</tr>
<tr>
<td>Sections</td>
<td>ViewType.Section</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>3D Views</td>
<td>ViewType.ThreeD</td>
<td>Elements.View3D</td>
</tr>
<tr>
<td>Walkthroughs</td>
<td>ViewType.Walkthrough</td>
<td>Elements.View3D</td>
</tr>
</tbody></table>
<p>此示例说明如何使用视图的ViewType属性来确定视图的类型。</p>
<p>代码区域：确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetViewType</span>(<span class="params">Autodesk.Revit.DB.View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the view type of the given view, and format the prompt string</span></span><br><span class="line">        String prompt = <span class="string">&quot;The view is &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (view.ViewType)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> ViewType.AreaPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an area view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CeilingPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a reflected ceiling plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.ColumnSchedule:</span><br><span class="line">                        prompt += <span class="string">&quot;a column schedule view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CostReport:</span><br><span class="line">                        prompt += <span class="string">&quot;a cost report view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Detail:</span><br><span class="line">                        prompt += <span class="string">&quot;a detail view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DraftingView:</span><br><span class="line">                        prompt += <span class="string">&quot;a drafting view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DrawingSheet:</span><br><span class="line">                        prompt += <span class="string">&quot;a drawing sheet view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Elevation:</span><br><span class="line">                        prompt += <span class="string">&quot;an elevation view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.EngineeringPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an engineering view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.FloorPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a floor plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分类视图的第三种方法是使用ViewFamilyType类。大多数视图创建方法需要新视图的ViewFamilyType的ID。可以从View.GetTypeId（）方法中检索ViewFamilyType的ID。ViewFamily属性返回ViewFamily枚举，它指定ViewFamilyType的族，类似于上面记录的ViewType枚举。下面的示例说明如何从View获取ViewFamily。</p>
<p>代码区域：从ViewFamilyType确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFamily <span class="title">GetViewFamily</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewFamily viewFamily = ViewFamily.Invalid;</span><br><span class="line"></span><br><span class="line">    ElementId viewTypeId = view.GetTypeId();</span><br><span class="line">    <span class="keyword">if</span> (viewTypeId.IntegerValue &gt; <span class="number">1</span>) <span class="comment">// some views may not have a ViewFamilyType</span></span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType viewFamilyType = doc.GetElement(viewTypeId) <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line">        viewFamily = viewFamilyType.ViewFamily;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewFamily;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p>View3D是一个自由导向的三维视图。</p>
<p>有两种三维视图：透视视图和等轴测视图，在Revit用户界面中也称为正交视图。差异基于投影射线关系。View3D.IsPerspective属性指示三维视图是透视视图还是等轴测视图。</p>
<h4 id="透视图"><a href="#透视图" class="headerlink" title="透视图"></a>透视图</h4><p>下图说明了如何创建透视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EF11532A-32D3-40C1-9410-5AADA6FD8701-low.png"></p>
<p>图96：透视投影</p>
<ul>
<li>直投影射线穿过模型中的每个点并与投影平面相交以形成投影内容。</li>
<li>为了便于从世界坐标到视图平面的变换，视图坐标系基于观察者。</li>
<li>它的原点由View.Origin属性表示，是查看者的位置。</li>
<li>使用ViewOrientation3D.EyePosition属性（从View3D.GetOrientation（）检索）检索查看器的世界坐标。因此，在3D视图中，View.Origin始终等于相应的ViewOrientation3D.EyePosition。</li>
<li>如上图所述，<em>观察</em>坐标系确定如下：<ul>
<li>X轴由View.RightDirection确定。</li>
<li>Y轴由View.UpDirection确定。</li>
<li>Z轴由View.ViewDirection确定。</li>
</ul>
</li>
<li>观看方向是在3D空间中从目标点到观看者，以及在屏幕空间中从屏幕到观看者。</li>
</ul>
<p>静态方法View3D.ViewPerspective（）方法可用于创建新的透视图。</p>
<p>代码区域：View3D.CreatePerspective（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreatePerspective (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。 下面的代码示例说明如何创建透视三维视图。</p>
<p>代码区域：创建透视三维视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"><span class="comment">// Create a new Perspective View3D</span></span><br><span class="line">View3D view3D = View3D.CreatePerspective(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">10</span>); </span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    view3D.SetOrientation(<span class="keyword">new</span> ViewOrientation3D(eye, up, forward));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn off the far clip plane with standard parameter API</span></span><br><span class="line">    Parameter farClip = view3D.LookupParameter(<span class="string">&quot;Far Clip Active&quot;</span>);</span><br><span class="line">    farClip.Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透视视图裁剪框是锥体的一部分，其顶点位于查看者位置。它是两个平行剪裁平面之间的几何体。裁剪框限定模型中被裁剪并投影到视图平面上的部分。 裁剪框由View.CropBox属性表示，该属性返回一个BoundingBoxXYZ对象。 CropBox.Min和CropBox.Max点在上一张图片中标记。请注意，透视图中的CropBox.Min点是通过将裁剪框前裁剪平面投影到后裁剪平面上而生成的。 裁剪框坐标基于查看坐标系。使用Transform.OfPoint（）将CropBox.Min和CropBox.Max变换到世界坐标系。有关变换的更多详细信息，请参见几何部分中的几何辅助类。 投影平面加上前剪裁平面和后剪裁平面都垂直于视图方向。CropBox.Max和CropBox.Min之间的线与查看方向平行。利用这些因子，可以计算裁剪框几何形状。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CCAE0F1D-6889-4225-900A-45CF0D207B15-low.png"></p>
<p>图97：透视3D视图</p>
<p>上图显示了裁剪后屏幕上的投影平面。裁剪区域是投影平面和裁剪框的矩形相交。 使用View.CropRegion属性检索几何信息。此属性返回BoundingBoxUV实例。 View.Outline.Max属性指向右上角。 View.Outline.Min属性指向左下角。 与裁剪框类似，裁剪区域坐标基于查看坐标系。下列表达式是相等的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) </span><br></pre></td></tr></table></figure>

<p>由于物体的透视投影的大小与从该物体到投影中心的距离成反比，因此比例对于透视图来说是没有意义的。透视三维视图的“比例”属性始终返回零。 #管理摄像头目标 相机表示透视视图的查看者正在查看的方向。如果用户或API应用调整裁剪区域以暴露更宽的视场或不对称的视场，则透视图的失真可能变得过于剧烈。可以通过调用View3D方法RestCameraTarget（）将摄像机目标定位在视场的中心，从而将摄像机目标强制定位到观察区域的中心。在调用之前，请检查是否可以使用View3D.CanResetCameraTarget（）方法在此视图中重置摄像机，该方法指示是否可以重置摄像机目标。无法重置目标的主要情况是View3D当前处于等轴测投影中。尝试在等轴测视图中重置相机目标将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<p>等距视图 可以使用静态View3D.NETIsometric（）方法创建新的等轴测视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6B8688A8-D480-4C35-84A2-5CA5CF8D1577-low.png"></p>
<p>图98：平行投影 </p>
<p>等轴测视图是使用平行投影光线通过将模型投影到与光线垂直的平面上而生成的。查看坐标系类似于透视图，但裁剪框是一个平行六面体，其面与投影光线平行或垂直。View.CropBox属性指向两个对角，其坐标基于查看坐标系。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A25AEAB3-BBF1-41E9-8B40-B1D40168A7AE-low.png"></p>
<p>图99：将视图平面上的窗口缩放到屏幕视口</p>
<p> 模型将投影到视图平面上，然后缩放到屏幕上。View.Scale属性表示实际模型大小与视图大小的比率。相关表达式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) == View.Scale </span><br></pre></td></tr></table></figure>

<p>代码区域：View3D.Other Isometric（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreateIsometric (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。Revit确定以下内容：观察者的位置。 如何使用视图方向创建视图坐标系。 * 如何创建裁剪框来裁剪模型。 创建视图后，可以调整裁剪框的大小以查看模型的不同部分。也可以更改默认方向。API不支持修改查看坐标系。 下面的代码示例说明如何创建等轴测三维视图。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line"></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                              <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                              <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                              <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new View3D</span></span><br><span class="line">View3D view3D = View3D.CreateIsometric(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ViewOrientation3D viewOrientation3D = newViewOrientation3D(eye, up, forward);</span><br><span class="line">    view3D.SetOrientation(viewOrientation3D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在等距和透视之间切换"><a href="#在等距和透视之间切换" class="headerlink" title="在等距和透视之间切换"></a>在等距和透视之间切换</h4><p>大多数情况下，View3D可以在“等轴测”和“透视”之间切换，前提是视图中没有视图特定的元素。View3D类提供了在等轴测和透视模式之间切换视图的方法。在切换之前，使用CanToggleBetweenPerspectiveAndIsometric（）方法，该方法指示是否可以进行切换。</p>
<p>要切换视图，请调用以下两个View 3D类方法之一：ToggleToPerspective（）或ToggleToIsometric（）。如果无法切换视图（可能是由于视图中存在特定于视图的元素），则这两种方法中的任何一种都将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<h4 id="3D视图剖面框"><a href="#3D视图剖面框" class="headerlink" title="3D视图剖面框"></a>3D视图剖面框</h4><p>每个视图都有一个裁剪框。裁剪框聚焦于要投影并显示在视图中的模型部分。对于三维视图，还有另一个名为剖面框的框。</p>
<ul>
<li>剖面框确定在三维视图中显示的模型部分。</li>
<li>剖面框用于剪裁三维模型的可见部分。</li>
<li>即使在裁剪框中，框外的部分也不可见。</li>
<li>剖面框与裁剪框的不同之处在于，剖面框可以随模型一起旋转和移动。</li>
</ul>
<p>剖面框对于大型模型特别有用。例如，如果要渲染大型建筑，请使用剖面框。剖面框限制用于计算的模型部分。若要显示剖面框，请在“三维视图图元属性”对话框的“范围”区域中选择“剖面框”。也可以使用IsSectionBoxActive属性设置它。在下面的示例中，如果活动视图是三维视图，它将设置剖面框是否处于活动状态。</p>
<p>代码区域：显示&#x2F;隐藏剖面框</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowHideSectionBox</span>(<span class="params">UIDocument document, <span class="built_in">bool</span> active</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (document.ActiveView <span class="keyword">is</span> View3D)</span><br><span class="line">    &#123;</span><br><span class="line">        View3D view3d = document.ActiveView <span class="keyword">as</span> View3D;</span><br><span class="line">        view3d.IsSectionBoxActive = active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-016E48BA-138E-4686-B864-D4A978DC406C-low.png"></p>
<p>图100：剖面框</p>
<p> View3D.GetSectionBox（）和View3D.SetSectionBox（）方法用于获取和更改长方体范围。在某些情况下，调用View3D.SetSectionBox（）可能会产生副作用。将该属性设置为某些值可以更改框的容量并将其显示在视图中。若要避免显示剖面框，请将IsSectionBoxActive属性设置为false。 下面的代码示例阐释如何更改剖面框的范围。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandSectionBox</span>(<span class="params">View3D view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The original section box</span></span><br><span class="line">    BoundingBoxXYZ sectionBox = view.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expand the section box (doubling in size in all directions while preserving the same center and orientation)</span></span><br><span class="line">    Autodesk.Revit.DB.XYZ deltaXYZ = sectionBox.Max - sectionBox.Min;</span><br><span class="line">    sectionBox.Max += deltaXYZ / <span class="number">2</span>;</span><br><span class="line">    sectionBox.Min -= deltaXYZ / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//After resetting the section box, it will be shown in the view.</span></span><br><span class="line">    <span class="comment">//It only works when the Section Box is active</span></span><br><span class="line">    view.SetSectionBox(sectionBox);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从GetSectionBox（）方法返回的BoundingBoxXYZ的Max和Min点的坐标不是全局坐标。要将Max和Min的坐标转换为全局坐标，需要通过从BoundingBoxXYZ.Transform属性获得的变换来转换每个点。</p>
<p>代码区域：将最大值和最小值转换为全局坐标</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertMaxMinToGlobal</span>(<span class="params">View3D view, <span class="keyword">out</span> XYZ max, <span class="keyword">out</span> XYZ min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BoundingBoxXYZ sectionbox = view.GetSectionBox();</span><br><span class="line">    Transform transform = sectionbox.Transform;</span><br><span class="line">    max = transform.OfPoint(sectionbox.Max);</span><br><span class="line">    min = transform.OfPoint(sectionbox.Min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图锁定"><a href="#视图锁定" class="headerlink" title="视图锁定"></a>视图锁定</h4><p>View3D类具有与Revit用户界面中可用的锁定功能相对应的方法和属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/3DLocking.jpg"></p>
<p>View3D.SaveOrientationAndLock（）方法将保存方向并锁定视图，而View3D.RestoreOrientationAndLock（）将恢复视图的方向并锁定它。View3D.RestoreOrientationAndLock（）将解锁当前锁定的视图。IsLocked属性将返回3D视图当前是否被锁定。</p>
<h3 id="视图平面"><a href="#视图平面" class="headerlink" title="视图平面"></a>视图平面</h3><p>平面视图是基于标高的。平面视图有三种类型：楼层平面视图、天花板平面视图和面积平面视图。</p>
<h4 id="创建平面视图"><a href="#创建平面视图" class="headerlink" title="创建平面视图"></a>创建平面视图</h4><ul>
<li>通常，楼层平面视图是在新项目中打开的默认视图。</li>
<li>大多数项目至少包括一个楼层平面视图和一个天花板平面视图。</li>
<li>通常在向项目中添加新标高后创建平面视图。</li>
</ul>
<p>使用API添加新标高不会自动添加平面视图。使用静态ViewPlan.Create（）方法创建新的地板和天花板平面视图。使用静态ViewPlan. ViewAreaPlan（）方法创建新的面积平面视图。</p>
<p>代码区域：创建平面视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.Create(Document document, ElementId viewFamilyTypeId, ElementId levelId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.CreateAreaPlan(Document document, ElementId areaSchemeId, ElementId levelId);</span><br></pre></td></tr></table></figure>

<p>ViewPlan.Create（）中的viewFamilyTypeId参数必须是FloorPlan、CeilingPlan、AreaPlan或StructuralPlan ViewType。levelId参数表示与平面视图关联的项目中标高图元的ID。 下面的代码基于某个标高创建楼层平面和天花板平面。</p>
<p>代码区域：创建楼层平面和天花板平面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateViewPlan</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList viewFamilyTypes = collector.OfClass(<span class="keyword">typeof</span>(ViewFamilyType)).ToElements();</span><br><span class="line">    ElementId floorPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType v = e <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v.ViewFamily == ViewFamily.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            floorPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElementId ceilingPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.Name == <span class="string">&quot;Ceiling Plan&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ceilingPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Level and a Floor Plan based on it</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">10.0</span>;</span><br><span class="line">    Level level1 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan floorView = ViewPlan.Create(document, floorPlanId, level1.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create another Level and a Ceiling Plan based on it</span></span><br><span class="line">    elevation += <span class="number">10.0</span>;</span><br><span class="line">    Level level2 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan ceilingView = ViewPlan.Create(document, ceilingPlanId, level2.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面视图属性"><a href="#平面视图属性" class="headerlink" title="平面视图属性"></a>平面视图属性</h4><p>创建新平面视图后，可以使用类型为ViewDiscipline的Discipline参数设置视图的Discipline。选项包括建筑、结构、机械、电气、管道和协调。</p>
<p>对于结构平面视图，可以使用ViewFamilyType.PlanViewDirection属性将视图方向设置为“向上”或“向下”。尽管它是ViewFamilyType类的属性，但如果为StructuralPlan视图以外的视图访问该属性，则将引发异常。</p>
<h4 id="视图范围"><a href="#视图范围" class="headerlink" title="视图范围"></a>视图范围</h4><p>可以通过ViewPlan.GetViewRange（）方法检索平面视图的视图范围。返回的PlanViewRange对象可用于查找平面相对的标高以及每个平面与该标高的偏移量。该信息与Revit用户界面的“视图范围”对话框中提供的信息相同：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ViewRange-76168.jpg"></p>
<p>以下示例显示如何获取平面视图的顶部剪裁平面和关联偏移</p>
<p>代码区域：获取视图范围的信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewRange</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> ViewPlan)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlan viewPlan = view <span class="keyword">as</span> ViewPlan;</span><br><span class="line">        PlanViewRange viewRange = viewPlan.GetViewRange();</span><br><span class="line"></span><br><span class="line">        ElementId topClipPlane = viewRange.GetLevelId(PlanViewPlane.TopClipPlane);</span><br><span class="line">        <span class="built_in">double</span> dOffset = viewRange.GetOffset(PlanViewPlane.TopClipPlane);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topClipPlane.IntegerValue &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Element levelAbove = doc.GetElement(topClipPlane);</span><br><span class="line">            TaskDialog.Show(view.Name, <span class="string">&quot;Top Clip Plane: &quot;</span> + levelAbove.Name + <span class="string">&quot;\r\nTop Offset: &quot;</span> + dOffset + <span class="string">&quot; ft&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面图underlay"><a href="#平面图underlay" class="headerlink" title="平面图underlay"></a>平面图underlay</h4><p>可以从ViewPlan中检索和设置顶层和底层范围。使用GetUnderlayBaseLevel（）和SetUnderlayBaseLevel（）访问对象范围的基准标高。如果基本级别ID为InvalidElementId，则不设置无效基本级别，并且没有元素显示为无效。设置参考底图范围的基准标高时，下一个最高标高的高程将用于确定参考底图范围的顶部。如果为基准标高指定的标高是最高标高，则该范围将是无边界的，并且将由指定标高以上的所有内容组成。</p>
<p>使用GetUnderlayTopLevel（）和SetUnderlayRange（）访问对象范围的顶级。如果GetUnderlayTopLevel（）返回InvalidElementId，并且XML基础级别是有效级别，则XML范围是无边界的，并且包含XML基础级别之上的所有内容。若要设置顶层，必须使用SetUnderlayRange（），该方法将ElementIds用于底层和顶层。如果顶层的高程不大于底层的高程，此方法将引发异常。</p>
<p>使用GetUnderlayOrientation（）和SetUnderlayOrientation（）方法控制如何查看视图中的元素。UnderlayOrientation可以是LookingDown（向下查看图元，就像从上面向下查看一样）或LookingUp（向上查看图元，就像从下面向上查看一样）。</p>
<p>如果当前方向为LookingDown且顶级Id与新值不同，则以下代码设置范围。然后方向更改为LookingUp。</p>
<p>代码区域：更改视图范围</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewUnderlay</span>(<span class="params">ViewPlan planView, ElementId topLevelId, ElementId baseLevelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (planView.GetUnderlayOrientation() == UnderlayOrientation.LookingDown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (planView.GetUnderlayTopLevel() != topLevelId)</span><br><span class="line">        &#123;</span><br><span class="line">            planView.SetUnderlayRange(baseLevelId, topLevelId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        planView.SetUnderlayOrientation(UnderlayOrientation.LookingUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图图纸"><a href="#视图图纸" class="headerlink" title="视图图纸"></a>视图图纸</h3><p>视图，用于创建不属于建模设计的、不关联的视图专有详图。</p>
<p>图纸视图未与模型关联。它允许用户创建不包括在模型中的详图。</p>
<ul>
<li><p>在绘图视图中，用户可以以不同的视图比例（粗略、精细或中等）创建详图。</p>
</li>
<li><p>您可以使用2D详图工具，包括：</p>
<table>
<thead>
<tr>
<th><em>Detail lines</em> Detail regions <em>Detail components</em> Insulation <em>详图线</em>详图区域<em>详图构件</em>隔热层</th>
<th><em>Reference planes</em> Dimensions <em>Symbols</em> Text <em>参照平面</em>尺寸<em>符号</em>文字</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这些工具与用于创建局部视图的工具相同。</p>
</li>
<li><p>图纸视图不显示模型图元。</p>
</li>
</ul>
<p>使用静态ViewDrafting.Create（）方法创建图纸视图。模型图元不显示在图纸视图中。</p>
<h4 id="图片视图"><a href="#图片视图" class="headerlink" title="图片视图"></a>图片视图</h4><p>ImageView类派生自ViewDrafting。它可用于创建包含从磁盘导入的图像的渲染视图。使用静态ImageView.Create（）方法创建新的呈现视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/RenderingView-76170.jpg"></p>
<h3 id="剖面视图"><a href="#剖面视图" class="headerlink" title="剖面视图"></a>剖面视图</h3><p>表示剖面视图、局部视图、俯视图和立面视图，以及参照详图索引和参照剖面。</p>
<p>ViewSection类可用于创建剖面视图、局部视图、局部视图、参照详图索引和参照剖面。它还表示立面视图。</p>
<p>剖面视图和参照剖面</p>
<p>剖面视图剖切模型以显示内部结构。ViewSection.ViewSection（）方法创建剖面视图。</p>
<p>代码区域：ViewSection. ViewSection（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateSection(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是截面视图族。sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。通常，另一个视图的裁剪框用作参数。您还可以构建自定义BoundingBoxXYZ实例来表示方向和范围。 下面的代码演示如何创建剖面视图。将在墙的中心创建剖面视图的边界框。生成的剖面视图将位于项目浏览器的“剖面（建筑剖面）”节点中。请注意，远裁剪距离将等于创建时边界框的最小值和最大值的z坐标之差。</p>
<p>代码区域：创建剖面图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a section view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.Section</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxXYZ instance centered on wall</span></span><br><span class="line">LocationCurve lc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">Transform curveTransform = lc.Curve.ComputeDerivatives(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// using 0.5 and &quot;true&quot; (to specify that the parameter is normalized) </span></span><br><span class="line"><span class="comment">// places the transform&#x27;s origin at the center of the location curve)</span></span><br><span class="line"></span><br><span class="line">XYZ origin = curveTransform.Origin; <span class="comment">// mid-point of location curve</span></span><br><span class="line">XYZ viewDirection = curveTransform.BasisX.Normalize(); <span class="comment">// tangent vector along the location curve</span></span><br><span class="line">XYZ normal = viewDirection.CrossProduct(XYZ.BasisZ).Normalize(); <span class="comment">// location curve normal @ mid-point</span></span><br><span class="line"></span><br><span class="line">Transform transform = Transform.Identity;</span><br><span class="line">transform.Origin = origin;</span><br><span class="line">transform.BasisX = normal;</span><br><span class="line">transform.BasisY = XYZ.BasisZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can use this simplification because wall&#x27;s &quot;up&quot; is vertical.</span></span><br><span class="line"><span class="comment">// For a non-vertical situation (such as section through a sloped floor the surface normal would be needed)</span></span><br><span class="line">transform.BasisZ = normal.CrossProduct(XYZ.BasisZ);</span><br><span class="line"></span><br><span class="line">BoundingBoxXYZ sectionBox = <span class="keyword">new</span> BoundingBoxXYZ();</span><br><span class="line">sectionBox.Transform = transform;</span><br><span class="line">sectionBox.Min = <span class="keyword">new</span> XYZ(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sectionBox.Max = <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Min &amp; Max X values (-10 &amp; 10) define the section line length on each side of the wall</span></span><br><span class="line"><span class="comment">// Max Y (12) is the height of the section box// Max Z (5) is the far clip offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new view section.</span></span><br><span class="line">ViewSection viewSection = ViewSection.CreateSection(document, viewFamilyTypes.First().Id, sectionBox);</span><br></pre></td></tr></table></figure>

<p>参照剖面是参照现有视图的剖面。创建新参照剖面时，Revit不会添加新视图。</p>
<p>代码区域：ViewSection. ViewReferenceSection（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceSection(Document document, </span><br><span class="line">                                                      ElementId parentViewId,</span><br><span class="line">                                                      ElementId viewIdToReference, </span><br><span class="line">                                                      XYZ headPoint, </span><br><span class="line">                                                      XYZ tailPoint);</span><br></pre></td></tr></table></figure>

<p>parentViewId参数是将在其中显示新引用截面标记的视图的ID。可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建参照剖面。viewIdToReference可以是详图、绘图或剖面视图的ID。新参照截面将使用参照视图的ViewFamilyType。这两个XYZ点将确定父视图中截面标记标头的位置。 #详细视图 局部视图是模型的视图，在其他视图中显示为剖面或截面。这种类型的视图通常以比父视图中更精细的细节比例来表示模型。它用于向模型的特定部分添加更多信息。静态ViewSection. ViewDetail（）方法用于创建新的细节ViewSection。</p>
<p>代码区域：ViewSection. ViewDetail（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateDetail(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是详图视图族。与标准剖面视图一样，sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。 添加新详图ViewSection后，它将显示在项目浏览器的“详图视图（Detail）”节点中。 #立面视图 立面视图是模型的横截面，其中显示标高线。立面视图由ViewSection类表示。但是，与其他类型的横断面图不同，不能使用ViewSection类的静态方法创建立面视图。要创建立面视图，请先创建立面标记，然后使用该标记生成立面视图。新创建的立面视图将显示在项目浏览器的“立面（建筑立面）”节点中。它将被分配一个唯一的名称。 以下示例基于梁的位置创建立面视图。</p>
<p>代码区域：创建立面视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewSection <span class="title">CreateElevationView</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an elevation view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Elevation</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    LocationCurve lc = beam.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ xyz = lc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    ElevationMarker marker = ElevationMarker.CreateElevationMarker(document, viewFamilyTypes.First().Id, xyz, <span class="number">1</span>);</span><br><span class="line">    ViewSection elevationView = marker.CreateElevation(document, document.ActiveView.Id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elevationView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElevationMarker. Elevation（）方法将ViewPlan的id作为参数。这是ElevationMarker可见的ViewPlan。新的立面ViewSection将从ViewPlan中导出其范围并继承设置。最后一个参数是将放置新立面视图的ElevationMarker上的索引。ElevationMarker上的索引必须有效且未使用。视图的方向由索引决定。 #标注和参考标注 视图以较大比例显示另一个视图的一部分。可以使用静态方法ViewSection. callout（）创建标注视图。详图索引可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建。生成的视图将是ViewSection、ViewPlan或ViewDetail，具体取决于所使用的ViewFamilyType，并将显示在项目浏览器的相应节点中。</p>
<p>代码区域：ViewSection. callout（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateCallout(Document document, </span><br><span class="line">                                            ElementId parentViewId, </span><br><span class="line">                                            ElementId viewFamilyTypeId,</span><br><span class="line">                                            XYZ point1,</span><br><span class="line">                                            XYZ point2);</span><br></pre></td></tr></table></figure>

<p>父视图ID参数可以是可在其上创建详图索引的任何类型的视图的ID。点参数确定父视图中的图元符号的范围。参照图元是指引用现有视图的图元。添加参照视图时，Revit不会在项目中创建视图。相反，它创建一个指向指定的现有视图的指针。多个参照详图索引可以指向同一视图。</p>
<p>代码区域：ViewSection. ViewReferenceCallout（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceCallout(Document document, </span><br><span class="line">                                                      ElementId parentViewId, </span><br><span class="line">                                                      ElementId viewIdToReference,</span><br><span class="line">                                                      XYZ point1,</span><br><span class="line">                                                      XYZ point2);</span><br></pre></td></tr></table></figure>

<p>创建引用对象与创建对象类似。但是，与其将视图的ViewFamilyType的Id作为参数，还不如将视图ReferenceCallout（）方法作为要引用的视图的Id。被引用视图的ViewFamilyType将由新引用对象使用。 只能参照裁剪的视图，除非参照的视图是“绘图”视图。无论父视图类型如何，始终可以参照绘图视图。立面视图可以从立面父视图和图纸父视图中参照。可以从“截面”和“绘图”父视图中参照截面视图。可以从所有父视图中参照详图视图，但在FloorPlan、CeilingPlan和StructuralPlan父视图中除外，在这些父视图中只能参照水平方向的详图视图。FloorPlan、CeilingPlan和StructuralPlan视图可以从FloorPlan、CeilingPlan和StructuralPlan父视图中引用。 下面的示例使用Detail ViewFamilyType创建新的图元，然后使用新的图元视图创建引用图元。</p>
<p>代码区域：创建对象和引用对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateCalloutView</span>(<span class="params">Document document, View parentView</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a detail view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Detail</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    ElementId viewFamilyTypeId = viewFamilyTypes.First().Id;    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    ElementId parentViewId = parentView.Id;  <span class="comment">// a ViewPlan</span></span><br><span class="line">    View view = ViewSection.CreateCallout(document, parentViewId, viewFamilyTypeId, point1, point2);</span><br><span class="line"></span><br><span class="line">    ViewSection.CreateReferenceCallout(document, parentViewId, view.Id, point1, point2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图纸"><a href="#图纸" class="headerlink" title="图纸"></a>图纸</h3><p>图纸包含视图和标题栏。使用ViewSheet.Create（）方法创建图纸视图时，标题栏族符号Id是该方法的必需参数。可以使用FilteredElementCollector找到标题栏族符号。</p>
<p>代码区域：ViewSheet.Create（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewSheet ViewSheet.Create(Document document, ElementId titleBlockTypeId);</span><br></pre></td></tr></table></figure>

<p>新创建的图纸没有视图。Viewport.Create（）方法用于添加视图。Viewport类用于将常规视图添加到视图工作表，即平面、立面、绘图和三维视图。若要向视图添加明细表，请改用ScheduleSheetInstance.Create（）。</p>
<p>代码区域：添加两个在左角对齐的视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PlaceAlignedViewsAtLeftCorner</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(ViewPlan));</span><br><span class="line">    <span class="keyword">var</span> viewPlans = fec.Cast().Where(vp =&gt; !vp.IsTemplate &amp;&amp; vp.ViewType == ViewType.CeilingPlan);</span><br><span class="line"></span><br><span class="line">    ViewPlan vp1 = viewPlans.ElementAt(<span class="number">0</span>);</span><br><span class="line">    ViewPlan vp2 = viewPlans.ElementAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Place on sheet&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add two viewports distinct from one another</span></span><br><span class="line">        ViewSheet vs = ViewSheet.Create(doc, ElementId.InvalidElementId);</span><br><span class="line">        Viewport viewport1 = Viewport.Create(doc, vs.Id, vp1.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        Viewport viewport2 = Viewport.Create(doc, vs.Id, vp2.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the necessary move vector to align the lower left corner</span></span><br><span class="line">        Outline outline1 = viewport1.GetBoxOutline();</span><br><span class="line">        Outline outline2 = viewport2.GetBoxOutline();</span><br><span class="line">        XYZ boxCenter = viewport2.GetBoxCenter();</span><br><span class="line">        XYZ vectorToCenter = boxCenter - outline2.MinimumPoint;</span><br><span class="line">        XYZ newCenter = outline1.MinimumPoint + vectorToCenter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the viewport to the new location</span></span><br><span class="line">        viewport2.SetBoxCenter(newCenter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XYZ位置参数标识添加的视图所在的位置。它指向添加的视图的中心坐标（以英寸为单位）。 坐标[0，0]是相对于工作表左下角的坐标。 在完整的图形集中，每张图纸都有唯一的图纸编号。该编号将显示在项目浏览器中图纸名称的前面。使用视图标题中的图纸编号可以方便地交叉参考图形集中的图纸。可以使用SheetNumber属性检索或修改编号。数字必须是唯一的;否则，当您将数字设置为重复值时，将引发异常。 下面的示例说明如何创建和打印工作表视图。开始，在文档中查找可用的标题栏（在本例中使用过滤器），然后使用它创建图纸视图。接下来，添加三维视图。视图将以其左下角位于图纸中心的方式放置。最后，通过调用View.Print（）方法打印工作表。</p>
<p>代码区域：创建图纸视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateSheetView</span>(<span class="params">Autodesk.Revit.DB.Document document, View3D view3D</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an available title block from document</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_TitleBlocks);</span><br><span class="line"></span><br><span class="line">    FamilySymbol fs = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">    <span class="keyword">if</span> (fs != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create a new ViewSheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create a sheet view</span></span><br><span class="line">                ViewSheet viewSheet = ViewSheet.Create(document, fs.Id);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == viewSheet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new ViewSheet.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add passed in view onto the center of the sheet</span></span><br><span class="line">                UV location = <span class="keyword">new</span> UV((viewSheet.Outline.Max.U - viewSheet.Outline.Min.U) / <span class="number">2</span>,</span><br><span class="line">                                        (viewSheet.Outline.Max.V - viewSheet.Outline.Min.V) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//viewSheet.AddView(view3D, location);</span></span><br><span class="line">                Viewport.Create(document, viewSheet.Id, view3D.Id, <span class="keyword">new</span> XYZ(location.U, location.V, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Print the sheet out</span></span><br><span class="line">                <span class="keyword">if</span> (viewSheet.CanBePrinted)</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">                    taskDialog.MainContent = <span class="string">&quot;Print the sheet?&quot;</span>;</span><br><span class="line">                    TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;</span><br><span class="line">                    taskDialog.CommonButtons = buttons;</span><br><span class="line">                    TaskDialogResult result = taskDialog.Show();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result == TaskDialogResult.Yes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        viewSheet.Print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                t.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                t.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能将工作表视图添加到另一个工作表，也不能将视图添加到多个工作表;否则会发生参数异常。</p>
<p>表单修订</p>
<p>ViewSheet类有几种用于处理图纸上的修订和云线批注的方法。</p>
<ul>
<li>GetAllRevisionIds（）-获取参与图纸修订明细表的修订的有序数组。</li>
<li>GetAdditionalRevisionIds（）-获取图纸修订明细表中额外包含的修订。SetAdditionalRevisionIds（）-设置要另外包含在图纸修订明细表中的修订。</li>
<li>GetCurrentRevision（）-返回此视图表中显示的最新编号版本。</li>
<li>GetRevisionCloudNumberOnSheet（）-当项目中的编号是按图纸编号时，获取此图纸上RevisionCloud的修订号。</li>
<li>GetRevisionNumberOnSheet（）-获取特定修订的修订号，当项目中的编号是按图纸编号时，该修订号将显示在此图纸上。</li>
</ul>
<p> 根据项目中的修订顺序对修订进行排序。附加包含的修订将始终参与图纸的修订明细表。通常，修订明细表中会列出修订明细表，因为其关联的RevisionClouds之一存在于图纸中。 下面的代码示例演示如何向图纸添加与给定条件匹配的其他修订。</p>
<p>代码区域：向图纸添加其他修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAdditionalRevisionsToSheet</span>(<span class="params">ViewSheet viewSheet, String toMatch</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = viewSheet.Document;</span><br><span class="line"></span><br><span class="line">    ICollection revisions = viewSheet.GetAdditionalRevisionIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find revisions whose description matches input string</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_Revisions);</span><br><span class="line">    collector.WhereElementIsNotElementType();</span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">        collector.Excluding(revisions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if revision should be added</span></span><br><span class="line">    <span class="keyword">foreach</span> (Element revision <span class="keyword">in</span> collector)</span><br><span class="line">    &#123;</span><br><span class="line">        Parameter descriptionParam = revision.get_Parameter(BuiltInParameter.PROJECT_REVISION_REVISION_DESCRIPTION);</span><br><span class="line">        String description = descriptionParam.AsString();</span><br><span class="line">        <span class="keyword">if</span> (description.Contains(toMatch))</span><br><span class="line">            revisions.Add(revision.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Apply the new list of revisions</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add revisions to sheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            viewSheet.SetAdditionalRevisionIds(revisions);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印机设置"><a href="#打印机设置" class="headerlink" title="打印机设置"></a>打印机设置</h4><p>在打印纸张之前，您可能需要更改打印机的设置。API使用PrintManager类和相关的Autodesk. Revit. DB类公开打印机的设置：</p>
<table>
<thead>
<tr>
<th><strong>Class 类</strong></th>
<th><strong>Functionality 功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.PrintManager</td>
<td>表示Revit UI中“打印”对话框（文件-&gt;Print）中的打印信息。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintParameters</td>
<td>包含用于打印文档的设置的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetup</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSize</td>
<td>表示Autodesk Revit项目中打印设置纸张尺寸的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSizeSet</td>
<td>可以包含任意数量的纸张大小对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSource</td>
<td>表示Autodesk Revit项目中打印设置的纸张来源的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSourceSet</td>
<td>可以包含任意数量纸张源对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ViewSheetSetting</td>
<td>表示Revit UI中的视图&#x2F;图纸集（文件-&gt;Print）。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetting</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
</tbody></table>
<p>有关使用这些对象的代码示例，请参见随Revit Platform SDK提供的ViewPrinter示例应用程序。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>此类表示显示数据表的视图。</p>
<p>TableView是ViewSchedule和PanelScheduleView的基类。</p>
<p>本节中的页面</p>
<ul>
<li>Schedule Classes 明细表类</li>
<li>ViewSchedule 视图明细表</li>
<li>PanelScheduleView 配电盘明细表</li>
</ul>
<h4 id="明细表类"><a href="#明细表类" class="headerlink" title="明细表类"></a>明细表类</h4><p>明细表视图使用多个支持类。</p>
<p>TableView是一个表示显示表的视图的类，它是ViewSchedule和PanelScheduleView的基类。它有一个关联的TableData类，其中包含一个或多个节。对于ViewSchedule，只有一个页眉和一个正文部分。</p>
<p>TableSectionData类表示按行和列排列的一组连续单元格。对于ViewSchedule，TableSectionData的单元格内容由ScheduleDefinition和参数生成。此外，对于ViewSchedules，虽然头部分具有读&#x2F;写权限，但主体部分是只读的。</p>
<h5 id="使用明细表中的数据"><a href="#使用明细表中的数据" class="headerlink" title="使用明细表中的数据"></a>使用明细表中的数据</h5><p>表的实际数据包含在TableData类中。虽然无法直接从TableView类获取TableData对象，但两个子类都有GetTableData（）方法。对于ViewSchedule，此方法返回一个TableData对象。对于PanelScheduleView，GetTableData（）返回PanelScheduleData对象，该对象派生自TableData基类。TableData类保存描述表中行、列和单元格样式的大部分数据。PanelScheduleData提供了专门与配电盘明细表相关的其他方法。</p>
<p>使用行、列和单元格<br>表中的数据被分解为多个部分。要使用TableData的行、列和单元格，需要获取TableSectionData对象。GetSectionData（）可以使用请求的节数据的整数或使用SectionType（即Header或Body）调用。</p>
<p>TableSectionData类可用于插入或删除行或列，格式化单元格，以及获取组成该明细表部分的单元格的详细信息，例如单元格类型（即文本或图形）或单元格的类别ID。</p>
<p>在下面的示例中，将新行添加到明细表的页眉部分，并为新创建的单元格设置文本。请注意，在使用UI创建时，页眉部分的第一行默认为标题。</p>
<p>代码区域：插入行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSubtitle</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = schedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    tsd.InsertRow(tsd.FirstRowNumber + <span class="number">1</span>);</span><br><span class="line">    tsd.SetCellText(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, <span class="string">&quot;Schedule of column top and base levels with offsets&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另请注意，在上面的代码示例中，它使用了FirstRowNumber和FirstColumnNumber属性。在某些部分中，行或列编号可能以0开头，也可能以1开头。这些属性应始终用于代替硬编码的0或1。 在下面的示例中，将创建一个带有自定义页眉节的新单类别明细表。</p>
<p>代码区域：自定义标题部分</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithSimpleHeaderSection</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with custom headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get header section</span></span><br><span class="line">        TableSectionData data = vs.GetTableData().GetSectionData(SectionType.Header);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rowNumber = data.LastRowNumber;</span><br><span class="line">        <span class="built_in">int</span> columnNumber = data.LastColumnNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the overall width of the table so that the new columns can be resized properly</span></span><br><span class="line">        <span class="built_in">double</span> tableWidth = data.GetColumnWidth(columnNumber);</span><br><span class="line"></span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Refresh data to be sure that schedule is ready for text insertion</span></span><br><span class="line">        vs.RefreshData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set text to the first header cell</span></span><br><span class="line">        data.SetCellText(rowNumber, data.FirstColumnNumber, <span class="string">&quot;Special Window Schedule Text&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set width of first column</span></span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set a different parameter to the second cell - the project name</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.FirstRowNumber + <span class="number">1</span>, <span class="keyword">new</span> ElementId(BuiltInParameter.PROJECT_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ProjectInformation));</span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber + <span class="number">1</span>, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the third column as the schedule view name - use the special category for schedule parameters for this</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.LastColumnNumber, <span class="keyword">new</span> ElementId(BuiltInParameter.VIEW_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ScheduleViewParamGroup));</span><br><span class="line">        data.SetColumnWidth(data.LastColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为明细表自定义行、列或单个单元格的样式。这包括为单元格的所有四边设置边框线样式，以及单元格颜色和文本外观（即颜色，字体，大小）的能力。对于常规计划，只能在表格的标题部分执行此操作。 在下面的示例中，ViewSchedule的副标题（假定为标题部分的第二行）的字体设置为粗体，字体大小设置为10。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatSubtitle</span>(<span class="params">ViewSchedule colSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = colSchedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    <span class="comment">// Subtitle is second row, first column</span></span><br><span class="line">    <span class="keyword">if</span> (tsd.AllowOverrideCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber))</span><br><span class="line">    &#123;</span><br><span class="line">        TableCellStyle tcs = <span class="keyword">new</span> TableCellStyle();</span><br><span class="line">        TableCellStyleOverrideOptions options = <span class="keyword">new</span> TableCellStyleOverrideOptions();</span><br><span class="line">        options.FontSize = <span class="literal">true</span>;</span><br><span class="line">        options.Bold = <span class="literal">true</span>;</span><br><span class="line">        tcs.SetCellStyleOverrideOptions(options);</span><br><span class="line">        tcs.IsFontBold = <span class="literal">true</span>;</span><br><span class="line">        tcs.TextSize = <span class="number">10</span>;</span><br><span class="line">        tsd.SetCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, tcs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图明细表"><a href="#视图明细表" class="headerlink" title="视图明细表"></a>视图明细表</h4><p>明细表是数据的表格表示形式。典型明细表显示类别的所有图元（门、房间等）。每行表示一个元素，每列表示一个参数。</p>
<p>ViewSchedule类表示明细表和其他类似明细表的视图，包括单类别和多类别明细表、关键字明细表、材质提取、视图列表、图纸列表、注释记号图例、修订明细表和注释块。</p>
<p>ViewSchedule.Export（）方法将日程数据导出到文本文件中。</p>
<p>在图纸上放置明细表</p>
<p>静态ScheduleSheetInstance.Create（）方法在工作表上创建明细表的实例。它需要要放置明细表的图纸的ID、明细表视图的ID以及要放置明细表的图纸上的XYZ位置。ScheduleSheetInstance对象具有用于访问生成此ScheduleSheetInstance的“主”明细表的ID、明细表在图纸上的旋转、明细表在图纸上的放置位置（在图纸坐标中）以及标识ScheduleSheetInstance是否为标题栏族中的修订明细表的标志的属性。</p>
<p>本节中的页面</p>
<ul>
<li>创建明细表</li>
<li>使用视图明细表</li>
</ul>
<h5 id="创建明细表"><a href="#创建明细表" class="headerlink" title="创建明细表"></a>创建明细表</h5><p>ViewSchedule类有几种方法用于根据计划类型创建新明细表。所有这些方法都有一个Document参数，该参数是要向其中添加新明细表或类似明细表的视图的文档。新创建的明细表视图将显示在项目浏览器中的“明细表&#x2F;明细表”节点下。</p>
<p>标准的单类别或多类别明细表可以用静态ViewSchedule. fullSchedule（）方法创建。</p>
<p>代码区域：创建具有2个字段的单一类别明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategorySchedule</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create schedule</span></span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add fields to the schedule</span></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Adds a single parameter field to the schedule</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的类别的ID，或者是多类别明细表的InvalidElementId。 第二个RISKSchedule（）方法可用于创建面积明细表，并接受一个附加参数，即明细表的面积方案ID。</p>
<p>代码区域：创建面积明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">collector.OfCategory(BuiltInCategory.OST_AreaSchemes);</span><br><span class="line"><span class="comment">//Get first ElementId of AreaScheme.</span></span><br><span class="line">ElementId areaSchemeId = collector.FirstElementId();</span><br><span class="line"><span class="keyword">if</span> (areaSchemeId != <span class="literal">null</span> &amp;&amp; areaSchemeId != ElementId.InvalidElementId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If you want to create an area schedule, you must use CreateSchedule method with three arguments. </span></span><br><span class="line">    <span class="comment">// The value of the second argument must be ElementId of BuiltInCategory.OST_Areas category</span></span><br><span class="line">    <span class="comment">// and the value of third argument must be ElementId of an AreaScheme.</span></span><br><span class="line">    areaSchedule = Autodesk.Revit.DB.ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Areas), areaSchemeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字明细表显示抽象的“关键”元素，这些元素可用于填充普通模型元素的参数，并且可以使用静态ViewSchedule.CreateKeySchedule（）方法创建，该方法的第二个参数是明细表的关键字将与之关联的元素类别的ID。材料提取是一个明细表，显示有关构成模型中元素的材料的信息。与每行（分组前）表示单个元素的常规明细表不同，材料提取中的每行表示单个&lt;元素、材料&gt;对。ViewSchedule. AccessMaterialTakeoff（）方法具有与ViewSchedule. AccessSchedule（）方法相同的参数，并且允许单类别和多类别材质提取明细表。 视图列表、图纸列表和注释记号图例与指定类别相关联，因此它们的创建方法将类别ID作为参数。视图列表是项目中视图的明细表。它是视图类别的明细表，使用ViewSchedule. ViewList（）创建。 图纸列表是项目中图纸的明细表。它是“图纸”类别的明细表，使用ViewSchedule. SetSheetList（）方法创建。 注释记号图例是“注释记号标记”类别的明细表，可使用ViewSchedule.CreateKeynoteLegend（）创建。 修订明细表将添加到标题栏族中，并作为图纸上标题栏的一部分可见。如果传入的文档不是标题栏族，ViewSchedule. RevisionSchedule（）方法将引发异常。 注释块是“常规注释”类别的明细表，它显示单个族的图元，而不是类别中的所有图元。</p>
<p>代码区域：ViewSchedule. NoteBlock（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSchedule ViewSchedule.CreateNoteBlock(Document document, ElementId familyId);</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的族的ID。</p>
<p>代码区域：创建注释块明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Creating Note BLock&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Get first ElementId of a Note Block family.</span></span><br><span class="line">    ICollection noteblockFamilies = ViewSchedule.GetValidFamiliesForNoteBlock(doc);</span><br><span class="line">    ElementId symbolId = noteblockFamilies.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symbolId.Equals(ElementId.InvalidElementId))</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create a note-block view schedule.</span></span><br><span class="line">        noteBlockSchedule = ViewSchedule.CreateNoteBlock(doc, symbolId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != areaSchedule)</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transaction.RollBack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用ViewSchedule"><a href="#使用ViewSchedule" class="headerlink" title="使用ViewSchedule"></a>使用ViewSchedule</h5><p>ScheduleDefinition类帮助定义ViewSchedule。</p>
<p>ScheduleDefinition类包含与明细表视图内容相关的各种设置，包括：</p>
<ul>
<li>明细表的类别和其他确定明细表类型的基本属性。</li>
<li>成为明细表列的一组字段。</li>
<li>排序和分组标准。</li>
<li>限制明细表中可见图元集的过滤器。</li>
<li>控制标题和&#x2F;或页眉可见性的设置。</li>
</ul>
<p>大多数计划都包含一个通过ViewSchedule.Definition属性检索的ScheduleDefinition。在Revit中，某些类别的明细表可以包含一个“嵌入式明细表”，其中包含与主明细表中的图元相关联的图元，例如，显示每个房间内图元的房间明细表或显示与每个系统相关联的图元的风管系统明细表。嵌入的计划有自己的类别、字段、过滤器等。这些设置存储在第二个ScheduleDefinition对象中。如果存在，则从ScheduleDefinition.EmbeddedDefinition属性获取嵌入的ScheduleDefinition。</p>
<h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h6><p>创建视图明细表后，可以添加字段。ScheduleDefinition. GetControlableFields（）方法将返回一个ControlableField对象的列表，这些对象表示可能包含在计划中的非计算字段。新字段可以从可扩展字段对象或使用ScheduleFieldType添加。下表描述了可从ScheduleFieldType枚举中使用的选项。</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Instance</td>
<td>明细表图元的实例参数。所有共享参数也都使用此类型，无论它们是实例参数还是类型参数。</td>
</tr>
<tr>
<td>ElementType</td>
<td>明细表图元的类型参数。</td>
</tr>
<tr>
<td>Count</td>
<td>明细表行上显示的图元数。</td>
</tr>
<tr>
<td>ViewBased</td>
<td>用于一些参数的专用字段类型，这些参数的显示值可以根据视图的设置而更改：<em>房间明细表和空间明细表中的ROOM_AREA和ROOM_PERIMETER。</em>修订明细表中的PROJECT_REVISION_REVISION_NUM。<em>注释记号图例中按图纸编号的KEYNOTE_NUMBER。</em></td>
</tr>
<tr>
<td>Formula</td>
<td>根据明细表中其他字段的值计算的公式。</td>
</tr>
<tr>
<td>Percentage</td>
<td>一个值，指示每个元素表示的另一个字段的总和的百分比。</td>
</tr>
<tr>
<td>Room</td>
<td>明细表图元所属房间的参数。</td>
</tr>
<tr>
<td>FromRoom</td>
<td>门或窗的“从”侧房间的参数。</td>
</tr>
<tr>
<td>ToRoom</td>
<td>门或窗“向”侧的房间参数。</td>
</tr>
<tr>
<td>ProjectInfo</td>
<td>明细表图元所属项目中的“项目信息”图元的参数，可以是链接文件。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>Material</td>
<td>在材质提取中，明细表图元的一种材质的参数。</td>
</tr>
<tr>
<td>MaterialQuantity</td>
<td>在材质提取中，表示如何在明细表图元中使用特定材质的值。参数ID可以是MATERIAL_AREA、MATERIAL_VOLUME或MATERIAL_ASPAINT。</td>
</tr>
<tr>
<td>RevitLinkInstance</td>
<td>链接文件中的元素所属的RevitLinkInstance的参数。当前，RVT_LINK_RELANCE_NAME是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>RevitLinkType</td>
<td>链接文件中的元素所属的RevitLinkType的参数。当前，RVT_LINK_FILE_NAME_WITHOUT_EXT是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>StructuralMaterial</td>
<td>明细表图元的结构材质参数。</td>
</tr>
<tr>
<td>Space</td>
<td>明细表图元所属空间的参数。</td>
</tr>
</tbody></table>
<p>使用一个ScheduleDefinition.AddField（）方法将把字段添加到字段列表的末尾。若要将新字段放置在字段列表中的特定位置，请使用ScheduleDefinition.InsertField（）方法之一。还可以在事后使用ScheduleDefinition.SetFieldOrder（）对字段进行排序。 下面是一个简单的示例，显示了如何在视图明细表中没有字段的情况下向视图添加字段。</p>
<p>代码区域：向明细表添加字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Add fields to view schedule.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> List of view schedule.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFieldToSchedule</span>(<span class="params">List schedules</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList schedulableFields = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ViewSchedule vs <span class="keyword">in</span> schedules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Get all schedulable fields from view schedule definition.</span></span><br><span class="line">        schedulableFields = vs.Definition.GetSchedulableFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (SchedulableField sf <span class="keyword">in</span> schedulableFields)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> fieldAlreadyAdded = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//Get all schedule field ids</span></span><br><span class="line">            IList ids = vs.Definition.GetFieldOrder();</span><br><span class="line">            <span class="keyword">foreach</span> (ScheduleFieldId id <span class="keyword">in</span> ids)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//If the GetSchedulableField() method of gotten schedule field returns same schedulable field,</span></span><br><span class="line">                <span class="comment">// it means the field is already added to the view schedule.</span></span><br><span class="line">                <span class="keyword">if</span> (vs.Definition.GetField(id).GetSchedulableField() == sf)</span><br><span class="line">                &#123;</span><br><span class="line">                    fieldAlreadyAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//If schedulable field doesn&#x27;t exist in view schedule, add it.</span></span><br><span class="line">            <span class="keyword">if</span> (fieldAlreadyAdded == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vs.Definition.AddField(sf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduleField类表示ScheduleDefinition的字段列表中的单个字段。每个（非隐藏）字段都将成为明细表中的一列。 最常见的情况是，字段表示明细表中出现的图元的实例或类型参数。某些字段表示其他相关图元的参数，如明细表图元所属的房间。字段还可以表示从明细表中的其他字段（特别是公式和百分比字段）计算的数据。 ScheduleField类具有控制列标题（包括文本和方向）的属性。也可以定义列内文本的列宽和水平对齐方式。 ScheduleField.IsHidden属性可用于隐藏字段。隐藏字段不显示在明细表中，但可用于筛选、排序、分组和条件格式设置，并且可由公式和百分比字段引用。</p>
<p>DisplayType</p>
<p>ScheduleField有一个DisplayType属性，用于指示字段的显示类型。可能的值为： 标准-如果元素的值不同，则不显示任何内容，否则将显示公共值总计-计算并显示总计值最小值最大值-计算并显示最小值和最大值最小值-计算并显示最大值最大值-计算并显示最小值 方法指示此字段是否可以显示最小值和最大值。 在非分项明细表中，当多个图元显示在同一行中时，非标准显示类型的值将显示在常规行中。 #字段的样式和格式 ScheduleField.GetStyle（）和ScheduleField.SetStyle（）使用TableCellStyle类来处理明细表中字段的样式。使用SetStyle（），可以设置字段的各种属性，包括单元格边框的线条样式以及文本字体、颜色和大小。 ScheduleField. SetOptions（）和ScheduleField. GetOptions（）使用DataOptions类来处理字段数据的格式。FormatOptions类包含控制如何将数字与单位格式化为字符串的设置。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置。 在以下示例中，ViewSchedule中的所有长度字段都设置为以英尺和小数英寸为单位显示。</p>
<p>代码区域：格式化字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// format length units to display in feet and inches format</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatLengthFields</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nFields = schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; nFields; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleField field = schedule.Definition.GetField(n);</span><br><span class="line">        <span class="keyword">if</span> (field.UnitType == UnitType.UT_Length)</span><br><span class="line">        &#123;</span><br><span class="line">            FormatOptions formatOpts = <span class="keyword">new</span> FormatOptions();</span><br><span class="line">            formatOpts.UseDefault = <span class="literal">false</span>;</span><br><span class="line">            formatOpts.DisplayUnits = DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES;</span><br><span class="line">            field.SetFormatOptions(formatOpts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例将格式和样式重写应用于给定字段。</p>
<p>代码区域：对字段应用格式和样式重写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ApplyFormattingToField</span>(<span class="params">ViewSchedule schedule, <span class="built_in">int</span> fieldIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the field.</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField field = definition.GetField(fieldIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build unit formatting for the field.</span></span><br><span class="line">    FormatOptions options = field.GetFormatOptions();</span><br><span class="line">    options.UseDefault = <span class="literal">false</span>;</span><br><span class="line">    options.DisplayUnits = DisplayUnitType.DUT_SQUARE_INCHES;</span><br><span class="line">    options.UnitSymbol = UnitSymbolType.UST_IN_SUP_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build style overrides for the field</span></span><br><span class="line">    <span class="comment">// Use override options to indicate fields that are overridden and apply changes</span></span><br><span class="line">    TableCellStyle style = field.GetStyle();</span><br><span class="line">    TableCellStyleOverrideOptions overrideOptions = style.GetCellStyleOverrideOptions();</span><br><span class="line">    overrideOptions.BackgroundColor = <span class="literal">true</span>;</span><br><span class="line">    style.BackgroundColor = <span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.FontColor = <span class="literal">true</span>;</span><br><span class="line">    style.TextColor = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.Italics = <span class="literal">true</span>;</span><br><span class="line">    style.IsFontItalic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    style.SetCellStyleOverrideOptions(overrideOptions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> width = field.GridColumnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Set style etc&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        field.SetStyle(style);</span><br><span class="line">        field.SetFormatOptions(options);</span><br><span class="line">        <span class="comment">// Change column width (affects width in grid and on sheet) - units are in Revit length units - ft.</span></span><br><span class="line">        field.GridColumnWidth = width + <span class="number">0.5</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="标题和标头"><a href="#标题和标头" class="headerlink" title="标题和标头"></a>标题和标头</h6><p>明细表标题和&#x2F;或页眉的显示是可选的。是否显示标题或标头可以使用ScheduleDefinition属性ShowTitle和ShowHeaders控制。</p>
<h6 id="明细表中的查询和排序"><a href="#明细表中的查询和排序" class="headerlink" title="明细表中的查询和排序"></a>明细表中的查询和排序</h6><p>可以按计划的一个或多个字段对计划进行排序或分组。有几种方法可用于控制字段的分组和排序。ScheduleSortGroupField类表示用于对计划进行排序或分组的字段之一。排序和分组是相关的操作。无论哪种情况，明细表中出现的元素都将根据其字段值进行排序，明细表将根据该字段值进行排序&#x2F;分组，这会自动将具有相同值的元素分组在一起。通过启用额外的页眉、页脚或空白行，可以实现组之间的视觉分隔。</p>
<p>如果ScheduleDefinition.IsItemized属性为false，则用于排序&#x2F;分组的所有字段具有相同值的元素将合并到同一行中。否则，明细表将在单独的行中显示每个元素</p>
<p>通过使用ScheduleField.IsHidden属性将用于排序&#x2F;分组的字段标记为隐藏，可以按计划中未显示的数据对计划进行排序或分组。</p>
<p>代码区域：将分组&#x2F;排序添加到计划</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGroupingToSchedule</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum, <span class="built_in">bool</span> withTotalsAndDecoration, ScheduleSortOrder order</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find field </span></span><br><span class="line">    ScheduleField field = FindField(schedule, paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to find field.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build sort/group field.</span></span><br><span class="line">    ScheduleSortGroupField sortGroupField = <span class="keyword">new</span> ScheduleSortGroupField(field.FieldId, order);</span><br><span class="line">    <span class="keyword">if</span> (withTotalsAndDecoration)</span><br><span class="line">    &#123;</span><br><span class="line">        sortGroupField.ShowFooter = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterTitle = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterCount = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowHeader = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowBlankLine = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the sort/group field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add sort/group field&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        definition.AddSortGroupField(sortGroupField);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标头也可以分组。GroupHeaders（）方法可用于指定在标题部分的分组中包括哪些行和列。最后一个参数是一个字符串，表示分组的行和列的标头。 在下面的示例中，将为新创建的单类别明细表对列进行分组。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithGroupedColumnHeaders</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with grouped column headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build the schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Group the headers in the body section using ViewSchedule methods</span></span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;Size&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;All&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h6><p>可使用“明细表过滤器”来过滤将在明细表中显示的图元。过滤器是要使图元显示在明细表中必须满足的条件。要使图元显示在明细表中，必须满足所有筛选条件。</p>
<p>通过使用ScheduleField.IsHidden属性将用于筛选的字段标记为隐藏，可以按未显示在计划中的数据筛选计划。</p>
<p>代码区域：将筛选器添加到计划</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddFilterToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId levelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find level field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    ScheduleField levelField = FindField(schedule, BuiltInParameter.ROOM_LEVEL_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add filter</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If field not present, add it</span></span><br><span class="line">        <span class="keyword">if</span> (levelField == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            levelField = definition.AddField(ScheduleFieldType.Instance, <span class="keyword">new</span> ElementId(BuiltInParameter.ROOM_LEVEL_ID));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set field to hidden</span></span><br><span class="line">        levelField.IsHidden = <span class="literal">true</span>;</span><br><span class="line">        ScheduleFilter filter = <span class="keyword">new</span> ScheduleFilter(levelField.FieldId, ScheduleFilterType.Equal, levelId);</span><br><span class="line">        definition.AddFilter(filter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds an existing ScheduleField matching the given parameter</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用明细表数据"><a href="#使用明细表数据" class="headerlink" title="使用明细表数据"></a>使用明细表数据</h6><p>下面的示例说明如何确定明细表中的图元列表。</p>
<p>代码区域：获取计划的内容</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetScheduleContents</span>(<span class="params">ViewSchedule viewSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Collect types displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector typeCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    typeCollector.WhereElementIsElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfTypes = typeCollector.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect instances displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector instCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    instCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfInstances = instCollector.Count();</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Elements in schedule&quot;</span>, String.Format(<span class="string">&quot;Types &#123;0&#125; instances &#123;1&#125;&quot;</span>, numberOfTypes, numberOfInstances));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使用明细表中的实际数据，ViewSchedule.GetTableData（）返回一个TableData对象，该对象包含描述表中行、列和单元格的样式和内容的大部分数据。更多信息可以在TableView中找到。</p>
<h4 id="配电盘明细表"><a href="#配电盘明细表" class="headerlink" title="配电盘明细表"></a>配电盘明细表</h4><p>PanelScheduleView表示配电盘明细表，其中显示有关配电盘、连接到配电盘的线路及其相应负荷的信息。</p>
<p>可以创建一个明细表，其中列出连接到配电盘的线路，并显示有关每个线路的信息，例如配电盘上的位置、线路名称和视在负荷。配电盘明细表显示四个主要信息部分：页眉、线路表、负荷汇总和页脚。选定配电盘的新配电盘明细表视图将显示在绘图区域中，并且配电盘明细表将添加到项目浏览器的“配电盘明细表”文件夹下。配电盘明细表显示以下数据：</p>
<ul>
<li>面板名称</li>
<li>配电盘支持的配电系统</li>
<li>面板上可用的相数</li>
<li>为分配给此配电盘的配电系统指定的导线数</li>
<li>配电盘供电电源的额定值</li>
<li>安装类型（表面或嵌入式）</li>
<li>嵌板外壳类型</li>
<li>安装面板的房间</li>
<li>分配给负载电路的名称</li>
<li>断路器的额定跳闸电流</li>
<li>断路器上的极数</li>
<li>电路号</li>
<li>Phases 阶段</li>
<li>各相视在负荷（VA）</li>
<li>所有三相的总视在负荷</li>
<li>制造商</li>
<li>对面板进行的任何更改的注释</li>
<li>均方根安培数要显示的其他回路和配电盘信息可以在配电盘明细表样板中指定，在Revit API中由PanelScheduleTemplate类表示。</li>
</ul>
<p>PanelScheduleView和ViewSchedule一样，都是从TableView类派生的。明细表和配电盘明细表之间的一些常用功能可以在“明细表类”主题中找到。</p>
<h6 id="配电盘明细表创建"><a href="#配电盘明细表创建" class="headerlink" title="配电盘明细表创建"></a>配电盘明细表创建</h6><p>有两种用于创建PanelScheduleView的静态重载。PanelScheduleView. rnInstanceView（）的一个重载只需要在其中创建配电盘明细表的文档以及与明细表关联的电气配电盘元素的ID。此方法使用默认配电盘明细表样板创建新视图。另一个重载接受要使用的特定PanelScheduleTemplate的ID。</p>
<p>以下示例使用默认样板从用户选择的配电盘创建新配电盘明细表，并将活动视图切换到新配电盘明细表视图。</p>
<p>代码区域：创建配电盘明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new panel schedule and switch to that view</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatePanelSchedule</span>(<span class="params">UIDocument uiDocument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDocument.Document;</span><br><span class="line"></span><br><span class="line">    Reference selected = uiDocument.Selection.PickObject(ObjectType.Element, <span class="string">&quot;Select an electrical panel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element panel = doc.GetElement(selected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != panel)</span><br><span class="line">    &#123;</span><br><span class="line">        PanelScheduleView psv = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a new panel schedule&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            trans.Start();</span><br><span class="line">            psv = PanelScheduleView.CreateInstanceView(doc, panel.Id);</span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != psv)</span><br><span class="line">        &#123;</span><br><span class="line">            uiDocument.ActiveView = psv;    <span class="comment">// make new view the active view</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Please select one electrical panel.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用配电盘明细表"><a href="#使用配电盘明细表" class="headerlink" title="使用配电盘明细表"></a>使用配电盘明细表</h6><p>创建计划后，您可能需要对其进行修改。有几种方法有助于在计划中移动数据。若要移动数据，请使用PanelScheduleView.GetCellsBySlotNumber（）获取指定插槽号的单元格范围。PanelScheduleView.MoveSlotTo（）将源插槽中的回路移动到特定插槽。在移动回路之前，调用PanelScheduleView.CanMoveSlotTo（）以确保允许移动。</p>
<p>如果移动回路在一个组中，则该组中的所有回路都将相应地移动。IsSlotGrouped（）方法将检查插槽是否在组中。如果插槽不在组中，则此方法返回0。如果它在一个组中，则返回的值为组号（大于0的值）。</p>
<h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p>Revit API提供了多个类和成员，用于访问项目修订、其设置和关联的云线批注。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>RevisionSettings类允许应用程序读取和修改影响修订和修订云线的项目范围设置。静态RevisionSettings.GetRevisionSettings（）方法返回给定项目文档的RevisionSettings对象。以下属性可用于访问项目范围的修订设置：</p>
<ul>
<li><p>RevisionCloudSpacing -确定项目中绘制的云线批注在图纸空间中的大小。</p>
</li>
<li><p>修订编号-确定项目的修订编号是按每张图纸还是按整个项目确定。AlphanumericRevisionSettings类包含应用于具有Alphanumeric RevisionNumberType的修订的设置。RevisionSettings方法GetAlphanumericRevisionSettings（）和SetAlphanumericRevisionSettings（）提供对AlphanumericRevisionSettings的读写访问。AlphanumericRevisionSettings提供以下成员：</p>
</li>
<li><p>前缀-前缀将被添加到每个版本号与字母数字类型。</p>
</li>
<li><p>后缀-要附加到每个版本号的字母数字类型的后缀。</p>
</li>
<li><p>GetSequence（）-获取字符串列表，这些字符串将用作字母数字类型的修订的编号序列。</p>
</li>
<li><p>SetSequence（）-设置此类型的修订编号的字符串列表。同样，NumericRevisionSettings类包含应用于具有Numeric</p>
</li>
</ul>
<p>RevisionNumberType的修订的设置。RevisionSettings方法GetNumericRevisionSettings（）和SetNumericRevisionSettings（）提供对这些设置的读写访问。NumericRevisionSettings提供以下成员：</p>
<ul>
<li>Prefix -每个版本号前面的数字类型前缀。</li>
<li>Suffix -要附加到每个版本号的数字类型的后缀。</li>
<li>StartNumber Property-用作数字修订序列中第一个数字的值。</li>
</ul>
<p>当修订云线显示在图纸上时，可以通过标记修订云线或通过图纸标题栏中的修订明细表来显示每个修订的修订编号。有两种方法可以确定数量：</p>
<p><strong>每个项目</strong>：版本号的值将始终对应于分配给该版本的项目范围的版本序号。例如，如果将序号为5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示5、7和8。</p>
<p><strong>每张图纸</strong>：将根据图纸上可见的修订云线为修订编号分配连续编号。例如，如果将指定了项目范围修订序号5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示1、2和3。图纸上的序列仍将遵循修订序列号的相对顺序，因此在本例中，修订5将在图纸上显示为1，修订7将显示为2，依此类推。</p>
<p>Revision类允许应用程序读取和修改项目中的现有修订以及创建新修订。Revision对象表示与项目中的单个修订相关的数据。它具有IssuedBy、IssuedTo、RevisionNumber、SequenceNumber和RevisionDate等属性。云线批注和标记可以与特定Revision对象关联，以在图纸上显示其特性。</p>
<p>项目中的修订以称为修订顺序的特定顺序存储。修订顺序表示将发布修订的概念顺序。静态方法Revision.GetAllRevisionIds（）将按此顺序返回所有Revision的ID。静态方法Revision.ReorderRevisionSequence（）可用于更改项目的修订顺序。请注意，新指定的序列必须只包含项目中的每个修订一次，并且更改修订的序列可能会更改已发布的修订的SequenceNumber和RevisionNumber。</p>
<p>静态Create（）方法将在指定的文档中创建一个新的Revision。在下面的示例中，添加了多个修订并设置了它们的属性。</p>
<p>代码区域：创建新修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList <span class="title">AddRevisions</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList newRevisions = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">using</span> (Transaction createRevision = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;createRevision&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        createRevision.Start();</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Include door tags&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">1</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Add a section view&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">2</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Make callout view larger&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">3</span>, DateTime.Now));</span><br><span class="line">        createRevision.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRevisions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">AddNewRevision</span>(<span class="params">Document document, <span class="built_in">string</span> description, <span class="built_in">string</span> issuedBy, <span class="built_in">string</span> issuedTo, <span class="built_in">int</span> sequenceNumber, DateTime date</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision newRevision = Revision.Create(document);</span><br><span class="line">    newRevision.Description = description;</span><br><span class="line">    newRevision.IssuedBy = issuedBy;</span><br><span class="line">    newRevision.IssuedTo = issuedTo;</span><br><span class="line">    newRevision.NumberType = RevisionNumberType.Alphanumeric;</span><br><span class="line">    newRevision.RevisionDate = date.ToShortDateString();</span><br><span class="line">    <span class="keyword">return</span> newRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CombineWithNext（）和CombineWithPrevious（）这两个方法允许应用程序将指定的Revision与模型中的下一个或上一个Revision合并。合并修订意味着与指定修订相关联的修订云和修订标签将与下一个修订重新关联，并且指定修订将从模型中删除。此方法返回重新关联的RevisionClouds的ID。但是，这些操作只能在两个修订版本都未发布的情况下实施。 下面的示例演示CombineWithNext（）方法的用法。它还使用GetAllRevisionIds（）方法查找下一个修订，以确保CombineWithNext（）方法成功。</p>
<p>代码区域：合并修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CombineRevision</span>(<span class="params">Document document, Revision revision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> combined = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Can only combine two revisions if neither have been issued</span></span><br><span class="line">    <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId revisionId = revision.Id;</span><br><span class="line">        Revision nextRevsion = GetNextRevision(document, revisionId);</span><br><span class="line">        <span class="keyword">if</span> (nextRevsion != <span class="literal">null</span> &amp;&amp; nextRevsion.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet revisionCloudIds = Revision.CombineWithNext(document, revisionId);</span><br><span class="line">            combined = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">int</span> movedClouds = revisionCloudIds.Count;</span><br><span class="line">            <span class="keyword">if</span> (movedClouds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RevisionCloud cloud = document.GetElement(revisionCloudIds.ElementAt(<span class="number">0</span>)) <span class="keyword">as</span> RevisionCloud;</span><br><span class="line">                <span class="keyword">if</span> (cloud != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Revision &#123;0&#125; deleted and &#123;1&#125; revision clouds were added to Revsion &#123;2&#125;&quot;</span>,</span><br><span class="line">                        revisionId.ToString(), movedClouds, cloud.RevisionId.ToString());</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revision Combined&quot;</span>, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">GetNextRevision</span>(<span class="params">Document document, ElementId currentRevisionId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision nextRevision = <span class="literal">null</span>;</span><br><span class="line">    IList revisionIds = Revision.GetAllRevisionIds(document);</span><br><span class="line">    <span class="built_in">int</span> currentRevisionIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; revisionIds.Count; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (revisionIds[n] == currentRevisionId)</span><br><span class="line">        &#123;</span><br><span class="line">            currentRevisionIndex = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the current revision id was found and is not the last index</span></span><br><span class="line">    <span class="keyword">if</span> (currentRevisionIndex &gt;= <span class="number">0</span> &amp;&amp; currentRevisionIndex &lt; revisionIds.Count - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId nextRevisionId = revisionIds[currentRevisionIndex + <span class="number">1</span>];</span><br><span class="line">        nextRevision = document.GetElement(nextRevisionId) <span class="keyword">as</span> Revision;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线"><a href="#修订云线" class="headerlink" title="修订云线"></a>修订云线</h3><p>RevisionCloud是一种图形化的“云”，可以显示在视图或图纸上，以指示模型中发生修订的位置。RevisionCloud类允许应用程序访问有关模型中存在的云线批注的信息，并创建新的云线批注。</p>
<p>RevisionCloud是特定于视图的，可以在大多数图形视图中创建，但3D视图除外。</p>
<p>另请注意，当在ViewLegend中创建RevisionCloud时，它会被视为RevisionCloud外观的图例表示，而不是模型更改的实际指示。因此，ViewLegends中的RevisionClouds不会影响修订明细表的内容。</p>
<h3 id="创建云线批注"><a href="#创建云线批注" class="headerlink" title="创建云线批注"></a>创建云线批注</h3><p>静态Create（）方法允许应用程序基于一系列直线和曲线在指定视图中创建新的RevisionCloud。只有在关联的Revision尚未发布时，才能创建RevisionClouds。</p>
<p>可以在大多数图形视图中创建RevisionClouds，但三维视图和图形柱明细表除外。与大多数其他元素不同，RevisionClouds可以直接在ViewSheet上创建。</p>
<p>RevisionCloud基于一系列草图曲线创建。不要求曲线形成闭合回路，也允许自相交。曲线将自动投影到视图的适当平面上。曲线列表不能为空，并且没有直线可以垂直于视图平面。如果视图是模型视图，则将在模型空间中解释为曲线指定的坐标。如果视图是非模型视图（例如ViewSheet），则坐标将在视图的空间中解释。</p>
<p>每条曲线都将有一系列的“云凸点”沿着它绘制沿着，形成云的外观。云图形将附加到假设每条曲线都是顺时针方向的曲线上。对于线，这意味着云的外部在视图平面内的线的法向量的方向上。因此，任何闭合的环都应该顺时针定向，以创建典型的云形状。</p>
<p>代码区域：创建修订云线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRevisionCloudInActiveView</span>(<span class="params">Document document, Revision revision, IList curves</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction newRevisionCloud = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Revision Cloud&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newRevisionCloud.Start();</span><br><span class="line">        <span class="comment">// Can only create revision cloud for revision that is not issued</span></span><br><span class="line">        <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisionCloud.Create(document, document.ActiveView, revision.Id, curves);</span><br><span class="line">            newRevisionCloud.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newRevisionCloud.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线几何图形"><a href="#修订云线几何图形" class="headerlink" title="修订云线几何图形"></a>修订云线几何图形</h3><p>RevisionCloud派生自Element类。云线批注的Element.Geometry属性将返回组成云线的实际曲线。另一方面，RevisionCloud.GetSketchCurves（）方法将返回定义云的基本轮廓的草图曲线，而不是Revit附着到这些曲线以创建云外观的弧。</p>
<h3 id="与RevisionCloud关联的修订版本"><a href="#与RevisionCloud关联的修订版本" class="headerlink" title="与RevisionCloud关联的修订版本"></a>与RevisionCloud关联的修订版本</h3><p>每个RevisionCloud与一个Revision相关联。关联的修订ID在调用Create（）时指定，可以从RevisionCloud.RevisionId属性中检索。如果RevisionCloud的RevisionId属性未与已发布的修订版本关联，则可以更改该属性。它只能更改为另一个尚未发布的修订版本的ID。IsRevisionIssued（）返回关联的Revision是否已发布。</p>
<h3 id="图纸-1"><a href="#图纸-1" class="headerlink" title="图纸"></a>图纸</h3><p>当RevisionCloud在ViewSheet上可见时（因为它直接放置在ViewSheet上，或者因为它在ViewSheet上放置的视图中可见），ViewSheet上显示的任何修订明细表将自动包括与RevisionCloud关联的修订。</p>
<p>RevisionCloud.GetSheetIds（）方法返回ViewSheets的ID，ViewSheets可能会出现在该ID中，并参与到图纸的修订明细表中。RevisionCloud可以出现在ViewSheet上，因为它是直接在ViewSheet上绘制的，或者因为它的所有者视图放置在ViewSheet上。如果RevisionCloud属于从属视图或具有关联从属视图的视图，则RevisionCloud也可以在放置相关从属视图或主视图的图纸上可见。</p>
<p>此RevisionCloud可能在此方法报告的所有ViewSheets中不可见。其他因素（例如视图的可见性设置或注释裁剪或关联修订的可见性设置）仍可能导致此RevisionCloud不显示在特定ViewSheet上。</p>
<p>如果此RevisionCloud归ViewLegend所有，则不会返回图纸，因为RevisionCloud不会参与修订明细表。ViewSheet类包括用于在图纸上使用Revisionsand RevisionClouds的方法。有关详细信息，请参见ViewSheet主题。</p>
<h2 id="视图过滤器"><a href="#视图过滤器" class="headerlink" title="视图过滤器"></a>视图过滤器</h2><p>过滤器是独立于视图的元素。它们可以使用ParameterFilterElement类或SelectionFilterElement类应用于视图。</p>
<h3 id="ParameterFilterElement"><a href="#ParameterFilterElement" class="headerlink" title="ParameterFilterElement"></a>ParameterFilterElement</h3><p>参数过滤元素根据其类别和一系列过滤规则过滤元素。可以指定一个或多个类别作为筛选器的允许类别。</p>
<p>定义过滤器（具有一个或多个类别和一个或多个过滤器规则）后，可以使用多种方法之一将其应用于视图。AddFilter（）方法将过滤器应用于视图，但使用默认覆盖，这意味着视图的显示不会更改。View.SetFilterOverrides（）将设置与过滤器关联的图形覆盖。而View.SetFilterVisibility（）将设置通过过滤器的元素在视图中是否可见。AddFilter（）和SetFilterVisibility（）都将过滤器应用到视图（如果它还没有应用），因此没有必要单独调用AddFilter（）。</p>
<p>下面的示例创建一个匹配多个条件的新视图筛选器，然后在视图中隐藏这些元素。</p>
<p>代码区域：将参数过滤器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateViewFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List categories = <span class="keyword">new</span> List();</span><br><span class="line">    categories.Add(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">    List filterRules = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add view filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create filter element associated to the input categories</span></span><br><span class="line">        ParameterFilterElement parameterFilterElement = ParameterFilterElement.Create(doc, <span class="string">&quot;Example view filter&quot;</span>, categories);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 1 - wall type Function is &quot;Exterior&quot;</span></span><br><span class="line">        ElementId exteriorParamId = <span class="keyword">new</span> ElementId(BuiltInParameter.FUNCTION_PARAM);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateEqualsRule(exteriorParamId, (<span class="built_in">int</span>)WallFunction.Exterior));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 2 - wall height &gt; some number</span></span><br><span class="line">        ElementId lengthId = <span class="keyword">new</span> ElementId(BuiltInParameter.CURVE_ELEM_LENGTH);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateGreaterOrEqualRule(lengthId, <span class="number">28.0</span>, <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 3 - custom shared parameter value matches string pattern</span></span><br><span class="line">        <span class="comment">// Get the id for the shared parameter - the ElementId is not hardcoded, so we need to get an instance of this type to find it</span></span><br><span class="line">        Guid spGuid = <span class="keyword">new</span> Guid(<span class="string">&quot;96b00b61-7f5a-4f36-a828-5cd07890a02a&quot;</span>);</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        collector.OfClass(<span class="keyword">typeof</span>(Wall));</span><br><span class="line">        Wall wall = collector.FirstElement() <span class="keyword">as</span> Wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Parameter sharedParam = wall.get_Parameter(spGuid);</span><br><span class="line">            ElementId sharedParamId = sharedParam.Id;</span><br><span class="line"></span><br><span class="line">            filterRules.Add(ParameterFilterRuleFactory.CreateBeginsWithRule(sharedParamId, <span class="string">&quot;15.&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterFilterElement.SetRules(filterRules);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply filter to view</span></span><br><span class="line">        view.AddFilter(parameterFilterElement.Id);</span><br><span class="line">        view.SetFilterVisibility(parameterFilterElement.Id, <span class="literal">false</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SelectionFilterElement"><a href="#SelectionFilterElement" class="headerlink" title="SelectionFilterElement"></a>SelectionFilterElement</h3><p>SelectionFilterElement是一种特殊的视图筛选器，它不基于规则，而是基于一组可能不相关的元素。可以根据需要将特定元素添加到过滤器中，并且可以像ParameterFilterElement一样覆盖所产生的选择。</p>
<p>下面的示例创建一个新的选择筛选器并对其应用重写。</p>
<p>代码区域：将选择筛选器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSelectionFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find room tags in this view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc, view.Id);</span><br><span class="line">    collector.WherePasses(<span class="keyword">new</span> RoomTagFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect tags whose room number matches criteria</span></span><br><span class="line">    List tagIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (RoomTag tag <span class="keyword">in</span> collector.Cast())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = Int32.Parse(tag.Room.Number);</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tagIds.Add(tag.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create SelectionFilterElement&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create selection filter and assign ids</span></span><br><span class="line">        SelectionFilterElement filterElement = SelectionFilterElement.Create(doc, <span class="string">&quot;Room tags filter&quot;</span>);</span><br><span class="line">        filterElement.SetElementIds(tagIds);</span><br><span class="line"></span><br><span class="line">        ElementId filterId = filterElement.Id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the filter to the view</span></span><br><span class="line">        view.AddFilter(filterId);</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the existing graphics settings, and change the color to Blue</span></span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        overrideSettings.SetProjectionLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        view.SetFilterOverrides(filterId, overrideSettings);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Modifying filters</p>
<p>应用于视图的所有过滤器都可以使用View.GetFilters（）方法检索，该方法将返回过滤器ID列表。可以分别使用View.GetFilterVisibility（）和View.GetFilterOverrides（）方法检查特定筛选器的筛选器可见性和图形覆盖。RemoveFilter将从视图中删除筛选器。</p>
<p>下面的示例演示如何获取视图中的过滤器，然后修改与当前将剪切颜色设置为红色的任何过滤器关联的覆盖。</p>
<p>代码区域：修改现有筛选器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyExistingFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find any filter with overrides setting cut color to Red</span></span><br><span class="line">    Dictionary&lt;ElementId, OverrideGraphicSettings&gt; filterIdsToChange = <span class="keyword">new</span> Dictionary&lt;ElementId, OverrideGraphicSettings&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> view.GetFilters())</span><br><span class="line">    &#123;</span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        Color lineColor = overrideSettings.CutLineColor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lineColor == Color.InvalidColorValue)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save overrides setting the cut color to green</span></span><br><span class="line">        <span class="keyword">if</span> (lineColor.Red == <span class="number">0xFF</span> &amp;&amp; lineColor.Green == <span class="number">0x00</span> &amp;&amp; lineColor.Blue == <span class="number">0x00</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            overrideSettings.SetCutLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>));</span><br><span class="line">            filterIdsToChange[filterId] = overrideSettings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the change to all found filters</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Change override filters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> filterIdsToChange.Keys)</span><br><span class="line">        &#123;</span><br><span class="line">            view.SetFilterOverrides(filterId, filterIdsToChange[filterId]);</span><br><span class="line">        &#125;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图裁剪"><a href="#视图裁剪" class="headerlink" title="视图裁剪"></a>视图裁剪</h2><p>可以使用Revit API修改某些视图的裁剪区域。ViewCropRegionShapeManager.CanHaveShape属性指示是否允许视图管理裁剪区域形状，而ShapeSet属性指示是否已设置形状。下面的示例裁剪房间边界周围的视图。</p>
<p>代码区域：裁剪视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CropAroundRoom</span>(<span class="params">Room room, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;&gt; segments = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != segments)  <span class="comment">//the room may not be bound</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; segmentList <span class="keyword">in</span> segments)</span><br><span class="line">            &#123;</span><br><span class="line">                CurveLoop loop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">                <span class="keyword">foreach</span> (Autodesk.Revit.DB.BoundarySegment boundarySegment <span class="keyword">in</span> segmentList)</span><br><span class="line">                &#123;</span><br><span class="line">                    loop.Append(boundarySegment.GetCurve());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewCropRegionShapeManager vcrShapeMgr = view.GetCropRegionShapeManager();</span><br><span class="line">                vcrShapeMgr.SetCropShape(loop);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// if more than one set of boundary segments for room, crop around the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置换视图"><a href="#置换视图" class="headerlink" title="置换视图"></a>置换视图</h2><p>使用DisplacementElement类创建置换视图。DisplacementElement是视图专有的元素，可用于使元素显示为从其实际位置偏移。置换视图对于说明模型元素与整个模型的关系非常有用。DisplacementElement实际上不会更改任何模型元素的位置;它只是使它们显示在不同的位置。</p>
<p>有关创建置换视图的详细示例，请参见Revit SDK中的DisplacementElementAnimation示例。</p>
<h3 id="创建置换视图"><a href="#创建置换视图" class="headerlink" title="创建置换视图"></a>创建置换视图</h3><p>静态DisplacementElement.Create（）方法创建一个新的DisplacementElement。如果parentDisplacementElement参数不为空，则新DisplacementElement可以是父DisplacementElement的子元素。如果指定了父代，则子DisplacementElement的转换将与父代的转换连接在一起，并且其关联元素的位移将相对于父代DisplacementElement。</p>
<p>Create（）方法还需要一个文档、一个要置换的元素列表、所有者视图以及要应用于置换元素图形的转换。在任何视图中，一个元素只能被单个DisplacementElement置换。将一个元素替换为多个DisplacementElement将导致异常。</p>
<p>可以在调用Create（）之前使用DisplaceementElement的其他静态方法来帮助防止任何异常。CanCategoryBeDisplaced（）测试属于特定类别的元素是否可以被置换，而重载的静态方法CanElementsBeDisplaced（）指示特定元素是否可以被分配给新的DisplacementElement。IsAllowedAsDisplacedElement（）测试单个元素是否有资格被置换。</p>
<p>静态GetAdditionalElementsToDisplace（）方法将返回任何其他元素，这些元素应与指定视图中的指定元素一起沿着移位。例如，当墙被置换时，所有插入对象或主体图元也应该被置换。</p>
<p>创建子DisplacementElement时，静态IsValidAsParentInView（）可用于验证特定DisplacementElement是否可用作特定View中的父代。</p>
<p>DisplacementElement的其他静态方法可用于查找包含特定元素的DisplacementElement，以获取View中所有移位元素的列表，或获取指定View所拥有的所有DisplacementElements。</p>
<h3 id="使用置换图元"><a href="#使用置换图元" class="headerlink" title="使用置换图元"></a>使用置换图元</h3><p>一旦创建了新的DisplacementElement，就可以使用方法来获取任何子DisplacementElements，以获取受DisplacementElement影响的所有元素的id，或者获取受DisplacementElement影响的所有元素以及任何子DisplacementElements的id。ParentId属性将返回父DisplacementElement的元素ID（如果存在）。</p>
<p>创建后，可以使用SetDisplacedElementIds（）或RemoveDisplacedElement（）修改受DisplacementElement影响的元素集。另外，相对位移可以改变。</p>
<p>方法ResetDisplacedElements（）将DisplacementElement的平移设置为（0，0，0）。DisplacementElement继续存在，但其元素显示在其实际位置。</p>
<h3 id="创建位移路径"><a href="#创建位移路径" class="headerlink" title="创建位移路径"></a>创建位移路径</h3><p>DisplacementPath是与DisplacementElement相关的视图特定注释。DisplacementPath类创建一个注释，该注释描述元素从其实际位置到其位移位置的移动。通过对DisplacementElement的已移位元素的边缘上的点的引用，将DisplacementPath锚定到DisplacementElement。它由一条直线或一系列折弯线表示，这些直线起源于位移元素上的指定点。</p>
<p>静态DisplacementPath.Create（）方法需要一个文档、关联DisplacementElement的ID、一个引用被DisplacementElement置换的元素之一的边或曲线的引用，以及一个在[0，1]范围内的值，该值是沿指定边的沿着参数。创建后，可以使用PathStyle属性设置DisplacementPath的路径样式。也可以使用SetAnchorPoint（）更改锚点。</p>
<p>下面的示例通过垂直和水平移动找到的第一面墙来创建新的位移，然后为其添加位移路径。</p>
<p>代码区域：创建位移和路径</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDisplacementAndPath</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find roof</span></span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(RoofBase));</span><br><span class="line">    RoofBase roof = fec.FirstElement() <span class="keyword">as</span> RoofBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a geometric reference for the path</span></span><br><span class="line">    Reference edgeRef = GetHorizontalEdgeReference(roof);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;CreateDisplacementAndPath&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        <span class="comment">// Create a new top level DisplacementElement</span></span><br><span class="line">        DisplacementElement dispElem = DisplacementElement.Create(doc, <span class="keyword">new</span> ElementId[] &#123; roof.Id &#125;, <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>), view, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the path associated to the element</span></span><br><span class="line">        DisplacementPath.Create(doc, dispElem, edgeRef, <span class="number">0.5</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Reference <span class="title">GetHorizontalEdgeReference</span>(<span class="params">Element elem</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Find target edge from lower face of roof</span></span><br><span class="line">    Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    options.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    GeometryElement geomElem = elem.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geomObj <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">var</span> faces = solid.Faces;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> faces)</span><br><span class="line">            &#123;</span><br><span class="line">                BoundingBoxUV box = face.GetBoundingBox();</span><br><span class="line">                UV midpoint = (box.Min + box.Max) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">if</span> (face.ComputeNormal(midpoint).Normalize().Z &lt; <span class="number">-0.1</span>) <span class="comment">// Downward facing, this is good enough</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> edgeLoops = face.EdgeLoops;</span><br><span class="line">                    <span class="keyword">foreach</span> (EdgeArray edgeArray <span class="keyword">in</span> edgeLoops)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeArray)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// horizontal?</span></span><br><span class="line">                            <span class="keyword">if</span> (Math.Abs(edge.AsCurve().ComputeDerivatives(<span class="number">0.0</span>, <span class="literal">true</span>).BasisX.DotProduct(XYZ.BasisZ)) - <span class="number">1</span> &lt;= <span class="number">0.00001</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> edge.Reference;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关联的DisplacementElement可以具有父DisplacementElement，并且该父DisplacementElement可以具有其自己的父DisplacementElement，从而产生一系列祖先。终点可以是点的原始（未移位）位置，或者是与这些祖先DisplacementElements相对应的任何中间移位位置上的对应点。位移路径。PistorIdx属性指定路径的终点。</p>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>View类是Revit中所有视图类型的基类，并跟踪视图中的图元，而UIView类则包含有关Revit用户界面中视图窗口的数据。可以使用GetOpenUIViews（）方法从UID目录中检索所有打开视图的列表。UIView类具有获取有关视图绘图区域的信息以及平移和缩放活动视图的方法。</p>
<p>GetWindowRectangle（）返回一个描述UIView窗口大小和位置的矩形。它不包括窗口边框或标题栏。</p>
<h3 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h3><p>UIView有几种与缩放活动视图相关的方法。UIView.GetZoomCorners（）获取模型坐标中视图矩形的角点，UIView.ZoomAndCenterRectangle（）提供缩放和平移活动视图的能力，使其以模型的输入区域为中心。</p>
<p>ZoomToFit（）和ZoomSheetSize（）方法提供了调整窗口缩放的快速方法，而Zoom（）方法可用于按指定因子放大或缩小。</p>
<h3 id="关闭视图"><a href="#关闭视图" class="headerlink" title="关闭视图"></a>关闭视图</h3><p>UIView.Close（）可以关闭可见窗口。但是，它不能用于关闭最后一个活动窗口。尝试关闭最后一个活动窗口将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/10%E8%A7%86%E5%9B%BE/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="编辑元素"><a href="#编辑元素" class="headerlink" title="编辑元素"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Editing_Elements_html">编辑元素</a></h1><p>在Revit中，可以使用Revit Platform API移动、复制、旋转、对齐、删除、镜像、编组和排列一个元素或一组元素。在API中使用编辑功能与在Revit UI中使用命令类似。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Moving Elements 移动元素</li>
<li>Copying Elements 复制元素</li>
<li>Rotating elements 旋转元素</li>
<li>Aligning Elements 对齐元素</li>
<li>Mirroring Elements 镜像元素</li>
<li>Grouping Elements 对元素进行分组</li>
<li>Creating Arrays of Elements 创建元素数组</li>
<li>Deleting Elements 删除元素</li>
<li>Pinned Elements 固定元素</li>
</ul>
<h2 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a>移动元素</h2><p>ElementTransformUtils类提供两个静态方法来将一个或多个元素从一个位置移动到另一个位置。</p>
<p>表19：移动方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>MoveElement( Document, ElementId, XYZ)</td>
<td>将文档中的元素移动指定的向量。</td>
</tr>
<tr>
<td>MoveElements(Document, ICollection, XYZ)</td>
<td>将文档中的几个元素移动指定向量的一组ID。</td>
</tr>
</tbody></table>
<p>注意：当您使用MoveElement（）或MoveElements（）方法时，以下规则适用。这些方法不能将基于标高的图元从标高上移或下移。如果图元基于标高，则不能修改Z坐标值。但是，可以将图元放置在同一标高中的任何位置。同样，某些基于标高的图元具有偏移实例参数，可以使用该参数在Z方向上移动它们。例如，如果在标高1中的原始位置（0，0，0）创建新柱，然后将其移动到新位置（10，20，30），则柱将放置在位置（10，20，0）而不是（10，20，30）。</p>
<p>代码区域10-1：使用MoveElement（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// get the column current location</span></span><br><span class="line">            LocationPoint columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">            XYZ oldPlace = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move the column to new location.</span></span><br><span class="line">            XYZ newPlace = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, column.Id, newPlace);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now get the column&#x27;s new location</span></span><br><span class="line">            columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">            XYZ newActual = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> info = <span class="string">&quot;Original Z location: &quot;</span> + oldPlace.Z + </span><br><span class="line">                            <span class="string">&quot;\nNew Z location: &quot;</span> + newActual.Z;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,info);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>移动一个或多个图元时，关联图元也会移动。例如，如果移动带窗的墙，则窗也会移动。 * 无法移动固定的图元。 在Revit中移动图元的另一种方法是使用位置及其衍生对象。在Revit Platform API中，Location对象提供了平移和旋转图元的功能。更多的位置信息和控制可以使用Location对象的派生，如LocationPoint或LocationCurve。如果Location元素向下转换为LocationCurve对象或LocationPoint对象，则直接将曲线或点移动到新位置。</p>
<p>代码区域10-2：使用位置移动</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MoveUsingLocationCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">        XYZ translationVec = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (wallLine.Move(translationVec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CA323378-0ABA-4B2B-B242-2D98C01F0A78-low.png"></p>
<p>图30：使用LocationCurve移动墙</p>
<p>此外，还可以使用LocationCurve Curve属性或LocationPoint Point属性在Revit中移动一个图元。 使用Curve特性将曲线驱动元素移动到任何指定位置。许多图元是曲线驱动的，例如墙、梁和支撑。还可以使用属性调整元素长度的大小。</p>
<p>代码区域10-3：使用曲线移动</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveUsingCurveParam</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ p1 = XYZ.Zero;</span><br><span class="line">    XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    Line newWallLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the wall line to a new line.</span></span><br><span class="line">    wallLine.Curve = newWallLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用LocationCurve.JoinType属性获取或设置基于曲线的元素的联接属性。 使用LocationPoint Point属性设置元素的物理位置。</p>
<p>代码区域10-4：使用点移动</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocationMove</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationPoint columnPoint = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != columnPoint)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ newLocation = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// Move the column to the new location</span></span><br><span class="line">                columnPoint.Point = newLocation;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h2><p>ElementTransformUtils类提供了几个静态方法，用于将一个或多个元素从一个位置复制到另一个位置，可以在同一文档或视图中复制，也可以复制到不同的文档或视图中。</p>
<p>表：复制方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CopyElement( Document, ElementId, XYZ)</td>
<td>复制元素并将副本放置在给定变换所指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, XYZ)</td>
<td>复制一组元素，并将副本放置在给定事务指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, Document, Transform, CopyPasteOptions)</td>
<td>将一组元素从源文档复制到目标文档。</td>
</tr>
<tr>
<td>CopyElements(View, ICollection, View, Transform, CopyPasteOptions)</td>
<td>将一组元素从源视图复制到目标视图。</td>
</tr>
</tbody></table>
<p>所有方法都返回新创建元素的ElementId集合，包括CopyElement（）。该集合包括由于依赖关系而创建的任何元素。</p>
<p>从一个文档复制到另一个文档的方法只能用于复制非视图特定的元素。副本被放置在其各自的原始位置或由可选转换指定的位置。</p>
<p>应使用从一个视图复制到另一个视图的方法来复制视图特定的图元。该方法可用于视图专有图元和模型图元，但绘图视图不能用作模型图元的目标。粘贴的图元将被重新定位，以确保在目标视图中正确放置。例如，从一个标高复制到另一个标高时，标高会发生更改。通过提供可选的Transform参数，可以在目标视图中执行其他转换。此附加变换必须在目标视图的平面内。</p>
<p>从一个视图复制到另一个视图时，源视图和目标视图都必须是能够绘制详图和视图专有图元（如楼板和天花板平面、立面、剖面或绘图视图）的二维图形视图。ElementTransformUtils.GetTransformFromViewToView（）方法将返回从源视图复制到目标视图时应用于元素的转换。</p>
<p>在视图之间或文档之间复制时，可以设置可选的CopyPasteOptions参数以覆盖默认的复制&#x2F;粘贴设置。默认情况下，如果在粘贴操作过程中出现重复的类型名称，Revit将显示一个模式对话框，其中包含仅复制具有唯一名称的类型或取消操作的选项。CopyPasteOptions可用于指定一个自定义处理程序，使用IDuplicateTypeException接口来处理重复的类型名称。</p>
<p>See the Duplicate Views sample in the Revit SDK for a detailed example of copying between documents and between views.<br>有关在文档之间和视图之间复制的详细示例，请参见Revit SDK中的“复制视图”示例。</p>
<h2 id="旋转元素"><a href="#旋转元素" class="headerlink" title="旋转元素"></a>旋转元素</h2><p>ElementTransformUtils类提供了两个静态方法来旋转项目中的一个或多个元素。</p>
<p>表20：旋转方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RotateElement(Document, ElementId, Line, double)</td>
<td>将文档中的元素围绕给定轴旋转指定的弧度数。</td>
</tr>
<tr>
<td>RotateElements(Document, ICollection, Line, double)</td>
<td>按项目中的ID将多个图元围绕给定轴旋转指定的弧度数。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CDF32C7-BA19-499B-81BE-02A982E310D7-low.png"></p>
<p>图31：逆时针旋转 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-11A64EB3-0D9F-4A33-8DB7-CBA34CFBD04C-low.png"></p>
<p>图32：顺时针旋转 请注意，锁定的图元不能旋转。</p>
<p>代码区域10-5：使用RotateElement（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RotateColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// The axis should be a bound line.</span></span><br><span class="line">    Line axis = Line.CreateBound(point1, point2);</span><br><span class="line">    ElementTransformUtils.RotateElement(document, element.Id, axis, Math.PI / <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果元素Location可以向下转换为LocationCurve或LocationPoint，则可以直接旋转曲线或点。</p>
<p>代码区域10-6：基于位置曲线旋转</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Rotate the element via its location curve.</span></span><br><span class="line">    LocationCurve curve = element.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">    &#123;</span><br><span class="line">        Curve line = curve.Curve;</span><br><span class="line">        XYZ aa = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">        XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">        Line axis = Line.CreateBound(aa, cc);</span><br><span class="line">        rotated = curve.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域10-7：基于位置点旋转</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">        LocationPoint location = element.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != location)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ aa = location.Point;</span><br><span class="line">                XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">                Line axis = Line.CreateBound(aa, cc);                </span><br><span class="line">            rotated = location.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h2><p>ItemFactoryBase.NewAlignment（）方法可以在两个引用之间创建新的锁定对齐。这两个引用必须是以下组合之一：</p>
<ul>
<li>2个平面</li>
<li>2条线</li>
<li>线和点</li>
<li>直线和参考平面</li>
<li>2个弧</li>
<li>2个圆柱面</li>
</ul>
<p>这些参照必须已经几何对齐，因为此函数不会强制它们对齐。如果可以创建对齐，则返回一个表示锁定对齐的新Dimension对象。否则将抛出异常。</p>
<p>NewAlignment（）方法还需要一个视图来确定路线的方向。</p>
<p>请参见SDK Samples中包含的FamilyCreation文件夹中的“桁架”示例。其中有几个使用NewAlignment（）的示例，例如将新桁架的下弦杆锁定到底部参照平面。</p>
<h2 id="镜像元素"><a href="#镜像元素" class="headerlink" title="镜像元素"></a>镜像元素</h2><p>ElementTransformUtils类提供两个静态方法来镜像项目中的一个或多个元素。</p>
<p>表21：镜像方法</p>
<table>
<thead>
<tr>
<th><strong>Member 构件</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MirrorElement(Document, ElementId, Plane)</td>
<td>关于几何平面镜像一个元素。</td>
</tr>
<tr>
<td>MirrorElements(Document, ICollection, Plane, Boolean)</td>
<td>关于几何平面镜像多个元素。可以在原始几何体或副本上执行。</td>
</tr>
</tbody></table>
<p>执行镜像操作后，可以从“选择元素集”（Selection ElementSet）访问新元素。</p>
<p>ElementTransformUtils. Canadian Element（）和ElementTransformUtils. Canadian Elements（）可用于在尝试镜像元素之前确定是否可以镜像一个或多个元素。</p>
<p>下面的代码演示如何使用根据墙的侧面计算的平面镜像墙。</p>
<p>代码区域10-8：镜像墙壁</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MirrorWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Reference reference = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior).First();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get one of the wall&#x27;s major side faces</span></span><br><span class="line">        Face face = wall.GetGeometryObjectFromReference(reference) <span class="keyword">as</span> Face; </span><br><span class="line"></span><br><span class="line">        UV bboxMin = face.GetBoundingBox().Min;</span><br><span class="line">        <span class="comment">// create a plane based on this side face with an offset of 10 in the X &amp; Y directions</span></span><br><span class="line"></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(face.ComputeNormal(bboxMin), </span><br><span class="line">                face.Evaluate(bboxMin).Add(<span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        ElementTransformUtils.MirrorElement(document, wall.Id, plane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个FamilyInstance都有一个镜像属性。它指示是否镜像FamilyInstance（例如柱）。</p>
<h2 id="对元素进行分组"><a href="#对元素进行分组" class="headerlink" title="对元素进行分组"></a>对元素进行分组</h2><p>Revit 平台 API 使用 Creation.Document.NewGroup（） 方法选择一个图元或多个图元或组，然后将它们组合在一起。对于您放置的组的每个实例，它们之间都有关联。例如，您可以创建一个包含床、墙和窗户的组，然后在项目中放置该组的多个实例。如果修改一个组中的墙，则该墙会针对该组的所有实例进行更改。这使得修改建筑模型变得更加容易，因为您可以在一次操作中更改组的多个实例。</p>
<p>代码区域 10-9：创建组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Group <span class="keyword">group</span> = <span class="literal">null</span>;</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Group all selected elements</span></span><br><span class="line">    <span class="keyword">group</span> = document.Create.NewGroup(selectedIds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初，该组具有通用名称，例如 Group 1。可以通过更改组类型的名称来修改它，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the default group name to a new name &quot;MyGroup&quot;</span></span><br><span class="line"><span class="keyword">group</span>.GroupType.Name = <span class="string">&quot;MyGroup&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Revit 中有三种类型的组;模型组、详图组和附加详图组。所有 API 都是使用 NewGroup（） 方法创建的。创建的 Group 的类型取决于传递的 Elements。</p>
<ul>
<li>如果未传递详图元素，则会创建一个模型组。</li>
<li>如果所有元素都是详图元素，则会创建一个详图组。</li>
<li>如果同时包含两种类型的元素，则会创建并返回包含 Attached Detail Group 的模型组。</li>
</ul>
<p><em><strong>注意</strong></em>对元素进行分组后，可以从项目中删除这些元素。</p>
<ul>
<li>删除模型组中的模型元素后，当鼠标光标悬停在组上或单击该组时，该模型元素仍然可见，即使应用程序向 UI 返回 Succeeded 也是如此。实际上，模型元素已被删除，您无法选择或访问该元素。</li>
<li>当组实例的最后一个成员被删除、排除或从项目中移除时，模型组实例将被删除。</li>
</ul>
<p>对元素进行分组时，无法移动或旋转它们。如果对分组的元素执行这些操作，则元素不会发生任何变化，但 Move（） 或 Rotate（） 方法返回 true。</p>
<p>如果不对维度和标记引用的元素进行分组，则无法对它们进行分组。如果这样做，API 调用将失败。</p>
<p>您可以对引用模型组中的模型元素的维度和标签进行分组。尺寸和标记将添加到附加的详图组中。如果不对父组执行相同的操作，则无法移动、复制、旋转、阵列或镜像附着的详图组。</p>
<h2 id="创建元素阵列"><a href="#创建元素阵列" class="headerlink" title="创建元素阵列"></a>创建元素阵列</h2><p>Revit 平台 API 提供了两个类，即 LinearArray 和 RadialArray，用于对项目中的一个或多个图元进行阵列。这些类提供静态方法，用于创建一个或多个选定组件的线性或径向阵列。线性阵列表示从一个点沿直线创建的阵列，而径向阵列表示沿圆弧创建的阵列。</p>
<p>作为使用阵列的示例，您可以选择位于同一墙中的门和窗，然后创建门、墙和窗配置的多个实例。</p>
<p>LinearArray 和 RadialArray 都提供了对一个或多个元素进行阵列的方法，而无需进行分组和关联。尽管类似于用于阵列元素的 Create（） 方法，但每个生成的元素都独立于其他元素，并且可以在不影响其他元素的情况下进行操作。有关可用于创建线性或径向阵列的方法的更多信息，请参阅下表。</p>
<p>表 22：LinearArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列排列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>表 23：RadialArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列.生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>如果您需要创建组件的多个实例并同时操作它们，则排列元素的方法非常有用。数组中的每个实例都可以是组的成员。</p>
<p>注意：使用方法对元素进行阵列时，以下规则适用：</p>
<ul>
<li>执行 Linear 和 Radial Array 操作时，依赖于阵列元素的元素也会排列。</li>
<li>某些元素无法排列，因为它们无法分组。有关组和阵列限制的详细信息，请参见《Revit 用户指南》。</li>
<li>大多数注释符号不支持数组。</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>Revit 平台 API 提供了 Delete（） 方法，用于删除项目中的一个或多个图元。</p>
<p> 表 23：删除成员</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Delete(ElementId)</td>
<td>使用元素 ID 从项目中删除元素</td>
</tr>
<tr>
<td>Delete(<a target="_blank" rel="noopener" href="http://msdn2.microsoft.com/en-us/library/92t2ye13">ICollection</a>)</td>
<td>按元素的 ID 从项目中删除多个元素。</td>
</tr>
</tbody></table>
<p>第一种方法根据 Id 删除单个元素，如以下示例所示。</p>
<p>代码区域：根据 ElementId 删除元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DeleteElement</span>(<span class="params">Autodesk.Revit.DB.Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Delete an element via its id</span></span><br><span class="line">        Autodesk.Revit.DB.ElementId elementId = element.Id;</span><br><span class="line">        ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elementId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected element in Revit failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String prompt = <span class="string">&quot;The selected element has been removed and &quot;</span>;</span><br><span class="line">        prompt += deletedIdSet.Count - <span class="number">1</span>;</span><br><span class="line">        prompt += <span class="string">&quot; more dependent elements have also been removed.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：删除元素时，与该元素关联的任何子元素也将被删除，如上面的示例所示。</p>
<p>该 API 还提供了一种删除多个元素的方法。</p>
<p>代码区域：根据 Id 删除多个元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete all the selected elements via the set of elements</span></span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection elements = uidoc.Selection.GetElementIds();</span><br><span class="line">ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elements);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected elements in Revit failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The selected element has been removed.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：删除元素后，对已删除元素的任何引用都将无效，并在访问这些元素时引发异常。</p>
<h2 id="固定元素"><a href="#固定元素" class="headerlink" title="固定元素"></a>固定元素</h2><p>可以固定元素以防止它们移动。Element.Pinned 属性可用于检查元素是否已固定，或者固定或取消固定元素。</p>
<p>当 Element.Pinned 设置为 true 时，无法移动或旋转元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/08%E9%9B%86%E5%90%88/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Collections_Collections_and_Iterators_html">集合</a></h1><p>大多数Revit Platform API属性和方法在提供对一组相关项的访问时都使用.NET Framework集合类。</p>
<p>在Revit集合类型中实现的IEnumerator和IEnumerator接口在System.Collection命名空间中定义。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Interface 接口</li>
<li>Collections and Iterators 集合和迭代器</li>
</ul>
<h2 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2><p>以下各节讨论与接口相关的集合类型。</p>
<h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>IELTS接口位于System.Collections命名空间中。它公开枚举数，该枚举数支持对非泛型集合进行简单迭代。GetEnumerator（）方法获取实现此接口的枚举器。返回的IEnumerator对象在整个集合中迭代。GetEnumerator（）方法由C#中的foreach循环隐式使用。</p>
<h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>IEnumerator接口位于System.Collections命名空间中。它支持对非泛型集合进行简单迭代。IEnumerator是所有非泛型枚举器的基接口。C#中的foreach语句隐藏了枚举器的复杂性。</p>
<p>注意：建议使用foreach而不是直接操作枚举器。</p>
<p>枚举数用于读取集合数据，但不能用于修改基础集合。使用IEnumerator如下：</p>
<ul>
<li>最初，枚举数位于集合中第一个元素的前面。但是，最好总是在第一次获取枚举数时调用Reset（）。<ul>
<li>Reset（）方法将枚举数移回原始位置。在此位置，调用Current属性将引发异常。</li>
<li>调用MoveNext（）方法，在阅读当前迭代器值之前，将枚举器前进到集合的第一个元素。</li>
</ul>
</li>
<li>在调用MoveNext（）方法或Reset（）方法之前，Current属性返回相同的对象。MoveNext（）方法将当前迭代器设置为下一个元素。</li>
<li>如果MoveNext通过了集合的末尾，则枚举数位于集合中最后一个元素之后，MoveNext返回false。<ul>
<li>当枚举数处于此位置时，对MoveNext的后续调用也返回false。</li>
<li>如果对MoveNext的最后一次调用返回false，则调用Current属性将引发异常。</li>
<li>要再次将当前迭代器设置为集合中的第一个元素，请调用Reset（）方法，然后调用MoveNext（）。</li>
</ul>
</li>
<li>只要集合保持不变，枚举数就保持有效。<ul>
<li>如果对集合进行了更改（如添加、修改或删除元素），则枚举数将失效，并且下次调用MoveNext（）或Reset（）方法时将引发InvalidOperationException。</li>
<li>如果在MoveNext和当前迭代器之间修改了集合，则Current属性返回到指定的元素，即使枚举器已经无效。</li>
</ul>
</li>
</ul>
<p>注意：所有对Reset（）方法的调用都必须导致枚举数的相同状态。首选的实现是将枚举数移动到集合的开头，在第一个元素之前。如果在创建枚举数之后修改了集合，则这将使枚举数无效，这与MoveNext（）和Current属性一致。</p>
<h2 id="Collections-and-Iterators-集合和迭代器"><a href="#Collections-and-Iterators-集合和迭代器" class="headerlink" title="Collections and Iterators 集合和迭代器"></a>Collections and Iterators 集合和迭代器</h2><p>在Revit Platform API中，集合和迭代器是通用且类型安全的。</p>
<p>所有集合都实现IEnumerator接口，所有相关迭代器都实现IEnumerator接口。因此，所有方法和属性都在Revit Platform API中实现，并且可以在相关集合中发挥作用。</p>
<p>所有集合的实现都是类似的。下面的示例使用ModelCurveArray演示如何使用主集合属性：</p>
<p>代码区域9-2：使用集合</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the ModelLine references</span></span><br><span class="line">ModelCurveArray lineArray = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// … Store operation</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(<span class="number">131943</span>); <span class="comment">//assume 131943 is a model line element id</span></span><br><span class="line">lineArray.Append(document.GetElement(id) <span class="keyword">as</span> ModelLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use Size property of Array</span></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Before Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use IsEmpty property of Array</span></span><br><span class="line"><span class="keyword">if</span> (!lineArray.IsEmpty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use Item(int) property of Array</span></span><br><span class="line">    ModelCurve modelCurve = lineArray.get_Item(<span class="number">0</span>) <span class="keyword">as</span> ModelCurve;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase the specific element from the set of elements</span></span><br><span class="line">    selectedIds.Remove(modelCurve.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new model line and insert to array of model line</span></span><br><span class="line">    SketchPlane sketchPlane = modelCurve.SketchPlane;</span><br><span class="line"></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the start point of the line</span></span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// the end point of the line</span></span><br><span class="line">    <span class="comment">// create geometry line</span></span><br><span class="line">    Line geometryLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the ModelLine</span></span><br><span class="line">    ModelLine line = document.Create.NewModelCurve(geometryLine, sketchPlane) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">    lineArray.Insert(line, lineArray.Size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the Clear() method to remove all elements in lineArray</span></span><br><span class="line">lineArray.Clear();</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Clear: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/08%E9%9B%86%E5%90%88/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/07%E5%8F%82%E6%95%B0/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Parameters_html">参数</a></h1><p>Revit提供了一种常规机制，为每个图元提供一组可编辑的参数。</p>
<p>在Revit UI中，某些图元参数在“图元属性”窗口中可见。以下各节介绍如何获取和使用内置参数、共享参数和全局参数。</p>
<p>在Revit Platform API中，参数在Element类中进行管理。您可以通过以下方式访问参数：</p>
<ul>
<li>通过迭代元素的所有参数的Element.Parameters集合（有关示例，请参见获取选定元素参数演练中的示例代码）。</li>
<li>通过迭代Element.GetOrderedParameters()返回的集合，该集合仅返回属性选项板中可见的参数。</li>
<li>通过重载的Element.Parameter属性直接访问参数。如果参数不存在，则属性返回null。</li>
<li>通过Element.ParametersMap集合按名称访问参数。</li>
<li>按名称字符串Element.LookupParameter()或Element.GetParameters()。</li>
</ul>
<p>如果知道内置ID、定义或参数，则可以使用重载的Parameter属性从Element中检索Parameter对象。Parameter[NULL]属性重载根据其全局唯一ID（Global Unique ID，NULL）获取共享参数，该全局唯一ID在创建共享参数时分配给该共享参数。}]}</p>
<p>Element.LookupParameter()方法根据参数的本地化名称获取参数，因此如果要按名称查找参数并且需要在多个区域设置中运行，则代码应处理不同的语言。此外，请记住，可能会出现同名参数的多个匹配，因为即使已经存在同名的内置参数，共享参数或项目参数也可以绑定到元素类别。因此，最好使用Element. GetParameter()，它将返回与给定名称匹配的所有参数。LookupParameter()将返回找到的第一个匹配项。</p>
<p>本节中的页面</p>
<ul>
<li>演练：获取选定的元素参数</li>
<li>参数关系</li>
<li>定义</li>
<li>内置参数</li>
<li>共享参数</li>
<li>全局参数</li>
<li>参数</li>
</ul>
<h2 id="演练：获取选定的元素参数"><a href="#演练：获取选定的元素参数" class="headerlink" title="演练：获取选定的元素参数"></a>演练：获取选定的元素参数</h2><p>元素参数是通过遍历元素参数集来检索的。下面的代码示例阐释如何从选定的元素中检索Parameter。</p>
<p>****注意：****此示例使用了一些参数成员，如AsValueString和DataType，这些将在后续主题中介绍。</p>
<p>代码区域8-1：获取选定的元素参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetElementParameterInformation</span>(<span class="params">Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Format the prompt information string</span></span><br><span class="line">    String prompt = <span class="string">&quot;Show parameters in selected Element: \n\r&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// iterate element&#x27;s parameters</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter para <span class="keyword">in</span> element.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        st.AppendLine(GetParameterInformation(para, document));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt + st.ToString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">GetParameterInformation</span>(<span class="params">Parameter para, Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> defName = para.Definition.Name + <span class="string">&quot;\t : &quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> defValue = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="comment">// Use different method to get parameter data according to the storage type</span></span><br><span class="line">    <span class="keyword">switch</span> (para.StorageType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Double:</span><br><span class="line">            <span class="comment">//covert the number into Metric</span></span><br><span class="line">            defValue = para.AsValueString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.ElementId:</span><br><span class="line">            <span class="comment">//find out the name of the element</span></span><br><span class="line">            Autodesk.Revit.DB.ElementId id = para.AsElementId();</span><br><span class="line">            <span class="keyword">if</span> (id.IntegerValue &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                defValue = document.GetElement(id).Name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = id.IntegerValue.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Integer:</span><br><span class="line">            <span class="keyword">if</span> (ParameterType.YesNo == para.Definition.ParameterType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (para.AsInteger() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;False&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;True&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = para.AsInteger().ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.String:</span><br><span class="line">            defValue = para.AsString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            defValue = <span class="string">&quot;Unexposed parameter.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defName + defValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-07A40B76-5AD7-46C8-983F-494CECF88543-low.png"></p>
<p>图26：获取墙参数结果</p>
<p>注意：在Revit中，某些参数的值位于“图元属性”对话框的下拉列表中。可以使用Revit Platform API获取与Parameter的枚举类型对应的数值，但不能使用Parameter.AsValueString()方法获取值的字符串表示形式。</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>参数可以相互影响。</p>
<p>参数之间存在关系，其中一个参数的值可以影响：</p>
<ul>
<li>是否可以设置另一个参数，或者是否为只读</li>
<li>哪些参数对元素有效</li>
<li>另一个参数的计算值</li>
</ul>
<p>此外，某些参数始终是只读的。</p>
<p>某些参数在Revit中计算，例如墙长度和面积参数。这些参数总是只读的，因为它们依赖于元素的内部状态。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B11C1A73-B5DE-4429-B728-C739D963AE1A-low.png"></p>
<p>在此代码示例中，洞口的“Sill Height”参数将被调整，从而导致重新计算“Head Height”参数：</p>
<p>代码区域：参数关系示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opening should be an opening such as a window or a door</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowParameterRelationship</span>(<span class="params">FamilyInstance opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get the original Sill Height and Head Height parameters for the opening</span></span><br><span class="line">        Parameter sillPara = opening.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);</span><br><span class="line">        Parameter headPara = opening.get_Parameter(BuiltInParameter.INSTANCE_HEAD_HEIGHT_PARAM);</span><br><span class="line">        <span class="built_in">double</span> sillHeight = sillPara.AsDouble();</span><br><span class="line">        <span class="built_in">double</span> origHeadHeight = headPara.AsDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change the Sill Height only and notice that Head Height is recalculated</span></span><br><span class="line">        sillPara.Set(sillHeight + <span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">double</span> newHeadHeight = headPara.AsDouble();</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Old head height: &quot;</span> + origHeadHeight + <span class="string">&quot;; new head height: &quot;</span> </span><br><span class="line">                + newHeadHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局参数也与其他参数有关系。有关详细信息，请参见“全局参数基础”主题。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象描述数据类型、名称和其他参数细节。</p>
<p>有两种类型的定义对象派生自该对象。</p>
<ul>
<li>InternalDefinition表示完全存在于Revit数据库中的所有类型的定义。</li>
<li>ExternalDefinition表示存储在磁盘上的共享参数文件中的定义。</li>
</ul>
<p>您应该编写使用Definition基类的代码，以便该代码适用于内部和外部参数定义。下面的代码示例演示如何使用定义类型查找特定参数。</p>
<p> 代码区域8-2：根据定义类型查找参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find parameter using the Parameter&#x27;s definition type.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindParameter</span>(<span class="params">Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter foundParameter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// This will find the first parameter that measures length</span></span><br><span class="line">        <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> element.Parameters)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameter.Definition.ParameterType == ParameterType.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                        foundParameter = parameter;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foundParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>此属性返回参数数据类型，这会影响参数在Revit UI中的显示方式。一些参数类型枚举成员包括：</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>Number</em></td>
<td>参数数据应解释为真实的数字，可能包括小数点。</td>
</tr>
<tr>
<td><em>Moment</em></td>
<td>数据值将表示为力矩。</td>
</tr>
<tr>
<td><em>AreaForce</em></td>
<td>数据值将表示为面积力。</td>
</tr>
<tr>
<td><em>LinearForce</em></td>
<td>数据值将表示为线性力。</td>
</tr>
<tr>
<td><em>Force</em></td>
<td>数据值将表示为力。</td>
</tr>
<tr>
<td><em>YesNo</em></td>
<td>一个布尔值，表示为Yes或No。</td>
</tr>
<tr>
<td><em>Material</em></td>
<td>此属性的值被视为材料。</td>
</tr>
<tr>
<td><em>URL</em></td>
<td>表示网址的文本字符串。</td>
</tr>
<tr>
<td><em>Angle</em></td>
<td>参数数据表示角度。内部表示将以弧度表示。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Volume</em></td>
<td>参数数据表示体积。内部表示将以十进制立方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Area</em></td>
<td>参数数据表示一个区域。内部表示将以十进制平方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>参数数据应解释为整数，正数或负数。</td>
</tr>
<tr>
<td><em>Invalid</em></td>
<td>参数类型无效。不应使用此值。</td>
</tr>
<tr>
<td><em>Length</em></td>
<td>参数数据表示长度。内部表示将以十进制英尺为单位。用户可见表示将在用户选择的单位系统中。</td>
</tr>
<tr>
<td><em>Text</em></td>
<td>参数数据应解释为文本字符串。</td>
</tr>
<tr>
<td><em>MultilineText</em></td>
<td>此参数的值将表示为多行文本。</td>
</tr>
<tr>
<td><em>FamilyType</em></td>
<td>用于控制嵌套在另一个族中的族的类型的参数。</td>
</tr>
<tr>
<td><em>Image</em></td>
<td>该参数的值是图像的id。</td>
</tr>
</tbody></table>
<p>有关参数类型.材质的更多详细信息，请参见材质。</p>
<p>ParameterGroup 参数组</p>
<p>定义类参数组属性返回参数定义组ID。BuiltInParameterGroup是一种枚举类型，列出了Revit支持的所有内置参数组。参数组用于对“图元属性”对话框中的参数进行排序。</p>
<h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><p>每个Parameter对象都有一个InternalDefinition，它可以从Definition属性中获得。InternalDefinition表示Revit文档中的参数定义。除了从Definition继承的属性之外，它还具有一些其他关键属性。</p>
<h3 id="BuiltInParameter-内置参数"><a href="#BuiltInParameter-内置参数" class="headerlink" title="BuiltInParameter 内置参数"></a>BuiltInParameter 内置参数</h3><p>此属性测试此定义是否标识内置参数。对于内置参数，此属性返回BuiltInParameter枚举值之一。对于自定义参数（如共享参数、全局参数或族参数），该值将为BuiltInParameter.INVALID。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>如果参数不是内置的，则此属性返回关联的ParameterElement的ID。</p>
<h3 id="VariesAcrossGroups"><a href="#VariesAcrossGroups" class="headerlink" title="VariesAcrossGroups"></a>VariesAcrossGroups</h3><p>该属性和相应的SetAllowVaryBetweenGroups()方法确定该参数的值是否可以在组实例的相关成员之间变化。如果为False，则组实例中相关成员的值将保持一致。这只能为非内置参数设置。</p>
<h3 id="Visible-可见"><a href="#Visible-可见" class="headerlink" title="Visible 可见"></a>Visible 可见</h3><p>visible属性指示是否对用户隐藏共享参数。如果您希望将数据添加到仅对您的应用程序有意义而对用户没有意义的元素中，这将非常有用。此值只能在创建共享参数定义时设置。</p>
<h2 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h2><p>Revit Platform API具有大量内置参数。</p>
<p>内置参数在Autodesk.Revit.Parameters.BuiltInParameter枚举中定义（有关此枚举的定义，请参见RevitAPI Help.chm文件）。此枚举已生成可从Visual Studio intellisense看到的文档，如下所示。每个id的文档都包括参数名称，如Autodesk Revit英文版的“图元属性”对话框中所示。请注意，多个不同的参数id可能映射到同一个英文名称;在这种情况下，您必须检查与特定元素关联的参数，以确定使用哪个参数id。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/BuiltInParameter-76164.jpg"></p>
<p>参数ID用于从元素中检索特定参数，如果它存在，使用Element.Parameter属性。但是，并非所有参数都可以使用ID进行检索。例如，族参数未在Revit Platform API中显示，因此，您无法使用内置参数ID获取它们。</p>
<p>以下代码示例显示如何使用BuiltInParameter Id获取特定参数：</p>
<p>代码区域8-3：基于BuiltInParameter获取参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindWithBuiltinParameterID</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use the WALL_BASE_OFFSET paramametId</span></span><br><span class="line">        <span class="comment">// to get the base offset parameter of the wall.</span></span><br><span class="line">        BuiltInParameter paraIndex = BuiltInParameter.WALL_BASE_OFFSET;</span><br><span class="line">        Parameter parameter = wall.get_Parameter(paraIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过Parameter重载，可以使用枚举类型BuiltInParameter作为方法参数.例如，使用BuiltInParameter.GENERIC_WIDTH。</p>
<p>如果不知道确切的BuiltInParameter ID，请通过迭代ParameterSet集合获取参数。另一种用于测试或识别目的的方法是使用get_Parameter()方法测试每个BuiltInParameter。当您使用此方法时，参数集集合可能不包含从get_Parameter()方法返回的所有参数，尽管这种情况并不常见。</p>
<h2 id="共享参数"><a href="#共享参数" class="headerlink" title="共享参数"></a>共享参数</h2><p>共享参数是存储在外部文本文件中的参数定义。</p>
<p>定义由创建定义时生成的唯一标识符标识，并且可以在多个项目中使用。</p>
<p>与共享参数关联的主要对象有：</p>
<ul>
<li>DefinitionFile -表示磁盘上的共享参数文件</li>
<li>DefinitionGroup -一组共享参数，它们被组织成有意义的集合</li>
<li>ExternalDefinition -表示一个共享参数定义，属于一个配置组</li>
<li>ExternalDefinitions -支持创建新的共享参数定义</li>
<li>Binding-将参数定义绑定到一个或多个类别</li>
<li>BindingMap -包含Autodesk Revit项目中存在的所有参数绑定</li>
<li>ParameterElement-存储有关文档中特定用户定义参数的信息</li>
<li>SharedParameterElement -从ParameterElement派生，存储共享参数的定义以下各节介绍如何通过Revit Platform API访问共享参数定义，包括如何获取共享参数定义并将其绑定到某些类别中的元素。</li>
</ul>
<p>要在定义共享参数并将其绑定到类别后访问共享参数，请参见参数。</p>
<p>本节中的页面</p>
<ul>
<li>Definition File</li>
<li>Working with the Definition File</li>
<li>Binding </li>
<li>SharedParameterElement</li>
</ul>
<h3 id="Definition-File"><a href="#Definition-File" class="headerlink" title="Definition File"></a>Definition File</h3><p>DefinitionFile 表示一个共享参数文件，它是一个通用文本文件。</p>
<h4 id="Format-格式"><a href="#Format-格式" class="headerlink" title="Format 格式"></a>Format 格式</h4><p>共享参数定义文件是一个文本文件（.txt），包含三个块：Meta、GROUP和PARAM。GROUP和PARAM块与Revit API中的共享参数功能相关。不要直接编辑定义文件;而是使用UI或API编辑它。</p>
<p>尽管Revit API负责阅读和写入此文件，但以下部分提供了文件格式的信息，该文件格式与用于访问共享参数的API对象和方法密切对应。该文件使用制表符分隔字段，在文本编辑器中很难阅读。下面的代码区域显示了示例共享参数文本文件的内容。</p>
<p>代码区域22-1：参数定义文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This is a Revit shared parameter file.</span><br><span class="line"># Do not edit manually.</span><br><span class="line">META    VERSION    MINVERSION</span><br><span class="line">META    2    1</span><br><span class="line">GROUP    ID    NAME</span><br><span class="line">GROUP    1    MyGroup</span><br><span class="line">GROUP    2    AnotherGroup</span><br><span class="line">*PARAM    GUID    NAME    DATATYPE    DATACATEGORY    GROUP    VISIBLE    DESCRIPTION    USERMODIFIABLE</span><br><span class="line">PARAM    bb7f0005-9692-4b76-8fa3-30cec8aecf74    Price    INTEGER        2    1    Enter price in USD    1</span><br><span class="line">PARAM    b7ea2654-b206-4694-a087-756359b52e7f    areaTags    FAMILYTYPE    -2005020    1    1        1</span><br><span class="line">PARAM    d1a5439d-dc8d-4053-99fa-2f33804bae0e    MyParam    TEXT        1    1        1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP块包含将每个参数定义与组关联的组条目。以下字段显示在GROUP块中：</p>
<ul>
<li>ID -唯一标识组并将参数定义与组关联。</li>
<li>Name - UI中显示的组名称。</li>
</ul>
</li>
<li><p>PARAM块包含参数定义。以下字段出现在PARAM块中：</p>
<ul>
<li><p>GUID - 识别参数定义。</p>
</li>
<li><p>NAME - 参数定义名称。</p>
</li>
<li><p>DATATYPE -参数类型。此字段可以是常见类型（TEXT、INTEGER等），结构类型（力、力矩等）或常用族类型（面积标记等）。通用类型和结构类型参数直接在文本文件中指定（例如：文本，力）。如果DATATYPE字段的值为FAMILYTYPE，则添加一个额外的数字。例如，FAMILYTYPE后跟-2005020表示族类型：面积标记。</p>
</li>
<li><p>DATACATEGORY -DATATYPE为FAMILYTYPE的参数的可选字段。</p>
</li>
<li><p>GROUP -用于标识包含当前参数定义的组的组ID。</p>
</li>
<li><p>VISIBLE -确定参数是否可见。此字段的值为0或1.0 </p>
</li>
<li><p>DESCRIPTION - 此参数的工具提示的可选字段。</p>
</li>
<li><p>USERMODIFIABLE -确定参数是否可由用户编辑。0 &#x3D;用户无法编辑参数，并且该参数在UI中呈灰色显示</p>
</li>
</ul>
</li>
</ul>
<p>在示例定义文件中，有两个组：</p>
<ul>
<li>MyGroup - ID 1 -包含MyParam的参数定义（文本类型参数）和areaTags的定义（家庭类型参数）。</li>
<li>AnotherGroup - ID 2 -包含Price的参数定义，它是一个价格类型参数。</li>
</ul>
<p>Of the 3 parameters in the sample file, only Price has a description. All of the parameters are visible and user modifiable.<br>在示例文件中的3个参数中，只有Price有描述。所有的参数都是可见的，用户可以修改。</p>
<h3 id="Working-with-the-Definition-File"><a href="#Working-with-the-Definition-File" class="headerlink" title="Working with the Definition File"></a>Working with the Definition File</h3><p>定在定义文件中设置参数义文件提供对共享参数的访问。</p>
<h4 id="在定义文件中设置参数"><a href="#在定义文件中设置参数" class="headerlink" title="在定义文件中设置参数"></a>在定义文件中设置参数</h4><p>使用以下步骤访问定义文件及其参数：</p>
<ol>
<li>使用现有文本文件或新文本文件指定Application.SharedParametersFiltrate属性。</li>
<li>使用Application.OpenSharedParameterFile()方法打开共享参数文件。</li>
<li>打开一个现有组或使用configtionFile.groups属性创建一个新组。</li>
<li>打开现有的外部参数定义或使用configuretionGroup.Definitions属性创建新定义。</li>
</ol>
<p>Autodesk. Revit. DB命名空间中的以下类和方法提供了使用Revit API访问共享参数的功能。</p>
<ul>
<li>DefinitionFile 类<ul>
<li>使用Application.OpenSharedParameterFile()方法检索。Revit每次使用一个共享参数文件。</li>
<li>表示一个共享参数文件。</li>
<li>包含多个Group对象。</li>
<li>共享参数被分组以便于管理，并包含共享参数定义。</li>
<li>可以根据需要添加新的定义。</li>
</ul>
</li>
<li>ExternalDefinition 类<ul>
<li>ExternalDefinition对象是由一个共享参数文件中的ExternationGroup对象创建的。</li>
<li>外部参数定义必须属于一个组，该组是共享参数定义的集合。</li>
</ul>
</li>
<li>Application.SharedParametersFilename 属性<ul>
<li>使用此属性获取和设置共享参数文件路径。</li>
<li>默认情况下，Revit没有共享参数文件。</li>
<li>使用前初始化此属性。如果它没有初始化，则会引发异常。</li>
</ul>
</li>
</ul>
<h4 id="创建共享参数文件"><a href="#创建共享参数文件" class="headerlink" title="创建共享参数文件"></a>创建共享参数文件</h4><p>代码区域22-3：创建共享参数文件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateExternalSharedParamFile</span>(<span class="params"><span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        System.IO.FileStream fileStream = System.IO.File.Create(sharedParameterFile);</span><br><span class="line">        fileStream.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问现有共享参数文件"><a href="#访问现有共享参数文件" class="headerlink" title="访问现有共享参数文件"></a>访问现有共享参数文件</h4><p>由于Revit可以有许多共享参数文件，因此必须明确标识要访问的文件和外部参数。以下两个过程说明如何访问现有的共享参数文件。</p>
<p>从外部参数文件中获取配置文件</p>
<p>按照下面的代码所示设置共享参数文件路径，然后调用Application.OpenSharedParameterFile()方法。</p>
<p>代码区域22-4：从外部参数文件获取定义文件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefinitionFile <span class="title">SetAndOpenExternalSharedParamFile</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, <span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set the path of shared parameter file to current Revit</span></span><br><span class="line">    application.SharedParametersFilename = sharedParameterFile;</span><br><span class="line">    <span class="comment">// open the file</span></span><br><span class="line">    <span class="keyword">return</span> application.OpenSharedParameterFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：设置共享参数路径时，请考虑以下几点： 在每次安装过程中，Revit无法检测是否在其他版本中设置了共享参数文件。必须再次为新的Revit安装绑定共享参数文件。 如果Application. SharedParametersFilm设置为无效路径，则仅在调用OpenSharedParameterFile()时引发异常。 * Revit可以使用多个共享参数文件。即使加载参数时只使用一个参数文件，也可以自由更改当前文件。 </p>
<h4 id="遍历所有参数"><a href="#遍历所有参数" class="headerlink" title="遍历所有参数"></a>遍历所有参数</h4><p>下面的示例阐释如何遍历参数项并在消息框中显示结果。</p>
<p>代码区域22-5：遍历参数条目</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDefinitionFileInfo</span>(<span class="params">DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder fileInformation = <span class="keyword">new</span> StringBuilder(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the file name </span></span><br><span class="line">    fileInformation.AppendLine(<span class="string">&quot;File Name: &quot;</span> + myDefinitionFile.Filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate the Definition groups of this file</span></span><br><span class="line">    <span class="keyword">foreach</span> (DefinitionGroup myGroup <span class="keyword">in</span> myDefinitionFile.Groups)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the group name</span></span><br><span class="line">        fileInformation.AppendLine(<span class="string">&quot;Group Name: &quot;</span> + myGroup.Name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate the difinitions</span></span><br><span class="line">        <span class="keyword">foreach</span> (Definition definition <span class="keyword">in</span> myGroup.Definitions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get definition name</span></span><br><span class="line">            fileInformation.AppendLine(<span class="string">&quot;Definition Name: &quot;</span> + definition.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,fileInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改参数定义所有者组"><a href="#更改参数定义所有者组" class="headerlink" title="更改参数定义所有者组"></a>更改参数定义所有者组</h4><p>以下示例说明如何更改参数定义组所有者。</p>
<p>代码区域22-6：更改参数定义组所有者</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadEditExternalParam</span>(<span class="params">DefinitionFile <span class="keyword">file</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get ExternalDefinition from shared parameter file</span></span><br><span class="line">    DefinitionGroups myGroups = <span class="keyword">file</span>.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.get_Item(<span class="string">&quot;MyGroup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (myGroup != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExternalDefinition myExtDef = myGroup.Definitions.get_Item(<span class="string">&quot;MyParam&quot;</span>) <span class="keyword">as</span> ExternalDefinition;</span><br><span class="line">        <span class="keyword">if</span> (myExtDef != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DefinitionGroup newGroup = myGroups.get_Item(<span class="string">&quot;AnotherGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (newGroup != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// change the OwnerGroup of the ExternalDefinition</span></span><br><span class="line">                myExtDef.OwnerGroup = newGroup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定是将共享参数与模型中某些类别的元素联系在一起。</p>
<p>有两种类型的绑定可用，实例绑定和类型绑定。两者之间的主要区别在于，实例绑定参数出现在这些类别中元素的所有实例上。更改其中一个实例的参数不会影响该参数的其他实例。类型绑定参数仅出现在类型对象上，并由使用该类型的所有实例共享。更改类型绑定参数会影响使用该类型的元素的所有实例。请注意，定义只能绑定到实例或类型，而不能同时绑定到两者。</p>
<p>要绑定参数，请执行以下操作：</p>
<ol>
<li>使用InstanceBinding或TypeBinding对象可以创建一个新的Binding对象，该对象包括参数绑定到的类别。</li>
<li>使用Document.ParameterBindings属性提供的BindingMap对象将绑定和定义添加到文档中。</li>
</ol>
<p>Autodesk.Revit.DB命名空间中的以下类和方法提供了有关将参数绑定到元素的详细信息。</p>
<ul>
<li>BindingMap类<ul>
<li>从Document.ParameterBindings属性检索。</li>
<li>参数绑定将参数定义连接到一个或多个类别中的元素。</li>
<li>该映射用于查询现有绑定以及使用Insert方法生成新的参数绑定。</li>
</ul>
</li>
<li>BindingMap.Insert()方法<ul>
<li>绑定对象类型规定参数是绑定到所有实例还是仅绑定到类型。</li>
<li>参数定义不能同时绑定到实例和类型。</li>
<li>如果参数绑定存在，则该方法返回false。</li>
</ul>
</li>
</ul>
<h4 id="Type-Binding"><a href="#Type-Binding" class="headerlink" title="Type Binding"></a>Type Binding</h4><p>TypeBinding对象用于将特性绑定到Revit类型（如墙类型）。它与实例绑定的不同之处在于，该属性由类型绑定中标识的所有实例共享。更改一个类型的参数会影响同一类型的所有实例。</p>
<p>下面的代码示例演示如何使用共享参数文件添加参数定义。以下代码执行的操作与使用Revit UI中的对话框执行的操作相同。参数定义按以下顺序创建：</p>
<ol>
<li>将创建共享参数文件。</li>
<li>将为墙类型创建定义组和参数定义。</li>
<li>定义将根据墙类别绑定到当前文档中的墙类型参数。</li>
</ol>
<p>代码区域22-7：使用共享参数文件添加类型参数定义</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToTypeWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a type definition</span></span><br><span class="line">    ExternalDefinitionCreationOptions option = <span class="keyword">new</span> ExternalDefinitionCreationOptions(<span class="string">&quot;CompanyName&quot;</span>, ParameterType.Text);</span><br><span class="line">    Definition myDefinition_CompanyName = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// Use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an object of TypeBinding according to the Categories</span></span><br><span class="line">    TypeBinding typeBinding = app.Application.Create.NewTypeBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> typeBindOK = bindingMap.Insert(myDefinition_CompanyName, typeBinding,</span><br><span class="line">        BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> typeBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Instance-Binding"><a href="#Instance-Binding" class="headerlink" title="Instance Binding"></a>Instance Binding</h4><p>InstanceBinding对象指示参数定义和某些类别实例中的参数之间的绑定。</p>
<p>Once bound, the parameter appears in all property dialog boxes for the instance (if the visible property is set to true). Changing the parameter in any one instance does not change the value in any other instance.<br>绑定后，该参数将显示在实例的所有属性对话框中（如果visible属性设置为true）。在任何一个实例中更改参数不会更改任何其他实例中的值。</p>
<p>The following code sample demonstrates how to add parameter definitions using a shared parameter file. Parameter definitions are added in the following order:<br>下面的代码示例演示如何使用共享参数文件添加参数定义。参数定义按以下顺序添加：</p>
<ol>
<li>A shared parameter file is created<br>创建共享参数文件</li>
<li>A definition group and a definition for all Walls instances is created<br>将创建所有墙实例的定义组和定义</li>
<li>Definitions are bound to each wall instance parameter in the current document based on the wall category.<br>定义将根据墙类别绑定到当前文档中的每个墙实例参数。</li>
</ol>
<p>代码区域22-8：使用共享参数文件添加实例参数定义</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToInstanceWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an instance definition in definition group MyParameters</span></span><br><span class="line">    ExternalDefinitonCreationOptions option = <span class="keyword">new</span> ExternalDefinitonCreationOptions(<span class="string">&quot;Instance_ProductDate&quot;</span>, ParameterType.Text);</span><br><span class="line">    <span class="comment">// Don&#x27;t let the user modify the value, only the API</span></span><br><span class="line">    option.UserModifiable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Set tooltip</span></span><br><span class="line">    option.Description = <span class="string">&quot;Wall product date&quot;</span>;</span><br><span class="line">    Definition myDefinition_ProductDate = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an instance of InstanceBinding</span></span><br><span class="line">    InstanceBinding instanceBinding = app.Application.Create.NewInstanceBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> instanceBindOK = bindingMap.Insert(myDefinition_ProductDate,</span><br><span class="line">                                    instanceBinding, BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> instanceBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SharedParameterElement"><a href="#SharedParameterElement" class="headerlink" title="SharedParameterElement"></a>SharedParameterElement</h3><p>SharedParameterElements存储有关文档中特定用户定义的共享参数的信息</p>
<p>用户定义的参数存储在文档中，并由ParameterElement类表示。子类SharedParameterElement表示加载到文档中的共享参数。ParemeterElement也是GlobalParameter的基类。</p>
<p>一旦共享参数被加载到文档中，就可以从SharedParameterElement类中检索有关它的信息。SharedParameterElement从父ParameterElement类继承GetDefinition()方法。GetDefinition()返回表示文档中参数定义的InternalDefinition，而不是存储在共享参数文件中的共享参数的ExternalDefinition。SharedParameterElement还通过GuidValue属性提供对标识共享参数的Guid的访问。</p>
<p>该类的静态Create()方法可以从ExternalDefinition在文档中创建一个新的SharedParameterElement。</p>
<p>静态函数可以从给定的Guid中检索SharedParameterElement。</p>
<p>在下面的示例中，明细表包含一个表示共享参数值的字段。从SharedParameterElement检索共享参数的定义。</p>
<p>代码区域：获取共享参数的定义</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if a given shared parameter in a schedule can vary across groups</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanParamVaryAcrossGroups</span>(<span class="params">ViewSchedule schedule, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> variesAcrossGroups = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numFields =  schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="comment">// Find the field with the given name</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numFields; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              ScheduleField field = schedule.Definition.GetField(i);</span><br><span class="line">        <span class="keyword">if</span> (field.GetName().Contains(sharedParamName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the SharedParameterElement from the field&#x27;s parameter id</span></span><br><span class="line">            SharedParameterElement spe = schedule.Document.GetElement(field.ParameterId) <span class="keyword">as</span> SharedParameterElement;</span><br><span class="line">            <span class="keyword">if</span> (spe != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                InternalDefinition definition = spe.GetDefinition();</span><br><span class="line">                variesAcrossGroups = definition.VariesAcrossGroups;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> variesAcrossGroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SharedParameterElements在使用RebarContainers时特别有用。可以将共享参数作为覆盖添加到RebarContainer的参数管理器中。shared参数不需要绑定到要作为覆盖添加的任何类别。下面的示例将给定的共享参数作为重写添加到RebarContainer。</p>
<p>代码区域：使用SharedParameterElement重写RebarContainer</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the named shared parameter and add it as an override to the parameter manger for the given RebarContainer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSharedParameterOverride</span>(<span class="params">RebarContainer container, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find the shared parameter guid</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(container.Document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(SharedParameterElement));</span><br><span class="line">    IEnumerable paramCollector = collector.Cast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (SharedParameterElement spe <span class="keyword">in</span> paramCollector)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (spe.Name.CompareTo(sharedParamName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RebarContainerParameterManager paramManager = container.GetParametersManager();</span><br><span class="line">            paramManager.AddSharedParameterAsOverride(spe.Id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>全局参数支持通过项目文档中定义的特殊参数控制几何约束。</p>
<p>全局参数可用于标注和报告至&#x2F;自标注，以及设置实例参数的值。它们可用于驱动尺寸或其他元素参数的值，也可由选定尺寸驱动，选定尺寸的值将确定全局参数的值。</p>
<p>本节中的页面</p>
<ul>
<li>管理全局参数</li>
<li>全局参数基础</li>
<li>报告与非报告参数</li>
<li>公式和全局参数</li>
<li>使用全局参数标注标注</li>
</ul>
<h3 id="管理全局参数"><a href="#管理全局参数" class="headerlink" title="管理全局参数"></a>管理全局参数</h3><p>GlobalParametersManager类提供对特定模型中的全局参数元素的常规信息和数据的访问。</p>
<p>GlobalParametersManager提供了管理项目文档中全局参数的主要访问点。它提供了静态方法来访问和重新排序全局参数，并测试名称的唯一性和ID的有效性。</p>
<h4 id="全局参数-1"><a href="#全局参数-1" class="headerlink" title="全局参数"></a>全局参数</h4><p>仅在项目文档中支持全局参数，而在族文档中不支持全局参数。然而，即使有项目文件，在某些情况下也可能暂时或永久地不允许使用全局参数。AreGlobalParametersAllowed()方法将指示在指定文档中是否允许全局参数。</p>
<p>如果允许在项目文档中使用全局参数，请使用方法GetAllGlobalParameters()获取指定文档中的所有全局参数，或使用GetGlobalParametersOrdered()获取全局参数的有序列表。检索有序列表时，项目的顺序与Revit用户界面中标准“全局参数”对话框中全局参数的显示顺序相对应。</p>
<p>要按名称获取全局参数，请调用FindByName()，它将返回命名的全局参数的ElementId，如果没有找到具有给定名称的全局参数，则返回ElementId.InvalidElementId。由于全局参数名称必须是唯一的，因此应在创建新的GlobalParameter之前调用IsUniqueName()方法来检查名称。</p>
<p>给定全局参数的ElementId，IsValidGlobalParameter()将确认给定的ElementId是有效的全局参数id。</p>
<p>下面的示例演示如何获取所有全局参数（如果文档中允许全局参数）。</p>
<p>代码区域：获取全局参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Returns all global parameter elements defined in the given document. </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of ElementIds of global parameter elements</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISet <span class="title">GetAllGlobalParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Global parameters are not available in all documents.</span></span><br><span class="line">    <span class="comment">// They are available in projects, but not in families.</span></span><br><span class="line">    <span class="keyword">if</span> (GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalParametersManager.GetAllGlobalParameters(document);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return an empty set if global parameters are not available in the document</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重新排序全局参数"><a href="#重新排序全局参数" class="headerlink" title="重新排序全局参数"></a>重新排序全局参数</h4><p>GlobalParametersManager提供了更改项目文档中全局参数的给定顺序的方法。这些操作对全局参数本身没有影响。重新排列的顺序仅在Revit的标准“全局参数”对话框中可见，并反映在GetGlobalParametersOrdered()方法中。</p>
<ul>
<li>SortParameters()-按字母顺序的升序或降序对全局参数进行排序，但仅在其各自的参数组范围内。</li>
<li>MoveParameterDownOrder()-按当前顺序向下移动给定参数。</li>
<li>MoveParameterUpOrder()-将给定参数按当前顺序上移。一个参数只能在其参数组内移动，所以如果一个参数因为位于其组的边界而不能再移动，MoveParameter方法将返回False。</li>
</ul>
<h3 id="全局参数基础"><a href="#全局参数基础" class="headerlink" title="全局参数基础"></a>全局参数基础</h3><p>GlobalParameter类表示项目文档中的全局参数，可用于创建和修改全局参数。</p>
<h4 id="创建全局参数"><a href="#创建全局参数" class="headerlink" title="创建全局参数"></a>创建全局参数</h4><p>全局参数只能在项目文档中创建，而不能在族中创建。全局参数通过静态Create()方法在给定文档中创建，具有给定的名称和参数类型。每个新参数在文档中必须有一个唯一的名称，可以使用静态GlobalParametersManager.IsUniqueName()方法确定该名称。全局参数几乎可以使用任何类型的数据创建，但有几种类型目前不受支持，例如ElementId类型。使用静态GlobalParameter.IsValidDataType()方法测试特定数据类型是否适合全局参数。</p>
<p>代码区域：创建新的全局参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Creates a new Global Parameter of type Length, assigns it an initial value,</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> and uses it to label a set of input dimension elements.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document in which to create the parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Name of the global parameter to create.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A value the new global parameter is to have.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of dimension to labe by the new global parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ElementId of the new GlobalParameter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ElementId <span class="title">CreateNewGlobalParameter</span>(<span class="params">Document document, String name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimensionsToLabel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ElementId gpid = ElementId.InvalidElementId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        GlobalParameter gp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (gp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if created successfully, assign it a value</span></span><br><span class="line">            <span class="comment">// note: parameters of type Length accept Double values</span></span><br><span class="line">            gp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if a collection of dimensions was given, label them with this new parameter</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimensionsToLabel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (gp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    gp.LabelDimension(elemid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gpid = gp.Id;</span><br><span class="line">        &#125;</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取和设置全局参数的值"><a href="#获取和设置全局参数的值" class="headerlink" title="获取和设置全局参数的值"></a>获取和设置全局参数的值</h4><p>所有全局参数，无论是公式驱动的、尺寸驱动的还是独立的，都有值。可以通过调用GetValue()方法来获取值。该方法返回的对象是从ParameterValue类派生的类之一的实例：</p>
<ul>
<li>IntegerParameterValue </li>
<li>DoubleParameterValue</li>
<li>StringParameterValue</li>
</ul>
<p>所有派生类都只有一个属性Value，它获取或设置相应类型的值。</p>
<p>具体实例由创建时指定的全局参数的类型确定。既不是公式驱动的参数也不是维度驱动的参数（报告）可以被赋值。要使用的方法是SetValue()，它接受GetValue()返回的相同类型的参数值。但是，类型也可以很容易地推导出来：Text参数只接受StringParameterValue。Integer 和 YesNo 参数仅接受IntegerParameterValue。所有其他参数仅接受DoubleParameterValue。</p>
<h4 id="受全局参数影响的元素"><a href="#受全局参数影响的元素" class="headerlink" title="受全局参数影响的元素"></a>受全局参数影响的元素</h4><p>全局参数可以与其他全局参数以及常规族实例参数相关联（常规族实例参数可以通过指定公式将全局参数报告为它们的值）。有两种方法可用于查找参数之间的关系：GlobalParameter.GetAffectedGlobalParameters()和GlobalParameter.GetAffectedElements()。前者返回在其各自的公式中引用特定全局参数的所有其他全局参数。后一个方法返回一组所有元素，其中一些参数由全局参数控制。这两个方法与GlobalParameter.GetLabeledDimensions()一起可以帮助确定模型元素如何通过全局参数相互关联。</p>
<p>可以在Parameter类中找到用于维护元素属性和全局参数之间的关联的方法。</p>
<h3 id="报告与非报告参数"><a href="#报告与非报告参数" class="headerlink" title="报告与非报告参数"></a>报告与非报告参数</h3><p>全局参数类型的最大区别是它们是报告参数还是非报告参数。</p>
<h4 id="什么是报告和非报告参数？"><a href="#什么是报告和非报告参数？" class="headerlink" title="什么是报告和非报告参数？"></a>什么是报告和非报告参数？</h4><p>有几种方法可以对全局参数进行分类，但最重要的分类可能源于GlobalParameter.IsReporting属性，该属性将全局参数分为两组-报告和非报告。报告参数的重要性在于它们的值由报告参数标记的维度驱动。这意味着报告参数的值反映了尺寸（长度或角度）的值，并在尺寸更改时更新。非报告参数的行为方式相反-它们驱动已由其标记的尺寸的值，这导致通过全局参数的值控制模型的几何体。</p>
<p>报告参数在几个方面受到限制。它们只能是“长度”或“角度”类型，这是因为尺寸必须能够驱动值。出于同样的原因，报告参数可能没有公式。</p>
<p>另一方面，非报告参数几乎可以是任何类型（长度、宽度、面积等）。ElementId类型除外。此外，非报告参数可能已分配公式，其中其他全局参数可用作参数。这样，一个全局参数的值可以从其他参数（或多个参数）导出，而其他参数可以是报告或非报告的。</p>
<p>全局参数的其他重要属性是IsDrivenByDimension和IsDrivenByFormula，它们是互斥的-分配了公式的参数不能由维驱动（也不能由报告驱动），反之亦然。</p>
<h4 id="使全局参数报告或不报告"><a href="#使全局参数报告或不报告" class="headerlink" title="使全局参数报告或不报告"></a>使全局参数报告或不报告</h4><p>全局参数在创建时最初是非报告的，但一旦创建了全局参数并且属于合格类型，就可以使用GlobalParameter.IsReporting属性将其设置为报告。使用GlobalParameter.HasValidTypeForReporting()确保可以使特定数据类型进行报告。请注意，当一个参数标记了多个维度后，该参数可能无法进行报告。这是因为报告参数只能标记一个维度（并由一个维驱动）。</p>
<p>生成参数报告的另一种方法是通过GlobalParameter.SetDrivingDimension()方法，该方法通过全局参数标记一个维度，如果尚未报告，则也生成参数报告。</p>
<p>尽管由尺寸驱动的参数会自动生成报告，但由公式驱动的参数则不会。为了设置公式，全局参数必须为非报告参数。因此，在分配公式之前，必须首先将报告参数更改为非报告参数。</p>
<h3 id="公式和全局参数"><a href="#公式和全局参数" class="headerlink" title="公式和全局参数"></a>公式和全局参数</h3><p>公式可以分配给非报告参数。</p>
<p>与族参数一样，可以使用GlobalParameter.SetFormula()方法将公式分配给全局参数。由于要设置公式，全局参数必须为非报告参数，因此在分配公式之前，必须将报告参数更改为非报告参数。</p>
<p>计算公式的值必须与参数的值类型兼容。例如，允许在分配给Double（<strong>Number</strong>）参数的公式中使用<strong>NULL</strong>参数，反之亦然。但是，不允许在公式中的参数类型为<strong>“ether”</strong>或“<strong>Number”</strong>的参数中使用<strong>Length</strong>或<strong>Angle</strong>参数。</p>
<p>公式可以包括所有标准的算术运算和逻辑运算（如函数<strong>and</strong>，<strong>or</strong>，<strong>not</strong>）。逻辑运算的输入必须是布尔值（YesNo类型的参数）。因此，算术运算只能应用于数值。虽然字符串（文本）参数不支持任何操作，但字符串可以用作逻辑<strong>If</strong>操作的结果。根据其类型（和单位），不同值类型的参数可以组合。但是，无单位值（例如<strong>，“”</strong>和<strong>“Number</strong>（double）”）只能相互组合。</p>
<p>由于公式可能会变得非常复杂，并且由于某些公式无法分配给某些参数，因此可以使用IsValidFormula()方法来测试公式对于全局参数是否有效。如果调用SetFormula()时全局参数的公式无效，则将引发异常。</p>
<p>GetFormula()将以字符串的形式返回当前公式。</p>
<p>下面的代码示例创建四个全局参数，然后将公式设置为1，以便它的值为其他两个参数中的任何一个，具体取决于第四个参数的布尔值。</p>
<p>代码区域：设置公式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCombinationParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GlobalParameter gpB = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpT = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpF = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpX = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transaction to create global parameters and set their values</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating global parameters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create 4 new global parameters</span></span><br><span class="line"></span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        gpB = GlobalParameter.Create(document, <span class="string">&quot;GPB&quot;</span>, ParameterType.YesNo);</span><br><span class="line">        gpT = GlobalParameter.Create(document, <span class="string">&quot;GPT&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpF = GlobalParameter.Create(document, <span class="string">&quot;GPF&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpX = GlobalParameter.Create(document, <span class="string">&quot;GPX&quot;</span>, ParameterType.Text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign initial values and a formula to the global parameters</span></span><br><span class="line"></span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(TRUE));</span><br><span class="line">        gpT.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeA&quot;</span>));</span><br><span class="line">        gpF.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeB&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the formula to GPX so that its final value is either the value of GPT (TypeA)</span></span><br><span class="line">        <span class="comment">// or GPF (TypeB) depending on whether the value of GPB is True or False.</span></span><br><span class="line">        <span class="comment">// Note: in this particular case we are certain the formula is valid, but if weren&#x27;t </span></span><br><span class="line">        <span class="comment">// certain, we could use a validation method as we are now going to illustrate here:</span></span><br><span class="line">        <span class="built_in">string</span> expression = <span class="string">&quot;if(GPB,GPT,GPF)&quot;</span>; <span class="comment">// XPX &lt;== if (GPB == TRUE) then GPT else GPF</span></span><br><span class="line">        <span class="keyword">if</span> (gpX.IsValidFormula(expression))</span><br><span class="line">        &#123;</span><br><span class="line">            gpX.SetFormula(expression);        &#125;</span><br><span class="line"></span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can test that the formula works</span></span><br><span class="line">    <span class="comment">// since the boolean value is TRUE, the value of the GPX parameter</span></span><br><span class="line">    <span class="comment">// should be the same as the value of the GPT parameters</span></span><br><span class="line"></span><br><span class="line">    StringParameterValue sTrue = gpT.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sFalse = gpF.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sTrue.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can also test that evaluation of the formula is affected by changes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change value of a YesNo parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(FALSE));</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sFalse.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用全局参数标注标注"><a href="#使用全局参数标注标注" class="headerlink" title="使用全局参数标注标注"></a>使用全局参数标注标注</h3><p>全局参数的一个关键特性是它们能够“标记”尺寸。</p>
<p>当维度由全局参数标记时，其值要么由参数控制（非报告），要么驱动参数的值（报告）。需要注意的是，报告参数最多只能标记一个维对象，这意味着参数只能由一个维驱动。如果尺寸标注有多个线段，并且由非报告参数标记，则每个线段的值将由该参数驱动。多段维不能用报告参数标记。</p>
<p>如果该维度已被另一个全局参数标记，则再次标记它将自动将其与该参数分离。</p>
<p>目前，只能标记单个<strong>线性</strong>和<strong>角度</strong>尺寸，但也有其他限制。使用CanLabelDimension()方法来确定是否可以标记特定的维度元素。此外，由于参数的值和由其标记的尺寸相互依赖，因此全局参数的数据类型必须是<strong>Length</strong>或<strong>Angle</strong>，因为这是尺寸可以表示的唯一单位。</p>
<p>下面的示例创建一个全局参数，并使用它来标记给定维度元素集。</p>
<p>代码区域：标签尺寸</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">DriveSelectedDimensions</span>(<span class="params">Document document, <span class="built_in">string</span> name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt;= <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Value of a global parameter that drives dimension must be a positive number&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nLabeledDims = <span class="number">0</span>;   <span class="comment">// number of labeled dimensions (for testing)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        <span class="comment">// Note: Length (or Angle) is required type of global parameters that are to label a dimension</span></span><br><span class="line">        GlobalParameter newgp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (newgp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newgp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the parameter to label the given dimensions</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (newgp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    newgp.LabelDimension(elemid);</span><br><span class="line">                    nLabeledDims += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for illustration purposes only, we&#x27;ll test the results of our modifications </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.) Check the new parameter can be found</span></span><br><span class="line"></span><br><span class="line">    ElementId gpid = GlobalParametersManager.FindByName(document,name);</span><br><span class="line">    <span class="keyword">if</span> (gpid == ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Failed to find a newly created global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Check the number of labeled dimension is as expected</span></span><br><span class="line"></span><br><span class="line">    ISet labeledSet = gp.GetLabeledDimensions();</span><br><span class="line">    <span class="keyword">if</span> (labeledSet.Count != nLabeledDims)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Have not found all the dimension that were labeled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labeledSet.Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetDrivingDimension()方法结合了两个操作：a）如果参数尚未报告，则进行参数报告，以及B）使用它标记给定维。因此，全局参数必须符合报告条件，并且不得用于标记多个维。有关报告参数的详细信息，请参阅报告参数与非报告参数页面 如果此参数已由另一个维度驱动，则在标记给定的维度之前，将首先取消标记另一个维度。这是因为报告参数一次只能标记一个维度（即，它只能由一个维度驱动）。 下一个示例创建由尺寸值驱动的全局参数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AssignDrivingDimension</span>(<span class="params">Document document, ElementId gpid, ElementId dimid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we expect to find the global parameter in the document</span></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line">    <span class="keyword">if</span> (gp == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we expect to find the given dimension in the document</span></span><br><span class="line">    Dimension dim = document.GetElement(dimid) <span class="keyword">as</span> Dimension;</span><br><span class="line">    <span class="keyword">if</span> (dim == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not every global parameter can label</span></span><br><span class="line">    <span class="comment">// and not every dimension can be labeled</span></span><br><span class="line">    <span class="keyword">if</span> (!gp.CanLabelDimension(dimid))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need a transaction to modify the model</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document,<span class="string">&quot;Assign a driving dimension&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we cannot assign a driving dimension to a global</span></span><br><span class="line">        <span class="comment">// parameter that is already used to label other dimensions</span></span><br><span class="line">        ISet dimset = gp.GetLabeledDimensions();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">        &#123;</span><br><span class="line">            gp.UnlabelDimension(elemid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// with the GP free of all previously labels (if there were any)</span></span><br><span class="line">        gp.SetDrivingDimension(dimid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we should be able to commit, but we test the result anyway</span></span><br><span class="line">        <span class="keyword">if</span> (trans.Commit() != TransactionStatus.Committed)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><p>Parameter类包含给定参数的值。</p>
<p>Autodesk Revit中的所有图元都包含参数，这些参数可以作为一个集合或单独检索。可以使用BuiltInParameter枚举、Definition对象或Shared Parameter对象从任何Element中获取单个参数对象。参数中包含的数据可以是Double、String、String或ElementId，如其String Type属性所示。对于值类型，DisplayUnitType属性将指示用于参数值的显示单位。Parameter对象还包含一个Definition对象，用于描述参数的数据类型、名称和其他详细信息。</p>
<h3 id="StorageType"><a href="#StorageType" class="headerlink" title="StorageType"></a>StorageType</h3><p>储存类型描述内部存储的参数值的类型。</p>
<p>根据属性值，使用相应的get和set方法来检索和设置参数数据值。</p>
<p>“储存类型”是一种枚举类型，列出了Revit支持的所有内部参数数据存储类型：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>String</em></td>
<td>内部数据存储为字符串。</td>
</tr>
<tr>
<td><em>ElementId</em></td>
<td>数据类型表示一个元素，并存储为元素ID。</td>
</tr>
<tr>
<td><em>Double</em></td>
<td>数据在内部存储为8字节浮点数。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>内部数据存储为有符号的32位整数。</td>
</tr>
<tr>
<td><em>None</em></td>
<td>无表示无效的存储类型。仅供内部使用。</td>
</tr>
</tbody></table>
<p>在大多数情况下，ElementId值为正数。但是，它可以是负数。当ElementId值为负时，它不表示元素，而是具有另一种含义。例如，梁的垂直投影的存储类型参数为ElementId。当参数值为Level 1或Level 2时，ElementId值为正，并与该级别的ElementId相对应。但是，当参数值设置为“自动检测”、“梁中心”或“梁顶部”时，ElementId值为负值。 下面的代码示例显示如何根据参数的类型检查参数的值是否可以设置为double值：</p>
<p>代码区域：检查参数的类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetParameter</span>(<span class="params">Parameter parameter, <span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//if the parameter is readonly, you can&#x27;t change the value of it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != parameter &amp;&amp; !parameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        StorageType parameterType = parameter.StorageType;</span><br><span class="line">        <span class="keyword">if</span> (StorageType.Double != parameterType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;The storagetypes of value and parameter are different!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = parameter.Set(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Set()方法返回值指示参数值已更改。Set()方法在参数值被更改时返回true，否则返回false。 并非所有参数都是可写的。如果参数为只读，则引发异常。 ## AsValueString()和SetValueString() 这两个Parameter类方法仅适用于值类型参数，这些参数是表示测量量的双精度或整数参数。 使用AsValueString()方法以带有度量单位的字符串形式获取参数值。例如，“底部偏移”值（墙参数）为“双精度”值。通常，该值在“图元属性”中显示为字符串，如-20 ‘0”。使用AsValueString()方法，您可以直接获得-20 ‘0”字符串值。使用AsDouble()方法，可以得到一个不带度量单位的double值，如-20。 使用SetValueString()方法更改值类型参数的值，而不是使用Set()方法。下面的代码示例说明如何使用SetValueString()方法更改参数值：</p>
<p>使用参数. SetValueString()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetWithValueString</span>(<span class="params">Parameter foundParameter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!foundParameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = foundParameter.SetValueString(<span class="string">&quot;-22\&#x27;3\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局参数关联"><a href="#全局参数关联" class="headerlink" title="全局参数关联"></a>全局参数关联</h3><p>Parameter类有几种方法用于维护元素参数和全局参数之间的关联。方法GetAssociatedGlobalParameter()返回当前与参数关联的全局参数的ElementId（如果有）。如果此参数未与任何全局参数关联，则返回InvalidElementId。InvalidElementId也会在为一个甚至不能与全局参数相关联的参数（即一个不可参数化的参数或一个带有公式的参数）调用时返回。</p>
<p>有两种方法可以确定参数是否可以与全局参数关联。参数.CanBeAssociatedWithGlobalParameters()测试参数是否可以与任何全局参数相关联。只有定义为可参数化的属性才能与全局参数相关联。这不包括任何只读参数和公式驱动参数，以及具有Revit施加的其他显式或隐式限制的参数。若要测试特定全局参数是否可以与此参数关联，请使用Parameter.CanBeAssociatedWithGlobalParameter()。请记住，参数的值类型必须与全局参数的类型匹配，才能创建关联。</p>
<p>对于可以与全局参数关联的参数，请使用AssociateWithGlobalParameter()创建关联。关联后，可以在以后通过调用DissociateFromGlobalParameter()方法解除参数关联</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/07%E5%8F%82%E6%95%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/06%E9%80%89%E6%8B%A9/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Selection_html">选择</a></h1><p>您可以使用UIDo.Selection.GetElementIds()方法从当前活动文档中获取所选对象，该方法返回所选元素的ElementIds集合。此方法返回的集合可以直接与FilteredElementCollector一起使用，以筛选选定的元素。</p>
<p>Selection对象还可以用于使用SetElementIds()方法以编程方式更改当前选择。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Changing the Selection 更改选择</li>
<li>User Selection 用户选择</li>
<li>Filtered User Selection 筛选的用户选择</li>
</ul>
<h2 id="更改选择"><a href="#更改选择" class="headerlink" title="更改选择"></a>更改选择</h2><p>要修改选定的图元，请执行以下操作：</p>
<ol>
<li>创建新的ElementId列表。</li>
<li>把ElementIds放进去。</li>
<li>使用新列表调用SetElementIds()。</li>
</ol>
<p>下面的示例说明了如何通过获取当前选择并仅过滤出墙以设置为新选择来更改选定的元素。</p>
<p><strong>代码区域7-1：更改所选元素</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeSelection</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get selected elements from current document.</span></span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display current number of selected elements</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Number of selected elements: &quot;</span> + selectedIds.Count.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the selected items and filter out walls only.</span></span><br><span class="line">    ICollection selectedWallIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element elements = uidoc.Document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (elements <span class="keyword">is</span> Wall)</span><br><span class="line">        &#123;</span><br><span class="line">            selectedWallIds.Add(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the created element set as current select element set.</span></span><br><span class="line">    uidoc.Selection.SetElementIds(selectedWallIds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != selectedWallIds.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, selectedWallIds.Count.ToString() + <span class="string">&quot; Walls are selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;No Walls have been selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户选择"><a href="#用户选择" class="headerlink" title="用户选择"></a>用户选择</h2><p>Selection类也有一些方法，允许用户选择新对象，甚至是屏幕上的一个点。这允许用户使用光标选择一个或多个元素（或其他对象，如边或面），然后将控制权返回给应用程序。这些函数不会自动将新选区添加到活动选区集合中。</p>
<ul>
<li>PickObject()方法提示用户在Revit模型中选择对象。</li>
<li>PickObjects()方法提示用户在Revit模型中选择多个对象。</li>
<li>PickElementsByRectangle()方法提示用户使用矩形选择多个元素。</li>
<li>PickPoint()方法提示用户在活动草图平面中拾取点。</li>
<li>PickBox()方法调用一个通用的双击编辑器，让用户在屏幕上指定一个矩形区域。</li>
</ul>
<p>调用PickObject()或PickObject时指定要选择的对象类型。可以指定的对象类型有：元素、PointOnElement、边或面。</p>
<p>当应用程序提示用户拾取对象或元素时，StatusbarTip属性在状态栏中显示一条消息。每个Pick函数都有一个重载，该重载具有一个String参数，可以在其中提供自定义状态消息。</p>
<p>代码区域7-2：使用PickObject()和PickElementsByRectangle()添加选定元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">Selection choices = uidoc.Selection;</span><br><span class="line"><span class="comment">// Pick one object from Revit.</span></span><br><span class="line">Reference hasPickOne = choices.PickObject(ObjectType.Element);</span><br><span class="line"><span class="keyword">if</span> (hasPickOne != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;One element selected.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the rectangle picking tool to identify model elements to select.</span></span><br><span class="line">IList pickedElements = uidoc.Selection.PickElementsByRectangle(<span class="string">&quot;Select by rectangle&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pickedElements.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// Collect Ids of all picked elements</span></span><br><span class="line">    IList idsToSelect = <span class="keyword">new</span> List(pickedElements.Count);</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> pickedElements)</span><br><span class="line">    &#123;</span><br><span class="line">        idsToSelect.Add(element.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the current selection</span></span><br><span class="line">    uidoc.Selection.SetElementIds(idsToSelect);</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125; elements added to Selection.&quot;</span>, idsToSelect.Count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickPoint()方法有2个重载，其中ObjectSnapTypes参数用于指定用于选择的捕捉类型的类型。可以指定多个，如下一个示例所示。</p>
<p>代码区域7-3：捕捉点</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickPoint</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        ObjectSnapTypes snapTypes = ObjectSnapTypes.Endpoints | ObjectSnapTypes.Intersections;</span><br><span class="line">        XYZ point = uidoc.Selection.PickPoint(snapTypes, <span class="string">&quot;Select an end point or intersection&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> strCoords = <span class="string">&quot;Selected point is &quot;</span> + point.ToString();</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, strCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickBox()方法接受一个PickBoxStyle枚举器。这些选项包括“交叉”、“包围”和“方向”，前者是选择完全或部分位于框内的对象时使用的样式，后者是选择完全被框包围的对象时使用的样式，前者是框的样式取决于框的绘制方向。如果从右向左绘制，则使用“交叉”样式;如果以相反方向绘制，则使用“包围”样式。 PickBox()返回一个PickedBox，其中包含选定的Min和Max点。以下示例演示了在点云选择中使用PickBox()。</p>
<p>代码区域：PickBox</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PromptForPointCloudSelection</span>(<span class="params">UIDocument uiDoc, PointCloudInstance pcInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = uiDoc.Application.Application;</span><br><span class="line">    Selection currentSel = uiDoc.Selection;</span><br><span class="line"></span><br><span class="line">    PickedBox pickedBox = currentSel.PickBox(PickBoxStyle.Enclosing, <span class="string">&quot;Select region of cloud for highlighting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    XYZ min = pickedBox.Min;</span><br><span class="line">    XYZ max = pickedBox.Max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Transform points into filter</span></span><br><span class="line">    View view = uiDoc.ActiveView;</span><br><span class="line">    XYZ right = view.RightDirection;</span><br><span class="line">    XYZ up = view.UpDirection;</span><br><span class="line"></span><br><span class="line">    List planes = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X boundaries</span></span><br><span class="line">    <span class="built_in">bool</span> directionCorrect = IsPointAbovePlane(right, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(right, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-right, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y boundaries</span></span><br><span class="line">    directionCorrect = IsPointAbovePlane(up, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(up, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-up, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create filter</span></span><br><span class="line">    PointCloudFilter filter = PointCloudFilterFactory.CreateMultiPlaneFilter(planes);</span><br><span class="line">    Transaction t = <span class="keyword">new</span> Transaction(uiDoc.Document, <span class="string">&quot;Highlight&quot;</span>);</span><br><span class="line">    t.Start();</span><br><span class="line">    pcInstance.SetSelectionFilter(filter);</span><br><span class="line">    pcInstance.FilterAction = SelectionFilterAction.Highlight;</span><br><span class="line">    t.Commit();</span><br><span class="line">    uiDoc.RefreshActiveView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="筛选的用户选择"><a href="#筛选的用户选择" class="headerlink" title="筛选的用户选择"></a>筛选的用户选择</h2><p>PickObject()、PickObjects()和PickElementsByRectangle()都具有将ISelectionFilter作为参数的重载。ISelectionFilter是一个接口，可用于在选择操作期间过滤对象。它有两个可以覆盖的方法：AllowElement()用于指定是否允许选择元素，以及AllowReference()用于指定是否允许选择对一段几何图形的引用。</p>
<p>下面的示例阐释如何使用ISelectionFilter接口将用户的选择限制为“体量”类别中的元素。它不允许选择对几何图元的任何参照。</p>
<p>使用ISelectionFilter限制元素选择</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList <span class="title">GetManyRefByRectangle</span>(<span class="params">UIDocument doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> MassSelectionFilter();</span><br><span class="line">        IList eList = doc.Selection.PickElementsByRectangle(selFilter, </span><br><span class="line">                <span class="string">&quot;Select multiple faces&quot;</span>) <span class="keyword">as</span> IList;</span><br><span class="line">        <span class="keyword">return</span> eList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MassSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.Category.Name == <span class="string">&quot;Mass&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何使用ISelectionFilter仅允许选择平面。</p>
<p>代码区域7-5：使用ISelectionFilter限制几何选择</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectPlanarFaces</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> PlanarFacesSelectionFilter(document);</span><br><span class="line">        IList faces = uidoc.Selection.PickObjects(ObjectType.Face, </span><br><span class="line">                selFilter, <span class="string">&quot;Select multiple planar faces&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlanarFacesSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        Document doc = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PlanarFacesSelectionFilter</span>(<span class="params">Document document</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                doc = document;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;                <span class="keyword">if</span> (doc.GetElement(refer).GetGeometryObjectFromReference(refer) <span class="keyword">is</span> PlanarFace)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Only return true for planar faces. Non-planar faces will not be selectable </span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关从选定元素中检索元素的更多信息，请参见“入门”部分中的演练：检索选定元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/06%E9%80%89%E6%8B%A9/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/05%E8%BF%87%E6%BB%A4/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Filtering-过滤"><a href="#Filtering-过滤" class="headerlink" title="Filtering 过滤"></a>Filtering 过滤</h1><p>Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。</p>
<p>获取通过指定过滤器的元素的基本步骤如下：</p>
<ol>
<li>创建新的FilteredElementCollector</li>
<li>对它应用一个或多个过滤器</li>
<li>获取过滤后的元素或元素ID（使用以下几种方法之一）</li>
</ol>
<p>下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。</p>
<p><strong>代码区域6-1：使用元素过滤获取文档中的所有墙实例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all Wall instances in the document by using category filter</span></span><br><span class="line">ElementCategoryFilter filter = <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// Use shortcut WhereElementIsNotElementType() to find wall instances only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList walls = </span><br><span class="line">collector.WherePasses(filter).WhereElementIsNotElementType().ToElements();</span><br><span class="line">String prompt = <span class="string">&quot;The walls in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> walls)</span><br><span class="line">&#123;</span><br><span class="line">        prompt += e.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p><strong>Pages in this section 本节中的页面</strong></p>
<ul>
<li>创建FilteredElementCollector</li>
<li>应用过滤器</li>
<li>获取筛选的元素或元素ID</li>
<li>LINQ查询</li>
<li>边界框过滤器</li>
<li>元素交叉过滤器</li>
</ul>
<h2 id="创建FilteredElementCollector"><a href="#创建FilteredElementCollector" class="headerlink" title="创建FilteredElementCollector"></a>创建FilteredElementCollector</h2><p>用于元素迭代和筛选的主类称为FilteredElementCollector。它以三种方式之一构建：</p>
<ol>
<li>从文档-将搜索和筛选文档中的元素集</li>
<li>从一个文档和一组ElementId-将搜索和筛选一组指定的元素</li>
<li>从文档和视图-将搜索和过滤视图中的可见元素</li>
</ol>
<p><em><strong>注意：</strong></em>使用静态FilteredElementCollector.IsViewValidForElementIteration()过滤指定视图中的元素时，请始终检查视图是否对元素迭代有效。</p>
<p>首次创建对象时，没有应用任何过滤器。此类要求在尝试访问元素之前至少设置一个条件，否则将引发异常。</p>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h2><p>可以使用ElementFilters将筛选器应用于FilteredElementCollector。ElementFilter是一个类，它检查元素以查看它是否满足特定条件。ElementFilter基类有三个派生类，它们将元素筛选器分为三个类别。</p>
<ul>
<li><em><strong>ElementQuickFilter</strong></em>-快速过滤器仅在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。</li>
<li><em><strong>ElementSlowFilter</strong></em>-慢过滤器要求首先获取元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。</li>
<li><em><strong>ElementLogicalFilter</strong></em>-逻辑筛选器将联合收割机两个或多个筛选器逻辑组合。Revit可能会对构件过滤器重新排序，以使最快作用的过滤器首先被评估。</li>
</ul>
<p>大多数过滤器可以使用重载构造函数来反转，该重载构造函数接受指示反转过滤器的布尔参数，以便通常被过滤器接受的元素将被拒绝，而通常被拒绝的元素将被接受。不能反转的过滤器在下面的相应部分中注明。</p>
<p>有一组预定义的过滤器可用于常见用途。这些内置过滤器中的许多都为上面的FilteredElementCollector部分中提到的FilteredElementCollector快捷方法提供了基础。接下来的三个部分提供了有关内置过滤器的更多信息。</p>
<p>创建筛选器后，需要将其应用于FilteredElementCollector。泛型方法WherePasses()用于将单个ElementFilter应用于FilteredElementCollector。</p>
<p>还可以使用FilteredElementCollector提供的许多快捷方法应用筛选器。有些应用一个特定的过滤器而不需要进一步的输入，比如WhereElementIsCurveDriven()，而其他应用一个特定的过滤器而只需要一个简单的输入，比如OfCategory()方法，它将BuiltInCategory作为一个参数。最后，还有一些方法，如UnionWith()，可以将过滤器连接在一起。所有这些方法都返回相同的收集器，从而可以轻松地将过滤器链接在一起。</p>
<h3 id="Quick-filters-快速筛选器"><a href="#Quick-filters-快速筛选器" class="headerlink" title="Quick filters 快速筛选器"></a>Quick filters 快速筛选器</h3><p>快速过滤器只在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。下表总结了内置的快速过滤器，下面是一些过滤器的示例。</p>
<p><strong>Table 13: Built-in Quick Filters<br>表13：内置快速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BoundingBoxContainsPointFilter</td>
<td>具有包含给定点的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIntersectsFilter</td>
<td>具有与给定轮廓相交的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIsInsideFilter</td>
<td>在给定轮廓内有边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementCategoryFilter</td>
<td>id 与输入类别id匹配的元素</td>
<td>OfCategoryId()</td>
</tr>
<tr>
<td>ElementClassFilter</td>
<td>与输入运行时类（或派生类）匹配的元素</td>
<td>OfClass()</td>
</tr>
<tr>
<td>ElementDesignOptionFilter</td>
<td>特定设计选项中的图元</td>
<td>ContainedInDesignOption()</td>
</tr>
<tr>
<td>ElementIsCurveDrivenFilter</td>
<td>曲线驱动的元素</td>
<td>WhereElementIsCurveDriven()</td>
</tr>
<tr>
<td>ElementIsElementTypeFilter</td>
<td>属于“元素类型”的元素</td>
<td>WhereElementIsNotElementType()</td>
</tr>
<tr>
<td>ElementMulticategoryFilter</td>
<td>与给定类别集中的任何一个相匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementMulticlassFilter</td>
<td>与给定的类（或派生类）集匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementOwnerViewFilter</td>
<td>视图专有的图元</td>
<td>OwnedByView()<br />WhereElementIsViewIndependent()</td>
</tr>
<tr>
<td>ElementStructuralTypeFilter</td>
<td>与给定结构类型匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ExclusionFilter</td>
<td>除元素id之外的所有元素都输入到过滤器</td>
<td>Excluding()</td>
</tr>
<tr>
<td>FamilySymbolFilter</td>
<td>特定族的Symbol</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>FamilySymbolFilter不能反转。</p>
<p><strong>注意：</strong>边界框过滤器排除所有从View派生的对象和从ElementType派生的对象。 下面的示例在文档中创建一个大纲，然后使用BoundingBoxIntersectsFilter查找文档中具有与该大纲相交的边界框的元素。然后，它展示了如何使用反向过滤器来查找边界框不与给定轮廓相交的所有墙。请注意，使用OfClass()方法也会将ElementClassFilter应用于集合。</p>
<p><strong>代码区域6-2：BoundingBoxIntersectsFilter示例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use BoundingBoxIntersects filter to find elements with a bounding box that intersects the </span></span><br><span class="line"><span class="comment">// given Outline in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Outline, uses a minimum and maximum XYZ point to initialize the outline. </span></span><br><span class="line">Outline myOutLn = <span class="keyword">new</span> Outline(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxIntersects filter with this Outline</span></span><br><span class="line">BoundingBoxIntersectsFilter filter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// This filter excludes all objects derived from View and objects derived from ElementType</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList elements = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all walls which don&#x27;t intersect with BoundingBox: use an inverted filter </span></span><br><span class="line"><span class="comment">// to match elements</span></span><br><span class="line"><span class="comment">// Use shortcut command OfClass() to find walls only</span></span><br><span class="line">BoundingBoxIntersectsFilter invertFilter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList notIntersectWalls = collector.OfClass(<span class="keyword">typeof</span>(Wall)).WherePasses(invertFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下一个示例使用排除过滤器查找文档中当前未选定的所有墙。</p>
<p>代码区域6-3：创建排除过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all walls that are not currently selected, </span></span><br><span class="line"><span class="comment">// Get all element ids which are current selected by users, exclude these ids when filtering</span></span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the selection to instantiate an exclusion filter</span></span><br><span class="line">ExclusionFilter filter = <span class="keyword">new</span> ExclusionFilter(selectedIds);</span><br><span class="line"><span class="comment">// For the sake of simplicity we do not test here whether the selection is empty or not,</span></span><br><span class="line"><span class="comment">// but in production code a proper validation would have to be done to avoid an argument</span></span><br><span class="line"><span class="comment">// exception from the filter&#x27;s consructor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document,</span></span><br><span class="line"><span class="comment">// Use shortcut method OfClass() to find Walls only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">IList walls = collector.WherePasses(filter).OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ElementClassFilter将匹配其类与输入类完全匹配的元素，或其类派生自输入类的元素。下面的示例使用ElementClassFilter获取文档中的所有加载。</p>
<p>代码区域6-4：使用ElementClassFilter获取负载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection allLoads = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>API中有一小部分元素子类不受元素类过滤器支持。这些类型存在于API中，但不存在于Revit的本机对象模型中，这意味着此过滤器不支持这些类型。为了使用类过滤器来查找这些类型的元素，需要使用更高级别的类，然后进一步处理结果以查找仅匹配子类型的元素。</p>
<p><strong>注：</strong>其中一些类型存在专用过滤器。 以下类型受此限制影响：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Dedicated Filter 专用过滤器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.Material的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CurveElement的子类</td>
<td>CurveElementFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ConnectorElement的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.HostedSweep的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.Room</td>
<td>RoomFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.Space</td>
<td>SpaceFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Area</td>
<td>AreaFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTag</td>
<td>RoomTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTag</td>
<td>SpaceTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTag</td>
<td>AreaTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CombinableElement</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mullion</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Panel</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbol</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.AreaReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.PathReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbolType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.TrussType</td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="Slow-Filters-慢过滤器"><a href="#Slow-Filters-慢过滤器" class="headerlink" title="Slow Filters 慢过滤器"></a>Slow Filters 慢过滤器</h3><p>慢过滤器要求首先获得元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。下表总结了内置的慢速过滤器，下面的几个示例提供了对某些过滤器的深入了解。</p>
<p><strong>表14：内置慢速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaFilter</td>
<td>Areas 区域</td>
<td>None</td>
</tr>
<tr>
<td>AreaTagFilter</td>
<td>Area tags 面积标记</td>
<td>None</td>
</tr>
<tr>
<td>CurveElementFilter</td>
<td>CurveElements 曲线元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementLevelFilter</td>
<td>与给定级别ID关联的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementParameterFilter</td>
<td>元素传递一个或多个参数筛选规则</td>
<td>None</td>
</tr>
<tr>
<td>ElementPhaseStatusFilter</td>
<td>给定阶段上具有给定阶段状态的元素</td>
<td>None</td>
</tr>
<tr>
<td>FamilyInstanceFilter</td>
<td>一个特定的族实例</td>
<td>None</td>
</tr>
<tr>
<td>FamilyStructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族元素</td>
<td>None</td>
</tr>
<tr>
<td>PrimaryDesignOptionMemberFilter</td>
<td>任何主设计选项所拥有的图元</td>
<td>None</td>
</tr>
<tr>
<td>RoomFilter</td>
<td>房间</td>
<td>None</td>
</tr>
<tr>
<td>RoomTagFilter</td>
<td>房间标记</td>
<td>None</td>
</tr>
<tr>
<td>SpaceFilter</td>
<td>空间</td>
<td>None</td>
</tr>
<tr>
<td>SpaceTagFilter</td>
<td>空间标签</td>
<td>None</td>
</tr>
<tr>
<td>StructuralInstanceUsageFilter</td>
<td>给定结构用途的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralWallUsageFilter</td>
<td>指定结构墙用途的墙</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定图元的实体几何相交的图元</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定实体几何相交的元素</td>
<td>None</td>
</tr>
</tbody></table>
<p>以下慢速过滤器不能反转： <em>RoomFilter</em> RoomTagFilter <em>AreaFilter</em> AreaTagFilter <em>SpaceFilter</em> * </p>
<p>FamilyInstanceFilter 如快速过滤器一节所述，有些类不能与ElementClassFilter一起使用。其中一些类，如Room和RoomTag有自己的专用过滤器。</p>
<p> 代码区域6-5：使用房间过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. It is necessary to use the </span></span><br><span class="line"><span class="comment">// RoomFilter and not an ElementClassFilter or the shortcut method OfClass() because the Room </span></span><br><span class="line"><span class="comment">// class is not supported by those methods.</span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>ElementParameterFilter是一个功能强大的过滤器，可以根据元素可能具有的参数值查找元素。它可以查找参数值与特定值匹配或大于或小于某个值的元素。ElementParameterFilter还可用于查找支持特定共享参数的元素。 下面的示例使用ElementParameterFilter查找大小超过100平方英尺的房间和小于100平方英尺的房间。</p>
<p>代码区域6-6：使用参数过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates an ElementParameter filter to find rooms whose area is </span></span><br><span class="line"><span class="comment">// greater than specified value</span></span><br><span class="line"><span class="comment">// Create filter by provider and evaluator </span></span><br><span class="line">BuiltInParameter areaParam = BuiltInParameter.ROOM_AREA;</span><br><span class="line"><span class="comment">// provider</span></span><br><span class="line">ParameterValueProvider pvp = <span class="keyword">new</span> ParameterValueProvider(<span class="keyword">new</span> ElementId((<span class="built_in">int</span>)areaParam));</span><br><span class="line"><span class="comment">// evaluator</span></span><br><span class="line">FilterNumericRuleEvaluator fnrv = <span class="keyword">new</span> FilterNumericGreater();</span><br><span class="line"><span class="comment">// rule value </span></span><br><span class="line"><span class="built_in">double</span> ruleValue = <span class="number">100.0f</span>;      <span class="comment">// filter room whose area is greater than 100 SF</span></span><br><span class="line"><span class="comment">// rule</span></span><br><span class="line">FilterRule fRule = <span class="keyword">new</span> FilterDoubleRule(pvp, fnrv, ruleValue, <span class="number">1E-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an ElementParameter filter</span></span><br><span class="line">ElementParameterFilter filter = <span class="keyword">new</span> ElementParameterFilter(fRule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find rooms whose area is less than or equal to 100: </span></span><br><span class="line"><span class="comment">// Use inverted filter to match elements</span></span><br><span class="line">ElementParameterFilter lessOrEqualFilter = <span class="keyword">new</span> ElementParameterFilter(fRule, <span class="literal">true</span>); </span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList lessOrEqualFounds = collector.WherePasses(lessOrEqualFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下面的示例显示如何使用FamilyStructuralMaterialTypeFilter查找材质类型为木材的所有族。它还说明了如何使用反向过滤器来查找材质类型不是木材的所有族。</p>
<p>代码区域6-7：查找所有使用木质材料的家庭</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use FamilyStructuralMaterialType filter to find families whose material type is Wood</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter filter = <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection woodFamiles = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find families are not Wood: Use inverted filter to match families</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter notWoodFilter = </span><br><span class="line">        <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection notWoodFamilies = collector.WherePasses(notWoodFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>最后两个慢过滤器派生自ElementIntersectsFilter，后者是用于匹配与几何体相交的元素的过滤器的基类。有关此类过滤器的使用示例，请参见几何工具类一节中的代码区域：查找附近的墙。#逻辑过滤器逻辑过滤器联合收割机将两个或多个过滤器逻辑组合。下表总结了内置的逻辑筛选器。表15：内置逻辑过滤器</p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LogicalAndFilter</td>
<td>通过2个或更多过滤器的元素</td>
<td>WherePasses()-添加一个额外的过滤器IntersectWith()-连接两组独立的过滤器</td>
</tr>
<tr>
<td>LogicalOrFilter</td>
<td>至少通过2个或多个过滤器之一的元素</td>
<td>UnionWith()-连接两组独立的过滤器</td>
</tr>
</tbody></table>
<p>在下面的示例中，使用逻辑过滤器组合了两个快速过滤器，以获取文档中的所有door FamilyInstance元素。</p>
<p>代码区域6-8：使用LogicalAndFilter查找所有门实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all door instances in the project by finding all elements that both belong to the</span></span><br><span class="line"><span class="comment">// door category and are family instances.</span></span><br><span class="line">ElementClassFilter familyInstanceFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a category filter for Doors</span></span><br><span class="line">ElementCategoryFilter doorsCategoryfilter = </span><br><span class="line">        <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a logic And filter for all Door FamilyInstances</span></span><br><span class="line">LogicalAndFilter doorInstancesFilter = <span class="keyword">new</span> LogicalAndFilter(familyInstanceFilter, </span><br><span class="line">        doorsCategoryfilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList doors = collector.WherePasses(doorInstancesFilter).ToElements();</span><br></pre></td></tr></table></figure>



<h2 id="获取筛选的元素或元素ID"><a href="#获取筛选的元素或元素ID" class="headerlink" title="获取筛选的元素或元素ID"></a>获取筛选的元素或元素ID</h2><p>将一个或多个过滤器应用于FilteredElementCollector后，可以通过以下三种方式之一来检索已过滤的元素集：</p>
<ol>
<li>获取Elements或ElementId的集合。<ul>
<li>ToElements()-返回通过所有应用的过滤器的所有元素</li>
<li>ToElementIds()-返回通过所有应用过滤器的所有元素的ElementIds</li>
</ul>
</li>
<li>获取与筛选器匹配的第一个Element或ElementId。<ul>
<li>FirstElement()-返回第一个元素以通过所有应用的过滤器</li>
<li>FirstElementId()-返回第一个元素的id，以通过所有应用的过滤器</li>
</ul>
</li>
<li>获取ElementId或Element迭代器。<ul>
<li>GetElementIdIterator()-将FilteredElementIdIterator返回到通过过滤器的元素id</li>
<li>GetElementIterator()-将FilteredElementIterator返回给通过过滤器的元素</li>
<li>GetEnumerator()-返回一个IEnumerator，它遍历传递元素的集合</li>
</ul>
</li>
</ol>
<p>一次只能使用这些组中的一个方法;如果调用另一个方法来提取元素，收集器将重置。因此，如果您之前已经获得了一个迭代器，那么当您调用另一个方法来提取元素时，它将停止并且不再遍历任何元素。</p>
<p>哪种方法最好取决于应用。如果只需要一个匹配元素，那么FirstElement()或FirstElementId()是最佳选择。如果需要所有匹配的元素，请使用ToElements()。如果需要一个变量，使用迭代器。</p>
<p>如果应用程序将删除元素或对过滤列表中的元素进行重大更改，ToElementIds()或元素id迭代器是最佳选择。这是因为删除元素或对元素进行重大更改会使元素句柄无效。对于元素id，对具有ElementId的Document.GetElement()的调用将始终返回有效的Element（如果元素已被删除，则返回空引用）。</p>
<p>使用ToElements()方法将筛选结果作为元素集合获取，允许使用foreach检查集合中的每个元素，如下所示：</p>
<p>代码区域6-9：使用ToElements()获取筛选结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line">ICollection allLoads = collector.ToElements();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">&quot;The loads in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element loadElem <span class="keyword">in</span> allLoads)</span><br><span class="line">&#123;</span><br><span class="line">        LoadBase load = loadElem <span class="keyword">as</span> LoadBase;</span><br><span class="line">        prompt += load.GetType().Name +  <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                        load.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p>当只需要一个传递元素时，使用FirstElement()：</p>
<p>代码区域6-10：获取第一个通过的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a filter to find all columns</span></span><br><span class="line">StructuralInstanceUsageFilter columnFilter = </span><br><span class="line">        <span class="keyword">new</span> StructuralInstanceUsageFilter(StructuralInstanceUsage.Column);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(columnFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the first column from the filtered results</span></span><br><span class="line"><span class="comment">// Element will be a FamilyInstance</span></span><br><span class="line">FamilyInstance column = collector.FirstElement() <span class="keyword">as</span> FamilyInstance;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，FirstElement()是不够的。下一个示例显示如何使用扩展方法获取第一个非模板3D视图（这对于ReferenceIntersector构造函数的输入很有用）。</p>
<p>代码区域6-11：使用扩展方法获取第一个传递元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use filter to find a non-template 3D view</span></span><br><span class="line"><span class="comment">// This example does not use FirstElement() since first filterd view3D might be a template</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply ElementClassFilter</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use extension methods to get first non-template View3D</span></span><br><span class="line">View3D view3D = collector.Cast().First(isNotTemplate);</span><br></pre></td></tr></table></figure>

<p>The following example demonstrates the use of the FirstElementId() method to get one passing element (a 3d view in this case) and the use of ToElementIds() to get the filter results as a collection of element ids (in order to delete a set of elements in this case).<br>下面的示例演示了使用FirstElementId()方法获取一个传递元素（本例中为3D视图），以及使用ToElementIds()获取作为元素ID集合的过滤结果（本例中为删除一组元素）。</p>
<p>代码区域6-12：使用得到过滤器结果作为元素id</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use shortcut OfClass to get View elements</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Id of the first view</span></span><br><span class="line">ElementId viewId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test if the view is valid for element filtering</span></span><br><span class="line"><span class="keyword">if</span> (FilteredElementCollector.IsViewValidForElementIteration(document, viewId))</span><br><span class="line">&#123;</span><br><span class="line">        FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document, viewId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all FamilyInstance items in the view</span></span><br><span class="line">        viewCollector.OfClass(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line">        ICollection familyInstanceIds = viewCollector.ToElementIds();</span><br><span class="line"></span><br><span class="line">        document.Delete(familyInstanceIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中使用了GetElementIterator()方法，该方法循环访问已筛选的元素以检查某些管道的流状态。</p>
<p>代码区域6-13：以元素迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a filter to get all pipes in the document</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Autodesk.Revit.DB.Plumbing.Pipe));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as an element iterator and look for a pipe with</span></span><br><span class="line"><span class="comment">// a specific flow state</span></span><br><span class="line">FilteredElementIterator elemItr = collector.GetElementIterator();</span><br><span class="line">elemItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (elemItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        Pipe pipe = elemItr.Current <span class="keyword">as</span> Pipe;</span><br><span class="line">        <span class="keyword">if</span> (pipe.FlowState == PipeFlowState.LaminarState)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Model has at least one pipe with Laminar flow state.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，过滤结果可以作为元素id迭代器返回：</p>
<p>代码区域6-14：以元素id迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. </span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as ElementId iterator</span></span><br><span class="line">FilteredElementIdIterator roomIdItr = collector.GetElementIdIterator();</span><br><span class="line">roomIdItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (roomIdItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        ElementId roomId = roomIdItr.Current;</span><br><span class="line">        <span class="comment">// Warn rooms smaller than 50 SF</span></span><br><span class="line">        Room room = document.GetElement(roomId) <span class="keyword">as</span> Room;</span><br><span class="line">        <span class="keyword">if</span> (room.Area &lt; <span class="number">50.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                String prompt = <span class="string">&quot;Room is too small: id = &quot;</span> + roomId.ToString();</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，针对给定的过滤器测试单个元素，而不是获取通过过滤器的所有元素，可能会很有用。ElementFilter.PassesFilter()有两个重载，它们根据筛选器测试给定的Element或ElementId，如果元素通过筛选器，则返回true。</p>
<h2 id="LINQ查询"><a href="#LINQ查询" class="headerlink" title="LINQ查询"></a>LINQ查询</h2><p>在.NET中，FilteredElementCollector类支持Elements的IEEETM接口。您可以将此类与LINQ查询和操作一起使用来处理元素列表。请注意，由于此类提供的ElementFilters和快捷方法在生成托管包装之前处理本机代码中的元素，因此在尝试使用LINQ查询处理结果之前，在收集器上使用尽可能多的本机筛选器将获得更好的性能。</p>
<p>The following example uses an ElementClassFilter to get all FamilyInstance elements in the document, and then uses a LINQ query to narrow down the results to those FamilyInstances with a specific name.<br>下面的示例使用ElementClassFilter获取文档中的所有FamilyInstance元素，然后使用LINQ查询将结果范围缩小到具有特定名称的FamilyInstance。</p>
<p>代码区域6-15：使用LINQ查询</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find family instances whose name is 60&quot; x 30&quot; Student </span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Linq query to find family instances whose name is 60&quot; x 30&quot; Student</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                        <span class="keyword">where</span> element.Name == <span class="string">&quot;60\&quot; x 30\&quot; Student&quot;</span></span><br><span class="line">                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast found elements to family instances, </span></span><br><span class="line"><span class="comment">// this cast to FamilyInstance is safe because ElementClassFilter for FamilyInstance was used</span></span><br><span class="line">List familyInstances = query.Cast().ToList();</span><br></pre></td></tr></table></figure>

<h2 id="边界框过滤器"><a href="#边界框过滤器" class="headerlink" title="边界框过滤器"></a>边界框过滤器</h2><p> BoundingBox过滤器：</p>
<ul>
<li>BoundingBoxIsInsideFilter</li>
<li>BoundingBoxIntersectsFilter</li>
<li>BoundingBoxContainsPointFilter</li>
</ul>
<p>帮助您查找其边界框满足特定条件的元素。您可以检查每个元素的边界框是否在给定体积内，是否与给定体积相交，或者是否包含给定点。也可以反向执行此检查，以查找不与体积相交或不包含给定点的元素。</p>
<p>BoundingBox过滤器使用Outline作为其输入。Outline是一个表示直角棱柱的类，其轴与Revit世界坐标系对齐。</p>
<p>这些过滤器最适合于实际几何形状与其边界框的几何形状紧密匹配的形状。示例可能包括曲线与X或Y方向对齐的线性墙、由此类墙形成的矩形房间、与此类墙对齐的楼板或屋顶，或者合理的矩形族。否则，可能会出现误报，因为元素的边界框可能比实际几何形状大得多。(在这些情况下，您可以使用实际图元的几何图形来确定图元是否真正满足条件）。</p>
<h2 id="元素交叉过滤器"><a href="#元素交叉过滤器" class="headerlink" title="元素交叉过滤器"></a>元素交叉过滤器</h2><p> 元素过滤器：</p>
<ul>
<li>ElementIntersectsElementFilter</li>
<li>ElementIntersectsSolidFilter</li>
</ul>
<p>其实际三维几何体与目标对象的三维几何体相交的过程元素。</p>
<p>使用ElementIntersectsElementFilter，目标对象是另一个元素。交点的确定与Revit在生成冲突报告期间确定是否存在冲突时使用的逻辑相同。(意味着某些图元组合永远不会通过此过滤器，例如在相交处自动连接的混凝土构件，或也从干涉检查中排除的场地图元）。此外，没有实心几何图形的图元（如钢筋）也不会通过此过滤器。</p>
<p>使用ElementIntersectsSolidFilter，目标对象是任何实体。该实体可以从现有图元中获得，使用GeometryCreationUtilities中的例程从头开始创建，或者是布尔运算等二次运算的结果。与ElementIntersectsElementFilter类似，此过滤器不会传递缺少实心几何图形的元素。</p>
<p>两个过滤器都可以反转以匹配目标对象体积之外的元素。</p>
<p>这两个过滤器都是慢速过滤器，因此最好与一个或多个快速过滤器（如类或类别过滤器）组合使用。</p>
<p> 代码区域：使用ElementIntersectsSolidFilter匹配阻止禁用出口到门的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds any Revit physical elements which interfere with the target </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> solid region surrounding a door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This routine is useful for detecting interferences which are </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> violations of the Americans with Disabilities Act or other local disabled </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> access codes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The door instance.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The accessibility region calculated</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> to surround the approach of the door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Because the geometric parameters of this region are code- and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> door-specific, calculation of the geometry of the region is not </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> demonstrated in this example.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A collection of interfering element ids.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ICollection <span class="title">FindElementsInterferingWithDoor</span>(<span class="params">FamilyInstance doorInstance, Solid doorAccessibilityRegion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Setup the filtered element collector for all document elements.</span></span><br><span class="line">   FilteredElementCollector interferingCollector = </span><br><span class="line">      <span class="keyword">new</span> FilteredElementCollector(doorInstance.Document);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only accept element instances</span></span><br><span class="line">   interferingCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exclude intersections with the door itself or the host wall for the door.</span></span><br><span class="line">   List excludedElements = <span class="keyword">new</span> List();</span><br><span class="line">   excludedElements.Add(doorInstance.Id);</span><br><span class="line">   excludedElements.Add(doorInstance.Host.Id);</span><br><span class="line">   ExclusionFilter exclusionFilter = <span class="keyword">new</span> ExclusionFilter(excludedElements);</span><br><span class="line">   interferingCollector.WherePasses(exclusionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set up a filter which matches elements whose solid geometry intersects </span></span><br><span class="line">   <span class="comment">// with the accessibility region</span></span><br><span class="line">   ElementIntersectsSolidFilter intersectionFilter = </span><br><span class="line">      <span class="keyword">new</span> ElementIntersectsSolidFilter(doorAccessibilityRegion);</span><br><span class="line">   interferingCollector.WherePasses(intersectionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return all elements passing the collector</span></span><br><span class="line">   <span class="keyword">return</span> interferingCollector.ToElementIds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/05%E8%BF%87%E6%BB%A4/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="元素要点"><a href="#元素要点" class="headerlink" title="元素要点"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Elements_Essentials_html">元素要点</a></h1><p>元素对应于单个建筑或绘图构件，例如门、墙或尺寸标注。此外，元素可以是门类型、视图或材质定义。</p>
<h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><p>Revit 图元分为六组：模型、草图、视图、组、注释和信息。每个组都包含相关的元素及其相应的符号。</p>
<h4 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h4><p>模型元素表示建筑项目中存在的物理项。“模型元素”组中的元素可以细分为以下元素：</p>
<p>族实例 - 族实例包含族实例对象。可以将族对象载入到项目中，也可以从族样板创建族对象。有关更多信息，请参阅系列实例。</p>
<p>主体图元 - 主体图元包含系统族对象，这些对象可以包含其他模型图元，例如墙、屋顶、天花板和楼板。有关主体图元的更多信息，请参见墙、楼板、屋顶和洞口。</p>
<p>结构元素-结构图元包含仅用于 Revit 结构特征的图元。有关 Structure Elements 的更多信息，请参见 Structural Engineering。</p>
<h4 id="视图元素"><a href="#视图元素" class="headerlink" title="视图元素"></a>视图元素</h4><p>视图图元表示在 Revit 中查看其他对象并与其他对象交互的方式。有关更多信息，请参阅视图。</p>
<h4 id="组元素"><a href="#组元素" class="headerlink" title="组元素"></a>组元素</h4><p>组图元表示辅助图元，例如 Revit 中的“阵列”和“组”对象。有关详细信息，请参阅编辑元素。</p>
<h4 id="注释和基准元素"><a href="#注释和基准元素" class="headerlink" title="注释和基准元素"></a>注释和基准元素</h4><p>注释和基准元素包含可见的非物理项。</p>
<p>注释元素表示在图纸上保持比例的二维构件，并且仅在一个视图中可见。有关注释元素的更多信息，请参阅注释元素。<br>注： 表示 2D 组件的注释元素不仅存在于 2D 视图中。例如，可以在 3D 视图中绘制尺寸，而它们所引用的形状仅存在于 2D 平面中。<br>基准元素表示用于建立项目上下文的非物理项。这些元素可以存在于视图中。基准元素进一步分为以下几部分：</p>
<ul>
<li>通用基准元素 - 通用基准元素表示用于存储建模数据的非物理可见项目。</li>
<li>基准 FamilyInstance - 基准 FamilyInstance 表示加载到项目中或从族模板创建的非物理可见项目。注意有关常用基准元素和基准族实例的更多信息，请参阅基准和信息元素;有关 ModelCurve 相关内容，请参阅草绘。</li>
<li>结构基准元素 - 结构基准元素表示用于存储结构建模数据的非物理可见项目。有关结构基准元素的详细信息，请参阅结构工程。</li>
</ul>
<h4 id="草图元素"><a href="#草图元素" class="headerlink" title="草图元素"></a>草图元素</h4><p>草图元素表示用于草绘 2D&#x2F;3D 形状的临时项目。此组包含族建模和体量分析中使用的以下对象：</p>
<p>SketchPlane 草图平面）</p>
<ul>
<li>Sketch 素描</li>
<li>Path3D 路径3D</li>
<li>GenericForm. 泛型形式。</li>
</ul>
<p>有关草图详细信息，请参阅草图绘制。</p>
<h4 id="信息元素"><a href="#信息元素" class="headerlink" title="信息元素"></a>信息元素</h4><p>信息元素包含用于存储项目和应用程序数据的非物理不可见项。信息元素进一步分为以下几部分：</p>
<ul>
<li>Project Datum Elements 项目基准元素</li>
<li>Project Datum Elements (Unique).项目基准元素 （Unique）。</li>
</ul>
<p>有关基准元素的更多信息，请参阅基准和信息元素。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><p>元素可以按Category, Family, Symbol and Instance.进行分类。</p>
<p>分类之间存在一些关系。例如：</p>
<p>您可以按类别区分不同类型的 FamilyInstances。结构柱等项目位于“结构柱”类别中，梁和支撑位于“结构框架”类别中，依此类推。<br>您可以通过Symbol来区分结构 FamilyInstance 元素。</p>
<h4 id="Category-类别"><a href="#Category-类别" class="headerlink" title="Category 类别"></a>Category 类别</h4><p>Element.Category 属性表示 Element 所属的类别或子类别。它用于标识元素类型。例如，“墙”类别中的任何内容都被视为墙。其他类别包括门和房间。</p>
<p>Category 是最通用的类。 Document.Settings.Categories 属性是一个包含文档中所有 Category 对象的映射，并细分为以下对象：</p>
<ul>
<li>模型类别 - 模型类别包括梁、柱、门、窗和墙。</li>
<li>注释类别 - 注释类别包括维度、网格、级别和文本注释。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png"></p>
<p> 图 20：类别</p>
<p>注意：以下指南适用于分类：</p>
<ul>
<li><p>一般而言，以下规则适用于类别：</p>
<ul>
<li><p>每个族对象都属于一个类别</p>
</li>
<li><p>非族对象（如材质和视图）不属于某个类别</p>
</li>
<li><p>也有例外，例如 ProjectInfo，它属于“项目信息”类别。</p>
</li>
</ul>
</li>
<li><p>元素及其对应的符号通常属于同一类别。例如，基本墙及其墙类型“通用 - 8”都属于“墙”类别。</p>
</li>
<li><p>相同类型的元素可以属于不同的类别。例如，SpotDimensions 具有 SpotDimensionType，但它可以属于两个不同的类别：高程点和高程点坐标。</p>
</li>
<li><p>不同的元素可以由于相似性或体系结构原因而属于同一类别。ModelLine 和 DetailLine 位于 Lines 类别中。</p>
</li>
</ul>
<p>要访问类别，您可以从文档的 Settings 类访问所有类别（例如，插入新的类别集），或者如果您只需要访问与内置类别关联的类别对象，您可以直接从 Category 类的静态重载 GetCategory（） 方法访问类别对象。</p>
<p>要访问类别：</p>
<ul>
<li><p>从文档属性中获取类别的完整映射：Document.Settings.Categories 返回一个 CategoryNameMap，其中包含按其名称编制索引的所有 Revit 类别的映射。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（） 的相应重载来获取特定的内置类别。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（) 的相应重载，按其 ElementId 获取特定类别或子类别。</p>
</li>
<li><p>代码区域 5-1：从文档设置中获取类别</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Get settings of current document</span></span><br><span class="line">  Settings documentSettings = document.Settings;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all categories of current document</span></span><br><span class="line">Categories groups = documentSettings.Categories;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show the number of all the categories to the user</span></span><br><span class="line">String prompt = <span class="string">&quot;Number of all categories in current Revit document:&quot;</span> + groups.Size; </span><br><span class="line"></span><br><span class="line"><span class="comment">// get Floor category according to OST_Floors and show its name</span></span><br><span class="line">Category floorCategory = groups.get_Item(BuiltInCategory.OST_Floors);</span><br><span class="line">prompt += floorCategory.Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give the user some information</span></span><br><span class="line">MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Category 的使用方式如下：</p>
<ul>
<li>Category 用于对元素进行分类。元素类别确定某些行为。例如，同一类别中的所有图元都可以包含在同一个明细表中。</li>
<li>元素具有基于其类别的参数。</li>
<li>类别还用于控制 Revit 中的可见性和图形外观。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png"><br>图 21：按类别划分的可见性</p>
<p>元素的类别由 Category ID 确定。</p>
<ul>
<li>类别 ID 由 ElementId 类表示。</li>
<li>导入的类别 ID 与文档中的元素相对应。</li>
<li>大多数类别都是内置的，它们的 ID 是存储在 ElementId 中的常量。</li>
<li>每个内置类别 ID 在 BuiltInCategory 枚举中都有相应的值。它们可以转换为相应的 BuiltInCategory 枚举类型。</li>
</ul>
<p>如果类别不是内置类别，则 ID 将转换为 null 值。</p>
<p>代码区域 5-2：获取元素类别</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  Element selectedElement = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> uidoc.Selection.GetElementIds())</span><br><span class="line">    &#123;</span><br><span class="line">        selectedElement = document.GetElement(id);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// just get one selected element</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Get the category instance from the Category property</span></span><br><span class="line">  Category category = selectedElement.Category;</span><br><span class="line"></span><br><span class="line">BuiltInCategory enumCategory = (BuiltInCategory)category.Id.IntegerValue;</span><br></pre></td></tr></table></figure>

<p>注意：为了避免在使用 Category.Name 时出现全球化问题，BuiltInCategory 是更好的选择。Category.Name 在不同的语言中可能会有所不同。</p>
<h4 id="Family-族"><a href="#Family-族" class="headerlink" title="Family 族"></a>Family 族</h4><p>族是类别中的元素类。族可以按以下方式对图元进行分组：</p>
<ul>
<li>一组通用的参数 （属性）。</li>
<li>相同使用。</li>
<li>类似的图形表示。</li>
</ul>
<p>大多数族都是构件族文件，这意味着您可以将它们加载到项目中或从族模板创建它们。您可以确定属性集和族图形表示。<br>另一种族类型是系统 Family。系统族不可用于加载或创建。Revit 预定义了系统族属性和图形表示;它们包括墙、尺寸、屋顶、楼板（或楼板）和标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png"></p>
<p>图 22：族</p>
<p>除了用作 Element 类之外，Family 还是用于生成属于 Family 的新项目的模板。</p>
<h4 id="Revit-平台-API-中的族"><a href="#Revit-平台-API-中的族" class="headerlink" title="Revit 平台 API 中的族"></a>Revit 平台 API 中的族</h4><p>在 Revit 平台 API 中，Family 类和 FamilyInstance 都属于构件族。其他元素包括 System Family。</p>
<p>Revit 平台 API 中的族由三个对象表示：</p>
<ul>
<li>Family 族</li>
<li>FamilySymbol  族符号</li>
<li>FamilyInstance  族实例</li>
</ul>
<p>每个对象在 Family 结构中都起着重要作用。</p>
<p>Family 对象具有以下特征：</p>
<ul>
<li>表示整个族，例如梁。</li>
<li>表示磁盘上的整个族文件。</li>
<li>包含许多 FamilySymbol。</li>
</ul>
<p>FamilySymbol 对象表示族中的一组特定族设置，例如类型、混凝土矩形梁：16×32。</p>
<p>FamilyInstance 对象是一个 FamilySymbol 实例，表示 Revit 项目中的单个实例。例如，FamilyInstance 可以是项目中 16×32 混凝土矩形梁的单个实例。</p>
<p>注意：请记住，FamilyInstance 存在于 FamilyInstance 元素、基准元素和注释元素中。</p>
<p>因此，以下规则适用：</p>
<ul>
<li>每个 FamilyInstance 都有一个 FamilySymbol。</li>
<li>每个 FamilySymbol 都属于一个 Family。</li>
<li>每个 Family 都包含一个或多个 FamilySymbol。</li>
</ul>
<p>有关更多详细信息，请参阅系列实例。</p>
<h4 id="ElementType-元素类型"><a href="#ElementType-元素类型" class="headerlink" title="ElementType 元素类型"></a>ElementType 元素类型</h4><p>在 Revit Platform API 中，符号通常是用于定义实例的不可见图元。Symbols 在用户界面中称为Types。</p>
<ul>
<li>Type可以是族中的特定大小，例如 1730 × 2032 的门，也可以是 8×4×1&#x2F;2 的角度。</li>
<li>Type可以是样式，例如尺寸的默认线性或默认角度样式。</li>
</ul>
<p>Symbols表示包含一组类似元素的共享数据的元素。在某些情况下，Symbols表示可以从仓库获取的建筑构件，例如门或窗，并且可以在同一建筑物中多次放置。在其他情况下，Symbols 包含主机对象参数或其他元素。例如，WallType Symbol 包含特定墙壁类型的厚度、层数、每层的材料以及其他属性。</p>
<p>FamilySymbol 是 API 中的一个Symbols。它在 Revit 用户界面中也称为族类型。FamilySymbol 是族中的一类图元，其所有属性的值都完全相同。例如，所有 32×78 个六面板门都属于一种类型，而所有 24×80 个六面板门都属于另一种类型。与 Family 一样，FamilySymbol 也是一个模板。FamilySymbol 对象派生自 ElementType 对象和 Element 对象。</p>
<p>Instance 实例</p>
<p>实例是在建筑 （模型实例） 或绘图图纸 （注释实例） 上具有特定位置的项。Instance 表示 ElementType 的转换后的相同副本。例如，如果建筑物包含 20 个特定类型的窗户，则有一个 ElementType 具有 20 个实例。实例在用户界面中称为 Components。</p>
<p>注意：对于 FamilyInstance，可以使用 Symbol 属性而不是 GetTypeId（） 方法来获取相应的 FamilySymbol。它既方便又安全，因为您不需要进行类型转换。</p>
<h2 id="元素检索"><a href="#元素检索" class="headerlink" title="元素检索"></a>元素检索</h2><p>Revit中的图元非常常见。在对任何 Element 命令使用 API 之前，必须从 Revit 中检索所需的图元。有几种方法可以使用 Revit API 检索图元：</p>
<ul>
<li>ElementId - 如果元素的 ElementId 已知，则可以从文档中检索该元素。</li>
<li>元素过滤和迭代 - 这是检索文档中一组相关元素的好方法。</li>
<li>选定元素 - 检索用户已选定的元素集</li>
<li>特定元素 - 某些元素可用作文档的属性</li>
</ul>
<p>以下各节将更详细地讨论这些元素检索方法中的每一种。</p>
<h4 id="按-ID-获取元素"><a href="#按-ID-获取元素" class="headerlink" title="按 ID 获取元素"></a>按 ID 获取元素</h4><p>当所需元素的 ElementId 已知时，请使用 Document.Element 属性获取该元素。</p>
<h4 id="筛选-Elements-集合"><a href="#筛选-Elements-集合" class="headerlink" title="筛选 Elements 集合"></a>筛选 Elements 集合</h4><p>获取文档中元素的最常见方法是使用筛选来检索元素集合。Revit API 提供了 FilteredElementCollector 类和支持类，用于创建经过过滤的元素集合，然后可以迭代这些元素。有关更多信息，请参阅筛选。</p>
<h4 id="Selection-选择"><a href="#Selection-选择" class="headerlink" title="Selection 选择"></a>Selection 选择</h4><p>您可以只访问已选择的元素，而不是获取模型中所有元素的过滤集合。您可以使用 UIDocument.Selection.GetElementIds 方法从当前活动文档中获取所选对象。有关使用活动选择的更多信息，请参阅选择。</p>
<h4 id="从文档中访问特定元素"><a href="#从文档中访问特定元素" class="headerlink" title="从文档中访问特定元素"></a>从文档中访问特定元素</h4><p>除了使用常规方式访问图元外，Revit Platform API 还在 Document 类中具有属性，用于从当前活动文档中获取指定的图元，而无需迭代所有图元。下表列出了您可以检索的指定元素。</p>
<p>表 11：从文档属性中检索元素</p>
<table>
<thead>
<tr>
<th><strong>Element 元素</strong></th>
<th><strong>Document 属性中的访问</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ProjectInfo 项目信息</td>
<td>Document.ProjectInformation</td>
</tr>
<tr>
<td>ProjectLocation 项目位置</td>
<td>Document.ProjectLocations</td>
</tr>
<tr>
<td>SiteLocation 站点位置</td>
<td>Document.SiteLocation</td>
</tr>
<tr>
<td>Phase 阶段</td>
<td>Document.Phases</td>
</tr>
</tbody></table>
<h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><p>以下特性对于使用 Revit 创建的每个图元都是通用的。</p>
<h4 id="ElementId-元素-Id"><a href="#ElementId-元素-Id" class="headerlink" title="ElementId 元素 Id"></a>ElementId 元素 Id</h4><p>活动文档中的每个元素都有一个唯一标识符，由 ElementId 存储类型表示。ElementId 对象是项目范围的。它是一个唯一编号，在元素模型中永远不会改变，这使得它可以存储在外部，以便在需要时检索元素。<br>在 Revit Platform API 中，您可以直接创建 ElementId，然后将唯一整数值与新的 ElementId 关联。默认情况下，新的 ElementId 值为 0。</p>
<p>代码区域 5-3：设置 ElementId</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br></pre></td></tr></table></figure>

<p>ElementId 具有以下用途：</p>
<p>使用 ElementId 从 Revit 中检索特定图元。从 Revit Application 类中，获取对活动文档的访问权限，然后使用Document.GetElement（ElementId） 方法获取指定的元素。</p>
<p>代码区域 5-4：使用 ElementId</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the element </span></span><br><span class="line">Autodesk.Revit.DB.Element first = document.GetElement(id);</span><br></pre></td></tr></table></figure>

<p>如果项目中不存在 ID 号，则检索的元素为 null。</p>
<p>使用 ElementId 检查一个项目中的两个元素是否相等。不建议使用 Object.Equal（） 方法。</p>
<h4 id="UniqueId-唯一-Id"><a href="#UniqueId-唯一-Id" class="headerlink" title="UniqueId 唯一 Id"></a>UniqueId 唯一 Id</h4><p>每个元素都有一个 UniqueId，由 String 存储类型表示。UniqueId 对应于 ElementId。但是，与 ElementId 不同，UniqueId 的功能类似于 GUID（全局唯一标识符），它在单独的 Revit 项目中是唯一的。UniqueId 可以帮助您在将 Revit 项目文件导出为其他格式时跟踪元素。</p>
<p>代码区域 5-5：UniqueId</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uniqueId = element.UniqueId;</span><br></pre></td></tr></table></figure>

<p>注意：ElementId 仅在当前项目中是唯一的。它在单独的 Revit 项目中不是唯一的。UniqueId 在单独的项目中始终是唯一的。</p>
<h4 id="Location-位置"><a href="#Location-位置" class="headerlink" title="Location 位置"></a>Location 位置</h4><p>在建筑建模过程中，对象的位置非常重要。在Revit中，某些对象具有点位置。例如，一个表有一个点位置。其他对象具有线位置，表示位置曲线或根本没有位置。墙是具有线位置的元素。</p>
<p>Revit Platform API 为大多数图元提供 Location 类和位置功能。例如，它具有 Move（） 和 Rotate（） 方法来平移和旋转元素。但是，Location 类没有可以从中获取坐标等信息的属性。在这种情况下，将 Location 对象降级到其子类（如 LocationPoint 或 LocationCurve），以获取更详细的位置信息并使用对象派生进行控制。</p>
<p>在获取对象的几何图形时，检索元素在项目中的物理位置非常有用。检索位置时，以下规则适用：<br>Wall、Beam 和 Brace 使用 LocationCurve 进行曲线驱动。</p>
<p>Room、RoomTag、SpotDimension、Group、非曲线驱动的 FamilyInstances 以及所有 In-Place-FamilyInstances 都使用 LocationPoint。</p>
<p>在 Revit Platform API 中，曲线驱动意味着元素的几何图形或位置由一个或多个关联的曲线确定。几乎所有的分析模型元素都是曲线驱动的 - 线性荷载和面积荷载、墙、框架元素等。</p>
<p>其他元素无法检索 LocationCurve 或 LocationPoint。他们返回“Location ”，但未提供任何信息。</p>
<p>表 12：元素位置信息</p>
<table>
<thead>
<tr>
<th><strong>位置信息</strong></th>
<th><strong>Elements 元素</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LocationCurve 位置曲线</td>
<td>Wall, Beam, Brace, Structural Truss, LineLoad(without host)</td>
</tr>
<tr>
<td>LocationPoint 位置点</td>
<td>Room, RoomTag, SpotDimension, Group, Column, Mass</td>
</tr>
<tr>
<td>Only Location 仅位置</td>
<td>Level, Floor, some Tags, BeamSystem, Rebar, Reinforcement, PointLoad, AreaLoad(without Host), Span Direction(IndependentTag)</td>
</tr>
<tr>
<td>No Location 无位置</td>
<td>View, LineLoad(with host), AreaLoad(with Host), BoundaryCondition</td>
</tr>
</tbody></table>
<p>注意：还有其他没有 Location 信息的元素。例如，LineLoad（带 host）或 AreaLoad（带 host）没有 Location。</p>
<p>某些 FamilyInstance LocationPoints（例如所有就地 FamilyInstances 和 mass）在创建时被指定为点 （0， 0， 0）。如果转换或移动实例，则 LocationPoint 坐标将更改。</p>
<p>若要更改 Group-s LocationPoint，请执行下列操作之一：</p>
<ul>
<li>在Revit UI中拖动组原点以更改LocationPoint坐标。在此情况下，组 LocationPoint 将更改，而 Group-s 的位置不会更改。</li>
<li>使用 ElementTransformUtils.MoveElement（） 方法移动组以更改 LocationPoint。这将更改 Group location 和 LocationPoint。</li>
</ul>
<p>有关 LocationCurve 和 LocationPoint 的更多信息，请参阅移动元素。</p>
<h4 id="Level-标高"><a href="#Level-标高" class="headerlink" title="Level 标高"></a>Level 标高</h4><p>楼层是有限的水平平面，用作楼层托管或基于楼层的元素（如屋顶、地板和天花板）的参考。Revit Platform API 提供了一个 Level 类，用于表示 Revit 中的标高线。如果元素是基于Level 的，请使用 API 获取元素分配到的 Level 对象。</p>
<p>代码区域 5-6：分配标高</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the level object to which the element is assigned.</span></span><br><span class="line"><span class="keyword">if</span> (element.LevelId.Equals(ElementId.InvalidElementId))</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The element isn&#x27;t based on a level.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Level level = element.Document.GetElement(element.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format the prompt information(Name and elevation)</span></span><br><span class="line">    String prompt = <span class="string">&quot;The element is based on a level.&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level name is:  &quot;</span> + level.Name;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level elevation is:  &quot;</span> + level.Elevation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show the information to the user.</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>许多元素（如柱）使用标高作为基本参考。当您获取柱标高时，您检索的标高是基础标高。</p>
<p>注意：使用 Reference Level 参数获取 Beam 或 Brace 标高。从 Level 属性中，您只会获得 null，而不是引用标高信息。标高是 Revit 中最常用的图元。在 Revit 平台 API 中，使用“level  ”过滤器检索所有标高。</p>
<p>有关更多级别详细信息，请参阅基准和信息元素。</p>
<h4 id="Parameter-参数"><a href="#Parameter-参数" class="headerlink" title="Parameter 参数"></a>Parameter 参数</h4><p>每个元素都有一组参数，用户可以在Revit中查看和编辑这些参数。参数在“元素属性”对话框中可见（选择任何元素，然后单击类型选择器旁边的“属性”按钮）。例如，下图显示了房间参数。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png"></p>
<p>图 25：Room 参数</p>
<p>在 Revit Platform API 中，每个 Element 对象都有一个 Parameters 属性，该属性是附加到 Element 的所有属性的集合。您可以更改集合中的属性值。例如，您可以从房间对象参数中获取房间的面积;此外，您还可以使用房间对象参数设置房间号。Parameter 是提供对元素对象中未公开的属性信息的访问的另一种方法。</p>
<p>通常，每个元素参数都有一个关联的参数 ID。参数 ID 由 ElementId 类表示。对于用户创建的参数，ID 对应于文档中的实际元素。但是，大多数参数都是内置的，其 ID 是存储在 ElementIds 中的常量。</p>
<p>参数是元素中数据存储的通用形式。在 Revit Platform API 中，最好使用内置参数 ID 来获取参数。Revit 具有大量使用 BuiltInParameter 枚举类型的内置参数。</p>
<p>有关详细信息，请参阅参数说明。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/12/28/03%E5%BA%94%E7%94%A8%E5%8F%8A%E6%96%87%E6%A1%A3/">
        <h2 class="post-title"></h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Application及Document"><a href="#Application及Document" class="headerlink" title="Application及Document"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Application_and_Document_html">Application及Document</a></h1><p>Revit 平台 API 中的顶级对象是Application和Document。这些类由 Application、UIApplication、Document 和 UIDocument 类表示。</p>
<p>Application对象是指单个 Revit 任务，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<p>Autodesk.Revit.UI.UIApplication - 提供对应用程序的 UI 级界面的访问，包括将 RibbonPanel 添加到用户界面的功能，以及在用户界面中获取活动文档的功能。</p>
<p>Autodesk.Revit.ApplicationServices.Application - 提供对所有其他应用程序级别属性的访问。</p>
<p>Document是表示建筑模型的单个 Revit 项目文件。Revit 可以打开多个项目，并为一个项目打开多个视图。</p>
<p>Autodesk.Revit.UI.UIDocument - 提供对文档的 UI 级界面的访问，例如选择的内容以及提示用户进行选择和选取点的功能。</p>
<p>Autodesk.Revit.DB.Document - 提供对所有其他文档级别属性的访问。</p>
<p>如果打开了多个文档，则活动文档是其视图在 Revit 任务中处于活动状态的文档。</p>
<p>本章介绍了所有Application和Document，然后重点介绍文件管理、设置和单位。有关 Element 类的更多详细信息，请参阅 Elements Essentials和 编辑元素 ，并参阅 视图 以了解有关视图元素的更多详细信息。</p>
<h2 id="Applicaion功能"><a href="#Applicaion功能" class="headerlink" title="Applicaion功能"></a>Applicaion功能</h2><p>Application和 UIApplication 成员提供对应用程序范围的数据和设置以及 Revit 的活动会话的访问。</p>
<h4 id="Application-应用"><a href="#Application-应用" class="headerlink" title="Application 应用"></a>Application 应用</h4><p>该类表示 Autodesk Revit 应用程序，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<h4 id="应用程序版本信息"><a href="#应用程序版本信息" class="headerlink" title="应用程序版本信息"></a>应用程序版本信息</h4><p>应用程序属性包括 VersionBuild、VersionNumber 和 VersionName。这些属性可用于根据 Revit 的发布和内部版本提供附加模块行为，如如何使用应用程序属性为附加模块强制实施正确的版本所示。</p>
<h4 id="应用程序范围的设置"><a href="#应用程序范围的设置" class="headerlink" title="应用程序范围的设置"></a>应用程序范围的设置</h4><p>Revit 一次使用一个共享参数文件。Application.OpenSharedParameterFile() 方法访问其路径在 SharedParametersFilename 属性中设置的共享参数文件。有关更多详细信息，请参阅共享参数。</p>
<h4 id="库内容"><a href="#库内容" class="headerlink" title="库内容"></a>库内容</h4><p>GetLibraryPaths() 和 SetLibraryPaths() 方法提供对路径信息的访问，用于标识 Revit 搜索内容的位置。</p>
<h4 id="图形显示"><a href="#图形显示" class="headerlink" title="图形显示"></a>图形显示</h4><p>BackgroundColor 属性允许读取和写入此会话中用于模型视图的背景颜色。AllowNavigationDuringRedraw 属性启用或禁用允许在重绘期间进行视图操作的选项。这可用于在重绘模型期间优化性能。</p>
<h4 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h4><p>Application 类提供了用于创建以下类型文档的方法：</p>
<ul>
<li>Family document 族文件</li>
<li>Project document 项目文档</li>
<li>Project template 项目模板</li>
</ul>
<p>OpenDocumentFile() 方法可用于打开这些文档类型中的任何一种。所有打开的文档都可以使用 Documents 属性进行检索。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<h4 id="会话信息"><a href="#会话信息" class="headerlink" title="会话信息"></a>会话信息</h4><p>UserName 等属性和GetRevitServerNetworkHosts() 等方法提供对此会话特定信息的只读访问。</p>
<h4 id="登录信息"><a href="#登录信息" class="headerlink" title="登录信息"></a>登录信息</h4><p>静态 IsLoggedIn 属性检查用户是否已从此会话登录到其 Autodesk A360 帐户。如果用户已登录，则 LoginUserId 属性将返回当前登录的用户的用户 ID。（如果用户未登录，则用户 ID 将为空。与上一节中的 UserName 不同，LoginUserId 值不是可识别的值，而是内部 ID。结合 Store Entitlement REST API，Autodesk 应用程序的发布者可以验证当前用户是否已从 Autodesk App Store 购买了其应用程序。有关 Store Entitlement API 的更多信息，请参阅 <a target="_blank" rel="noopener" href="http://www.autodesk.com/developapps%E3%80%82">www.autodesk.com/developapps。</a></p>
<h4 id="共享参数管理"><a href="#共享参数管理" class="headerlink" title="共享参数管理"></a>共享参数管理</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>Application 类公开 document 和 application 事件，例如 document open 和 save。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h4 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h4><p>“Create ”属性返回一个对象工厂，该对象工厂用于在 Revit 平台 API 中创建应用程序范围的实用程序和几何对象。如果要在 Revit Revit application memory （而不是your application’s memory）中创建对象，则使用“Create ”。</p>
<p>失败发布和处理</p>
<p>包含所有已注册的 FailureDefinitions 的 FailureDefinitionRegistry 可从静态 GetFailureDefinitionRegistry () 方法获得。静态方法 RegisterFailuresProcessor() 可用于注册自定义 IFailuresProcessor。有关发布和处理失败的更多信息，请参阅失败发布和处理。</p>
<h4 id="断开连接警告"><a href="#断开连接警告" class="headerlink" title="断开连接警告"></a>断开连接警告</h4><p>以下属性控制是否显示各种类型断开连接的图形警告。</p>
<ul>
<li>ShowGraphicalWarningCableTrayConduitDisconnects</li>
<li>ShowGraphicalWarningDuctDisconnects</li>
<li>ShowGraphicalWarningElectricalDisconnects</li>
<li>ShowGraphicalWarningHangerDisconnects</li>
</ul>
<h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>此类表示 Autodesk Revit 用户界面的活动会话，提供对 UI 自定义方法、事件和活动文档的访问。<br>文档管理</p>
<p>UIApplication 使用 UIActiveDocument 属性提供对活动文档的访问。此外，可以使用重载的 OpenAndActivateDocument() 方法打开 Revit 文档。文档将在默认视图处于活动状态的情况下打开。此方法不能在事务中调用，并且只能在事件期间调用 Revit 中尚未打开活动文档，并且该事件未嵌套在其他事件中。</p>
<h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4><p>ActiveAddInId 属性获取当前活动的外部应用程序或外部命令 ID，而 LoadedApplications 属性返回成功加载的外部应用程序的数组。</p>
<h4 id="功能区面板实用程序"><a href="#功能区面板实用程序" class="headerlink" title="功能区面板实用程序"></a>功能区面板实用程序</h4><p>使用 UIApplication 对象将新的功能区面板和控件添加到 Revit。<br>有关更多详细信息，请参阅“加载项集成”部分中的 Ribbon 面板和控件。</p>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>DrawingAreaExtents 属性返回一个矩形，该矩形表示绘图区域的屏幕像素坐标，而 MainWindowExtents 属性返回一个矩形，该矩形表示 Revit 主窗口的屏幕像素坐标</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>UIApplication 类公开与 UI 相关的事件，例如显示对话框时。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h3 id="学科控制"><a href="#学科控制" class="headerlink" title="学科控制"></a>学科控制</h3><p>The properties:</p>
<ul>
<li>Application.IsArchitectureEnabled</li>
<li>Application.IsStructureEnabled</li>
<li>Application.IsStructuralAnalysisEnabled</li>
<li>Application.IsMassingEnabled</li>
<li>Application.IsEnergyAnalysisEnabled</li>
<li>Application.IsSystemsEnabled</li>
<li>Application.IsMechanicalEnabled</li>
<li>Application.IsMechanicalAnalysisEnabled</li>
<li>Application.IsElectricalEnabled</li>
<li>Application.IsElectricalAnalysisEnabled</li>
<li>Application.IsPipingEnabled</li>
<li>Application.IsPipingAnalysisEnabled</li>
</ul>
<p>提供对可用学科的 READ 和 MODIFY 访问权限。应用程序可以读取属性以确定何时启用或禁用其 UI 的各个方面。</p>
<p>切换领域状态时，Revit 的 UI 将进行调整，并且将根据需要启用或禁用某些操作和功能。启用分析模式仅在启用相应专业时生效。例如，除非还启用了机械专业，否则启用 Mechanical Analysis 不会生效。</p>
<h3 id="如何使用Application属性为外接程序强制实施正确的版本"><a href="#如何使用Application属性为外接程序强制实施正确的版本" class="headerlink" title="如何使用Application属性为外接程序强制实施正确的版本"></a>如何使用Application属性为外接程序强制实施正确的版本</h3><p>有时，由于存在特定的修复或兼容的 API，您需要仅在存在特定的 Revit Update Release 的情况下运行附加模块。</p>
<p>使用“Application”的属性可以检查 Revit 的特定版本。属性 VersionNumber 将返回表示主版本号的字符串，而 VersionBuild 属性将返回 Autodesk Revit 应用程序的内部内部版本号。</p>
<p>另一个有用的属性是 Application.SubVersionNumber 属性。它返回一个字符串，该字符串表示 Revit 应用程序的主要-次要版本号，例如“2018.0.0”。Autodesk 会针对所有主要和次要更新更新更新此字符串。小版本（如 2018.1.0）可能具有初始客户版本（如 2018.0.0）中未提供的其他 API 和功能。为支持初始版本而编写的加载项可能与订阅更新兼容，但在订阅更新中使用新功能的加载项将与初始版本不兼容。</p>
<p>以下示例代码演示了一种技术，用于确定 Revit 版本是否为初始已知 Revit 版本之后的任何 Update Release。</p>
<p>代码区域：使用 VersionBuild 确定您的外接程序是否兼容</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetVersionInfo</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">// 20110309_2315 is the datecode of the initial release of Revit 2012 </span></span><br><span class="line">   <span class="keyword">if</span> (app.VersionNumber == <span class="string">&quot;2012&quot;</span> &amp;&amp; </span><br><span class="line">       String.Compare(app.VersionBuild, <span class="string">&quot;20110309_2315&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog.Show(<span class="string">&quot;Supported version&quot;</span>, </span><br><span class="line">                      <span class="string">&quot;This application supported in this version.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog dialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Unsupported version.&quot;</span>);</span><br><span class="line">       dialog.MainIcon = TaskDialogIcon.TaskDialogIconWarning;</span><br><span class="line">       dialog.MainInstruction = <span class="string">&quot;This Revit 2012 application is supported in UR1 and later releases.&quot;</span>;</span><br><span class="line">       dialog.Show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Document功能"><a href="#Document功能" class="headerlink" title="Document功能"></a>Document功能</h2><p>Document存储 Revit 图元、管理数据并更新多个数据视图。Document 类主要提供以下功能。</p>
<p>Document </p>
<p>Document 类表示打开的 Autodesk Revit 项目。</p>
<p>Settings 属性</p>
<p>Settings 属性返回一个对象，该对象提供对 Revit 项目中常规组件的访问。有关更多详细信息，请参阅设置。</p>
<p>地点和位置</p>
<p>每个项目只有一个场地位置，用于标识 Earth 上的物理项目位置。一个工程可以有多个工程位置。每个位置都是站点位置的偏移或旋转。有关更多详细信息，请参阅地点和位置。</p>
<p>视图管理</p>
<p>一个项目文档可以有多个视图。ActiveView 属性返回表示活动视图的 View 对象。您可以过滤项目中的图元以检索其他视图。有关更多详细信息，请参阅 视图。</p>
<p>元素检索</p>
<p>Document 对象将元素存储在项目中。使用 Element 属性按 ElementId 或 UniqueId 检索特定元素。<br>有关更多详细信息，请参阅 Elements Essential。</p>
<p>文件管理</p>
<p>每个 Document 对象都代表一个 Revit 项目文件。Document 提供如下功能：<br>检索文件信息，例如文件路径名和项目标题。<br>提供 Close() 和 Save() 方法来关闭和保存文档。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<p>元素管理</p>
<p>Revit 会保留项目中的所有图元对象。要创建新图元，请使用“Create”属性，该属性返回用于在 Revit 平台 API 中创建新项目图元实例（如 FamilyInstance 或 Group）的对象工厂。<br>Document 类还可用于删除元素。使用 Delete() 方法删除项目中的元素。已删除的元素和任何从属元素不会显示，并且会从文档中删除。对已删除元素的引用无效，并会导致异常。有关更多详细信息，请参阅编辑元素。</p>
<p>事件</p>
<p>某些操作会引发事件，例如当您使用 Save 或 Save As 保存项目时。要在应用程序中捕获事件并做出响应，必须注册事件处理程序。有关更多详细信息，请参阅 事件。</p>
<p>文档状态</p>
<p>多个属性提供有关文档状态的信息：</p>
<ul>
<li>IsModifiable - 当前是否可以修改文档（这意味着文档中有一个活动事务，并且更改不会被其他任何内容暂时阻止）</li>
<li>IsModified - 文档在打开或保存后是否发生更改</li>
<li>IsReadOnly - 如果为 true，则文档当前为只读且无法修改</li>
<li>IsReadOnlyFile - 文档是否以只读模式打开</li>
<li>IsFamilyDocument - 文档是否为家庭文档</li>
<li>IsWorkshared - 是否已在文档中启用工作集</li>
</ul>
<p>其他</p>
<p>Document 还提供其他功能：</p>
<ul>
<li>ParameterBindings 属性 - 参数定义和类别之间的映射。有关更多详细信息，请参阅共享参数。</li>
<li>ReactionsAreUpToDate 属性 - 报告反作用载荷是否发生变化。有关更多详细信息，请参阅负载。</li>
<li>Default Types - 访问族和非族元素的默认类型。有关更多详细信息，请参阅默认类型。</li>
</ul>
<p>UIDocument</p>
<p>UIDocument 类表示在 Revit 用户界面中打开的 Autodesk Revit 项目。</p>
<p>元素检索</p>
<p>使用 UIDocument 中的 Selection 属性检索所选元素。此属性返回一个对象，该对象表示包含所选项目元素的活动选择。它还提供了 UI 交互方法，用于在 Revit 模型中拾取对象。有关更多详细信息，请参阅 Elements Essentials。</p>
<p>元素显示</p>
<p>ShowElements() 方法使用来关注多个元素。</p>
<p>视图管理</p>
<p>通过调用 RefreshActiveView() 方法，可以使用 UIDocument 类来刷新活动文档中的活动视图。ActiveView 属性可用于检索或设置文档的活动视图。更改活动视图有一些限制。它只能在活动文档中使用，该文档不得处于只读状态，也不得位于事务中。此外，在 ViewActivating 或 ViewActivated 事件期间，或任何操作前事件 （如 DocumentSaving、DocumentClosing 或其他类似事件） 期间，不得更改活动视图。</p>
<p>UIDocument.ActiveGraphicalView 属性检索文档的活动图形视图。与 UIDocument.ActiveView 不同，如果用户碰巧在其中一个视图中进行选择，则此属性将永远不会返回辅助视图（如 Project Browser 或 System Browser）。</p>
<p>UIDocument 还可用于获取 Revit 用户界面中所有打开的视图窗口的列表。GetOpenUIViews 方法返回一个 UIViews 列表，其中包含有关 Revit 用户界面中视图窗口的数据。</p>
<h3 id="Default-Types-默认类型"><a href="#Default-Types-默认类型" class="headerlink" title="Default Types 默认类型"></a>Default Types 默认类型</h3><p>Revit 具有不同类别的默认类型。调用相关工具创建此类别的图元时，此默认类型将显示在 Revit 用户界面中。Revit API 通过 Document 类公开族和非族类型的默认类型。</p>
<p>族类型</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultFamilyTypeId()</td>
<td align="left">获取与给定族类别 ID 关联的默认系列类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultFamilyTypeId()</td>
<td align="left">设置与给定族类别 ID 关联的默认族类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultFamilyTypeIdValid()</td>
<td align="left">检查族类型 ID 是否有效，可设置为给定族类别 ID 的默认值。</td>
</tr>
</tbody></table>
<p>此外，给定 ElementType，ElementType.IsValidDefaultFamilyType() 标识它是否是给定族类别 ID 的有效默认族类型。 以下示例演示了如何获取结构柱类别的默认族类型 ID。然后，它获取默认类型的族符号并将其分配给给定的柱。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AssignDefaultTypeToColumn</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultTypeId = document.GetDefaultFamilyTypeId(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_StructuralColumns));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultTypeId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol defaultType = document.GetElement(defaultTypeId) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        <span class="keyword">if</span> (defaultType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            column.Symbol = defaultType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例在首先检查给定门是否为有效的默认族类型 ID 后，为给定门的门类别设置默认类型。</p>
<p>代码区域：设置默认族类型 ID</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDefaultTypeFromDoor</span>(<span class="params">Document document, FamilyInstance door</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId doorCategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is necessary to test the type suitability to be a default family type, for not every type can be set as default. </span></span><br><span class="line">    <span class="comment">// Trying to set a non-qualifying default type will cause an exception</span></span><br><span class="line">    <span class="keyword">if</span> (door.Symbol.IsValidDefaultFamilyType(doorCategoryId))</span><br><span class="line">    &#123;</span><br><span class="line">        document.SetDefaultFamilyTypeId(doorCategoryId, door.Symbol.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非族类型</p>
<p>下表中的文档成员提供对非 Family 元素类型的默认类型的访问。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultElementTypeId()</td>
<td align="left">获取给定非 Family 元素类型的默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultElementTypeId()</td>
<td align="left">为给定的非 Family 元素类型设置默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultElementTypeIdValid()</td>
<td align="left">检查元素类型 ID 是否对给定的非 Family 元素类型有效。</td>
</tr>
</tbody></table>
<p>下面的示例检查给定的墙壁是否使用墙壁类型的默认元素类型。</p>
<p>代码区域：获取默认元素类型 ID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private bool IsWallUsingDefaultType(Document document, Wall wall)</span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultElementTypeId = document.GetDefaultElementTypeId(ElementTypeGroup.WallType);</span><br><span class="line">    return (wall.WallType.Id == defaultElementTypeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文档和文件管理"><a href="#文档和文件管理" class="headerlink" title="文档和文件管理"></a>文档和文件管理</h2><p>文档和文件管理使创建和查找文档变得容易。</p>
<p>文档检索</p>
<p>Application 类维护所有文档。如前所述，您可以在一个会话中打开多个文档。使用 UIApplication 类属性 ActiveUIDocument 检索活动文档。所有打开的文档（包括活动文档）都使用 Application 类 Documents 属性进行检索。该属性返回一个包含 Revit 任务中所有打开的文档的集。</p>
<p>文档文件信息</p>
<p>Document 类为每个相应的文件提供两个属性，即 PathName 和 Title。</p>
<p>PathName 返回文档的完全限定文件路径。如果项目自创建以来尚未保存，则 PathName 将返回空字符串。</p>
<p>Title 是项目标题，通常从项目文件名派生而来。返回值因您的系统设置而异。</p>
<p>打开文档</p>
<p>Application 类提供了一个重载的方法来打开现有项目文件：</p>
<p>表 3：在 API 中打开文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Document OpenDocumentFile(string filename )<br /> Document OpenDocumentFile(ModelPath modelPath, OpenOptions openOptions)</td>
<td>DocumentOpened 文档已打开</td>
</tr>
</tbody></table>
<p>指定具有完全限定文件路径的字符串时，Revit 将打开该文件并创建一个 Document 实例。使用此方法可以通过为此方法分配文件通用命名转换 （UNC） 名称，在其他计算机上打开文件。该文件可以是扩展名为 .rvt 的项目文件、扩展名为 .rfa 的族文件或扩展名为 .rte 的样板文件。第二个重载将模型的路径作为 ModelPath 而不是字符串，并且 OpenOptions 参数提供用于打开文件的选项，例如从中心分离打开的文档（如果适用）的功能，以及与工作共享相关的选项。有关打开工作共享文档的更多信息，请参阅打开工作共享文档。这些方法在发生故障时引发特定的记录异常。例外情况分为 4 大类。</p>
<p>表 4：引发的异常类型</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Example 例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Disk errors 磁盘错误</td>
<td>文件不存在或版本错误</td>
</tr>
<tr>
<td>Resource errors 资源错误</td>
<td>没有足够的内存或磁盘空间来打开文件</td>
</tr>
<tr>
<td>Central model file errors 中心模型文件错误</td>
<td>文件已锁定或损坏</td>
</tr>
<tr>
<td>Central model&#x2F;server errors 中心模型&#x2F;服务器错误</td>
<td>与服务器发生网络通信错误</td>
</tr>
</tbody></table>
<p>如果文档打开成功，则会引发 DocumentOpened 事件。</p>
<p> 创建文档 </p>
<p>使用下表中的 Application 方法创建新文档。<br>表 5：在 API 中创建文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Document NewProjectDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectDocument(UnitSystem unitSystem);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewFamilyDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectTemplateDocument(string templateFilename);</code></td>
<td>DocumentCreated</td>
</tr>
</tbody></table>
<p>对于需要模板文件名作为参数的方法，将基于模板文件返回创建的文档。NewProjectDocument（UnitSystem）将创建一个没有指定模板的新英制或公制项目文档。</p>
<p>保存并关闭文档 Document 类提供了保存或关闭实例的方法。</p>
<p>表 6：在 API 中保存和关闭文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Save() 保存</td>
<td>DocumentSaved 文档已保存</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
<tr>
<td>Close() 关闭</td>
<td>DocumentClosed 文档已关闭</td>
</tr>
</tbody></table>
<p>Save() 有 2 个重载，一个没有参数，另一个带有 SaveOptions 参数，可以指定是否强制操作系统从磁盘上的文件中删除所有死数据。如果之前未保存该文件，则必须改为调用 SaveAs()。 </p>
<p>SaveAs() 有 3 个重载。一个重载仅将文件名作为参数，如果存在另一个具有给定文件名的文件，则会引发异常。其他 2 个重载将文件名作为参数（在一种情况下以 ModelPath 的形式）以及第二个 SaveAsOptions 参数，该参数可用于指定是否覆盖现有文件（如果存在）。SaveAsOptions 还可用于指定其他相关选项，例如是否删除磁盘上与文件相关的死数据和工作共享选项。 Save() 和 SaveAs() 在与打开文档时相同的 4 个类别中引发特定的记录异常，如上面的表 4 所示。</p>
<p> Close() 有两个重载。一个参数采用 Boolean 参数，该参数指示是否在关闭文件之前保存文件。第二个重载不带任何参数，如果文档被修改，系统会询问用户是否要在关闭之前保存文件。如果尚未设置文档的路径名，或者保存的目标文件是只读的，则此方法将引发异常。</p>
<p>注： Close() 方法不会影响活动文档或引发 DocumentClosed 事件，因为该文档由外部应用程序使用。您只能对非活动文档调用此方法。UIDocument 类还提供了保存和关闭实例的方法。</p>
<p>表 7：在 API 中保存和关闭 UIDocument</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SaveAndClose()</td>
<td>DocumentSaved, DocumentClosed</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
</tbody></table>
<p>SaveAndClose() 在保存文档后关闭文档。如果尚未设置文档的路径名称，则向 Revit 用户显示“另存为”对话框，以设置其名称和位置。 SaveAs() 方法将文档保存为通过“另存为”对话框从 Revit 用户处获取的文件名和路径。</p>
<p>文档预览</p>
<p> 可以从 Document 获取 DocumentPreviewSettings 类，该类包含与保存给定文档的预览图像相关的设置。</p>
<p>代码区域：文档预览</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveActiveViewWithPreview</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the handle of current document.</span></span><br><span class="line">    Autodesk.Revit.DB.Document document = application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the document&#x27;s preview settings</span></span><br><span class="line">    DocumentPreviewSettings settings = document.GetDocumentPreviewSettings();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find a candidate 3D view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line">    </span><br><span class="line">    Func&lt;View3D, <span class="built_in">bool</span>&gt; isValidForPreview = v =&gt; settings.IsViewIdValidForPreview(v.Id);</span><br><span class="line">    </span><br><span class="line">    View3D viewForPreview = collector.OfType().First(isValidForPreview);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the preview settings</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction setTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Set preview view id&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        setTransaction.Start();</span><br><span class="line">        settings.PreviewViewId = viewForPreview.Id;</span><br><span class="line">        setTransaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the document</span></span><br><span class="line">    document.Save();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>荷载族</p>
<p>Document 类使您能够将整个族及其所有符号加载到项目中。由于加载整个族可能需要很长时间和大量内存，因此 Document 类提供了类似的方法 LoadFamilySymbol() 来仅加载指定的符号。有关更多详细信息，请参阅 族。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>下表标识了 Revit Platform UI“管理”选项卡中的命令以及相应的 API。</p>
<p>表 7：API 和 UI 中的设置</p>
<table>
<thead>
<tr>
<th><strong>UI 命令</strong></th>
<th><strong>关联 API</strong></th>
<th><strong>参考</strong></th>
</tr>
</thead>
<tbody><tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目信息</td>
<td>Document.ProjectInformation</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目参数</td>
<td>Document.ParameterBindings (Only for Shared Parameter)</td>
<td>请参阅<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Shared_Parameters">共享参数</a></td>
</tr>
<tr>
<td>“项目位置”面板</td>
<td>Document.ProjectLocations</td>
<td>查看<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Place_and_Locations">地点和位置</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 其他设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 填充图案</td>
<td>FilteredElementCollector filtering on class FillPatternElement</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 材质</td>
<td>FilteredElementCollector filtering on class Material</td>
<td>请参阅<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Material_Management">物料管理</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 对象样式</td>
<td>Document.Settings.Categories</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>阶段划分 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 阶段</td>
<td>Document.Phases</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 结构设置</td>
<td>Loads and related structural settings are available in the API</td>
<td>参见 <a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Structural_Engineering">Structural Engineering</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目单位</td>
<td>Document.GetUnits()</td>
<td>见<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Units">单位</a></td>
</tr>
<tr>
<td>面积和体积计算（在房间和面积面板上）</td>
<td>AreaVolumeSettings.GetAreaVolumeSettings()</td>
<td>请参阅以下注释</td>
</tr>
</tbody></table>
<p>注意：项目信息 - API 提供 ProjectInfo 类，该类使用 Document.ProjectInformation 检索，以表示 Revit 项目中的项目信息。下表标识了 Project Information 参数的相应 API。</p>
<p>表 8：项目信息</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>对应 API</strong></th>
<th><strong>内置参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Project Issue Date 项目发布日期</td>
<td>ProjectInfo.IssueDate</td>
<td>PROJECT_ISSUE_DATE</td>
</tr>
<tr>
<td>Project Status 项目进展</td>
<td>ProjectInfo.Status</td>
<td>PROJECT_STATUS</td>
</tr>
<tr>
<td>Client Name 客户端名称</td>
<td>ProjectInfo.ClientName</td>
<td>CLIENT_NAME</td>
</tr>
<tr>
<td>Project Address 项目地址</td>
<td>ProjectInfo.Address</td>
<td>PROJECT_ADDRESS</td>
</tr>
<tr>
<td>Project Name 项目名称</td>
<td>ProjectInfo.Name</td>
<td>PROJECT_NAME</td>
</tr>
<tr>
<td>Project Number 项目编号</td>
<td>ProjectInfo.Number</td>
<td>PROJECT_NUMBER</td>
</tr>
</tbody></table>
<p>使用 ProjectInfo 公开的属性来检索和设置所有字符串。这些属性由相应的内置参数实现。您可以直接通过内置参数获取或设置值。有关如何通过内置参数访问这些参数的更多信息，请参阅“Elements Essentials”部分中的参数。获取项目信息的推荐方法是使用 ProjectInfo 属性。</p>
<p>Fill Patterns</p>
<p>使用对类 FillPatternElement 的 FilteredElementCollector 过滤来检索当前文档中的所有填充图案。可以使用静态方法 FillPatternElement.GetFillPattern（Document， ElementId） 或 FillPatternElement.GetFillPatternByName （Document， string） 来检索特定的 FillPattern。</p>
<p>Object Styles</p>
<p>使用 Settings.Categories 检索 Category 对象中除 Line Style 之外的所有信息。有关更多详细信息，请参阅 Elements Essentials和 Material 部分中的 Other Classifications。</p>
<p>Phases</p>
<p>Revit 按阶段维护图元生命周期，阶段是项目生命周期中的不同时间段。文档中的所有阶段都使用 Document.Phases 属性进行检索。该属性返回一个包含 Phase 类实例的数组。但是，Revit API 不会公开 Phase 类中的函数。</p>
<p>Options</p>
<p> “Options”命令用于配置项目全局设置。您可以使用 Application.Options 属性检索 Options.Application 实例。目前，Options.Application 类仅支持访问库路径和共享参数文件。</p>
<p>Area and Volume Calculations</p>
<p>AreaVolumeSettings 类允许您启用或禁用体积计算，以及更改房间边界位置。</p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>Revit API 中用于处理单位的两个主要类是 Units 和 FormatOptions。Units 类表示文档的默认设置，用于将带有单位的数字格式设置为字符串。它包含每个单位类型的 FormatOptions 对象以及与小数符号和数字分组相关的设置。</p>
<p>Units 类为每个有效的 Unit 类型存储一个 FormatOptions 对象，但并非所有 Unit 类型都可以直接修改。有些 （如 UT_Number 和 UT_SiteAngle）具有固定的定义。其他单位的定义是从其他单位类型自动派生的。例如，UT_SheetLength 派生自 UT_Length UT_ForceScale 派生自 UT_Force。</p>
<p>FormatOptions 类包含一些设置，这些设置控制如何将带有单位的数字格式设置为字符串。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置，例如舍入、准确性、显示单位以及是否禁止空格或前导零或尾随零。</p>
<p>FormatOptions 类以两种不同的方式使用。Units 类中的 FormatOptions 对象表示文档的默认设置。在其他位置使用的 FormatOptions 对象表示可以选择性地覆盖默认设置的设置。</p>
<p>UseDefault 属性控制 FormatOptions 对象是表示默认格式还是自定义格式。如果 UseDefault 为 true，则格式设置将根据 Units 类中的默认设置进行，并且对象中的其他设置都没有意义的。如果 UseDefault 为 false，则对象包含替代 Units 类中的默认设置的自定义设置。对于 Units 类中的 FormatOptions 对象，UseDefault 始终为 false。</p>
<p>Revit API 中与单元相关的重要枚举包括：</p>
<ul>
<li>UnitType - 要测量的物理量类型，例如长度或力（UT_Length 或 UT_Force）</li>
<li>DisplayUnitType - 用于将数字格式化为字符串或转换单位（即 DUT_METERS）的单位和显示格式</li>
<li>UnitSymbolType - 以数字的格式化字符串表示形式显示的单位符号，以指示值的单位（即 UST_M）</li>
</ul>
<p>单位换算<br>Revit API 提供了实用程序类，以便于在 Revit 中处理数量。使用 UnitUtils 类，可以轻松地将单位数据与 Revit 的内部单位相互转换。<br>Revit 有七个基本单位，每个基本单位都有自己的内部单位。下表列出了这些内部单位。</p>
<p>表 9：Revit Unit System 中的 7 个基本单元</p>
<table>
<thead>
<tr>
<th><strong>基本单位</strong></th>
<th><strong>Revit 中的单位</strong></th>
<th><strong>单位制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Length 长度</td>
<td>Feet (ft) 英尺（英尺）</td>
<td>Imperial 英制</td>
</tr>
<tr>
<td>Angle 角度</td>
<td>Radian 弧度</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Mass 质量</td>
<td>Kilogram (kg) 千克 （kg）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Time 时间</td>
<td>Seconds (s) 秒 （s）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Electric Current 电流</td>
<td>Ampere (A) 安培 （A）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Temperature 温度</td>
<td>Kelvin (K) 开尔文 （K）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Luminous Intensity 发光强度</td>
<td>Candela (cd) 坎德拉 （cd）</td>
<td>Metric 公制</td>
</tr>
</tbody></table>
<p>注意：由于 Revit 以英尺为单位存储长度，以公制单位存储其他基本量，因此涉及长度的派生单位将是基于英制和公制的非标准单位。例如，由于力是以“每时间平方的质量长度”来测量的，因此它以 kg-ft &#x2F; s2 为单位存储。以下示例使用 UnitUtils.ConvertFromInternalUnits() 方法获取材料的最小屈服应力（以 kips&#x2F;平方英寸为单位）。</p>
<p>代码区域：从 Revit 的内部单位转换</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetYieldStressInKsi</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dMinYieldStress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Get the structural asset for the material</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the min yield stress and convert to ksi</span></span><br><span class="line">            dMinYieldStress = asset.MinimumYieldStress;</span><br><span class="line">            dMinYieldStress = UnitUtils.ConvertFromInternalUnits(dMinYieldStress,</span><br><span class="line">                DisplayUnitType.DUT_KIPS_PER_SQUARE_INCH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> dMinYieldStress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnitUtils 还可用于将值从一种单位类型转换为另一种单位类型，例如平方英尺到平方米。在以下示例中，以英寸为单位输入的墙的顶部偏移值将转换为英尺，这是设置该值的预期单位。</p>
<p>代码区域：在单位之间转换</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTopOffset</span>(<span class="params">Wall wall, <span class="built_in">double</span> dOffsetInches</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// convert user-defined offset value to feet from inches prior to setting</span></span><br><span class="line">    <span class="built_in">double</span> dOffsetFeet = UnitUtils.Convert(dOffsetInches,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_INCHES,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_FEET);</span><br><span class="line"></span><br><span class="line">    Parameter paramTopOffset = wall.get_Parameter(BuiltInParameter.WALL_TOP_OFFSET);</span><br><span class="line">    paramTopOffset.Set(dOffsetFeet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单元格式设置和解析</p>
<p>另一个实用程序类 UnitFormatUtils 可以格式化数据或分析格式化单元数据。</p>
<p>重载方法 Format() 可用于根据格式设置选项将值格式化为字符串，如以下示例所示。检索材料密度，然后使用 Format() 方法将该值转换为用户友好的单位值。</p>
<p>代码区域：将值格式化为字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDensityOfMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> density = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get structural asset of material in order to get the density</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            density = asset.Density;</span><br><span class="line">            <span class="comment">// convert the density value to a user readable string that includes the units</span></span><br><span class="line">            Units units = material.Document.GetUnits();</span><br><span class="line">            <span class="comment">// false for maxAccuracy means accuracy specified by the FormatOptions should be used</span></span><br><span class="line">            <span class="comment">// false for forEditing since this will be for display only and no formatting modifications are necessary</span></span><br><span class="line">            <span class="built_in">string</span> strDensity = UnitFormatUtils.Format(units, UnitType.UT_UnitWeight, density, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Raw Value: &#123;0&#125;\r\nFormatted Value: &#123;1&#125;&quot;</span>, density, strDensity);</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Material Density&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的 UnitFormatUtils.TryParse() 方法使用指定单位类型的 Revit 内部单位（如果可能）将格式化字符串（包括单位）解析为值。以下示例采用用户输入的长度值（假定为数字和长度单位），并尝试将其分析为长度值。出于演示目的，将结果与 TaskDialog 中的输入字符串进行比较。</p>
<p>代码区域：解析字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetLengthInput</span>(<span class="params">Document document, String userInputLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dParsedLength = <span class="number">0</span>;</span><br><span class="line">    Units units = document.GetUnits();</span><br><span class="line">    <span class="comment">// try to parse a user entered string (i.e. 100 mm, 1&#x27;6&quot;)</span></span><br><span class="line">    <span class="built_in">bool</span> parsed = UnitFormatUtils.TryParse(units, UnitType.UT_Length, userInputLength, <span class="keyword">out</span> dParsedLength);</span><br><span class="line">    <span class="keyword">if</span> (parsed == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;User Input: &#123;0&#125;\r\nParsed value: &#123;1&#125;&quot;</span>, userInputLength, dParsedLength);</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Parsed Data&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dParsedLength;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/12/28/03%E5%BA%94%E7%94%A8%E5%8F%8A%E6%96%87%E6%A1%A3/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">3</span>
    
    <a class="page-num" href="/page/4">
        4
    </a>
    
    
    
    
    <a class="page-num" href="/page/4/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">John Doe</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 funtim
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
