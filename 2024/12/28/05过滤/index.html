
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title> | funtim</title>
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>FUNTIM</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;FUNTIM</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/12/28
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="Filtering-过滤"><a href="#Filtering-过滤" class="headerlink" title="Filtering 过滤"></a>Filtering 过滤</h1><p>Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。</p>
<p>获取通过指定过滤器的元素的基本步骤如下：</p>
<ol>
<li>创建新的FilteredElementCollector</li>
<li>对它应用一个或多个过滤器</li>
<li>获取过滤后的元素或元素ID（使用以下几种方法之一）</li>
</ol>
<p>下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。</p>
<p><strong>代码区域6-1：使用元素过滤获取文档中的所有墙实例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all Wall instances in the document by using category filter</span></span><br><span class="line">ElementCategoryFilter filter = <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// Use shortcut WhereElementIsNotElementType() to find wall instances only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList walls = </span><br><span class="line">collector.WherePasses(filter).WhereElementIsNotElementType().ToElements();</span><br><span class="line">String prompt = <span class="string">&quot;The walls in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> walls)</span><br><span class="line">&#123;</span><br><span class="line">        prompt += e.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p><strong>Pages in this section 本节中的页面</strong></p>
<ul>
<li>创建FilteredElementCollector</li>
<li>应用过滤器</li>
<li>获取筛选的元素或元素ID</li>
<li>LINQ查询</li>
<li>边界框过滤器</li>
<li>元素交叉过滤器</li>
</ul>
<h2 id="创建FilteredElementCollector"><a href="#创建FilteredElementCollector" class="headerlink" title="创建FilteredElementCollector"></a>创建FilteredElementCollector</h2><p>用于元素迭代和筛选的主类称为FilteredElementCollector。它以三种方式之一构建：</p>
<ol>
<li>从文档-将搜索和筛选文档中的元素集</li>
<li>从一个文档和一组ElementId-将搜索和筛选一组指定的元素</li>
<li>从文档和视图-将搜索和过滤视图中的可见元素</li>
</ol>
<p><em><strong>注意：</strong></em>使用静态FilteredElementCollector.IsViewValidForElementIteration()过滤指定视图中的元素时，请始终检查视图是否对元素迭代有效。</p>
<p>首次创建对象时，没有应用任何过滤器。此类要求在尝试访问元素之前至少设置一个条件，否则将引发异常。</p>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h2><p>可以使用ElementFilters将筛选器应用于FilteredElementCollector。ElementFilter是一个类，它检查元素以查看它是否满足特定条件。ElementFilter基类有三个派生类，它们将元素筛选器分为三个类别。</p>
<ul>
<li><em><strong>ElementQuickFilter</strong></em>-快速过滤器仅在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。</li>
<li><em><strong>ElementSlowFilter</strong></em>-慢过滤器要求首先获取元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。</li>
<li><em><strong>ElementLogicalFilter</strong></em>-逻辑筛选器将联合收割机两个或多个筛选器逻辑组合。Revit可能会对构件过滤器重新排序，以使最快作用的过滤器首先被评估。</li>
</ul>
<p>大多数过滤器可以使用重载构造函数来反转，该重载构造函数接受指示反转过滤器的布尔参数，以便通常被过滤器接受的元素将被拒绝，而通常被拒绝的元素将被接受。不能反转的过滤器在下面的相应部分中注明。</p>
<p>有一组预定义的过滤器可用于常见用途。这些内置过滤器中的许多都为上面的FilteredElementCollector部分中提到的FilteredElementCollector快捷方法提供了基础。接下来的三个部分提供了有关内置过滤器的更多信息。</p>
<p>创建筛选器后，需要将其应用于FilteredElementCollector。泛型方法WherePasses()用于将单个ElementFilter应用于FilteredElementCollector。</p>
<p>还可以使用FilteredElementCollector提供的许多快捷方法应用筛选器。有些应用一个特定的过滤器而不需要进一步的输入，比如WhereElementIsCurveDriven()，而其他应用一个特定的过滤器而只需要一个简单的输入，比如OfCategory()方法，它将BuiltInCategory作为一个参数。最后，还有一些方法，如UnionWith()，可以将过滤器连接在一起。所有这些方法都返回相同的收集器，从而可以轻松地将过滤器链接在一起。</p>
<h3 id="Quick-filters-快速筛选器"><a href="#Quick-filters-快速筛选器" class="headerlink" title="Quick filters 快速筛选器"></a>Quick filters 快速筛选器</h3><p>快速过滤器只在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。下表总结了内置的快速过滤器，下面是一些过滤器的示例。</p>
<p><strong>Table 13: Built-in Quick Filters<br>表13：内置快速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BoundingBoxContainsPointFilter</td>
<td>具有包含给定点的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIntersectsFilter</td>
<td>具有与给定轮廓相交的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIsInsideFilter</td>
<td>在给定轮廓内有边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementCategoryFilter</td>
<td>id 与输入类别id匹配的元素</td>
<td>OfCategoryId()</td>
</tr>
<tr>
<td>ElementClassFilter</td>
<td>与输入运行时类（或派生类）匹配的元素</td>
<td>OfClass()</td>
</tr>
<tr>
<td>ElementDesignOptionFilter</td>
<td>特定设计选项中的图元</td>
<td>ContainedInDesignOption()</td>
</tr>
<tr>
<td>ElementIsCurveDrivenFilter</td>
<td>曲线驱动的元素</td>
<td>WhereElementIsCurveDriven()</td>
</tr>
<tr>
<td>ElementIsElementTypeFilter</td>
<td>属于“元素类型”的元素</td>
<td>WhereElementIsNotElementType()</td>
</tr>
<tr>
<td>ElementMulticategoryFilter</td>
<td>与给定类别集中的任何一个相匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementMulticlassFilter</td>
<td>与给定的类（或派生类）集匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementOwnerViewFilter</td>
<td>视图专有的图元</td>
<td>OwnedByView()<br />WhereElementIsViewIndependent()</td>
</tr>
<tr>
<td>ElementStructuralTypeFilter</td>
<td>与给定结构类型匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ExclusionFilter</td>
<td>除元素id之外的所有元素都输入到过滤器</td>
<td>Excluding()</td>
</tr>
<tr>
<td>FamilySymbolFilter</td>
<td>特定族的Symbol</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>FamilySymbolFilter不能反转。</p>
<p><strong>注意：</strong>边界框过滤器排除所有从View派生的对象和从ElementType派生的对象。 下面的示例在文档中创建一个大纲，然后使用BoundingBoxIntersectsFilter查找文档中具有与该大纲相交的边界框的元素。然后，它展示了如何使用反向过滤器来查找边界框不与给定轮廓相交的所有墙。请注意，使用OfClass()方法也会将ElementClassFilter应用于集合。</p>
<p><strong>代码区域6-2：BoundingBoxIntersectsFilter示例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use BoundingBoxIntersects filter to find elements with a bounding box that intersects the </span></span><br><span class="line"><span class="comment">// given Outline in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Outline, uses a minimum and maximum XYZ point to initialize the outline. </span></span><br><span class="line">Outline myOutLn = <span class="keyword">new</span> Outline(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxIntersects filter with this Outline</span></span><br><span class="line">BoundingBoxIntersectsFilter filter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// This filter excludes all objects derived from View and objects derived from ElementType</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList elements = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all walls which don&#x27;t intersect with BoundingBox: use an inverted filter </span></span><br><span class="line"><span class="comment">// to match elements</span></span><br><span class="line"><span class="comment">// Use shortcut command OfClass() to find walls only</span></span><br><span class="line">BoundingBoxIntersectsFilter invertFilter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList notIntersectWalls = collector.OfClass(<span class="keyword">typeof</span>(Wall)).WherePasses(invertFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下一个示例使用排除过滤器查找文档中当前未选定的所有墙。</p>
<p>代码区域6-3：创建排除过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all walls that are not currently selected, </span></span><br><span class="line"><span class="comment">// Get all element ids which are current selected by users, exclude these ids when filtering</span></span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the selection to instantiate an exclusion filter</span></span><br><span class="line">ExclusionFilter filter = <span class="keyword">new</span> ExclusionFilter(selectedIds);</span><br><span class="line"><span class="comment">// For the sake of simplicity we do not test here whether the selection is empty or not,</span></span><br><span class="line"><span class="comment">// but in production code a proper validation would have to be done to avoid an argument</span></span><br><span class="line"><span class="comment">// exception from the filter&#x27;s consructor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document,</span></span><br><span class="line"><span class="comment">// Use shortcut method OfClass() to find Walls only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">IList walls = collector.WherePasses(filter).OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ElementClassFilter将匹配其类与输入类完全匹配的元素，或其类派生自输入类的元素。下面的示例使用ElementClassFilter获取文档中的所有加载。</p>
<p>代码区域6-4：使用ElementClassFilter获取负载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection allLoads = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>API中有一小部分元素子类不受元素类过滤器支持。这些类型存在于API中，但不存在于Revit的本机对象模型中，这意味着此过滤器不支持这些类型。为了使用类过滤器来查找这些类型的元素，需要使用更高级别的类，然后进一步处理结果以查找仅匹配子类型的元素。</p>
<p><strong>注：</strong>其中一些类型存在专用过滤器。 以下类型受此限制影响：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Dedicated Filter 专用过滤器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.Material的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CurveElement的子类</td>
<td>CurveElementFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ConnectorElement的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.HostedSweep的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.Room</td>
<td>RoomFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.Space</td>
<td>SpaceFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Area</td>
<td>AreaFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTag</td>
<td>RoomTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTag</td>
<td>SpaceTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTag</td>
<td>AreaTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CombinableElement</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mullion</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Panel</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbol</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.AreaReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.PathReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbolType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.TrussType</td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="Slow-Filters-慢过滤器"><a href="#Slow-Filters-慢过滤器" class="headerlink" title="Slow Filters 慢过滤器"></a>Slow Filters 慢过滤器</h3><p>慢过滤器要求首先获得元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。下表总结了内置的慢速过滤器，下面的几个示例提供了对某些过滤器的深入了解。</p>
<p><strong>表14：内置慢速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaFilter</td>
<td>Areas 区域</td>
<td>None</td>
</tr>
<tr>
<td>AreaTagFilter</td>
<td>Area tags 面积标记</td>
<td>None</td>
</tr>
<tr>
<td>CurveElementFilter</td>
<td>CurveElements 曲线元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementLevelFilter</td>
<td>与给定级别ID关联的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementParameterFilter</td>
<td>元素传递一个或多个参数筛选规则</td>
<td>None</td>
</tr>
<tr>
<td>ElementPhaseStatusFilter</td>
<td>给定阶段上具有给定阶段状态的元素</td>
<td>None</td>
</tr>
<tr>
<td>FamilyInstanceFilter</td>
<td>一个特定的族实例</td>
<td>None</td>
</tr>
<tr>
<td>FamilyStructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族元素</td>
<td>None</td>
</tr>
<tr>
<td>PrimaryDesignOptionMemberFilter</td>
<td>任何主设计选项所拥有的图元</td>
<td>None</td>
</tr>
<tr>
<td>RoomFilter</td>
<td>房间</td>
<td>None</td>
</tr>
<tr>
<td>RoomTagFilter</td>
<td>房间标记</td>
<td>None</td>
</tr>
<tr>
<td>SpaceFilter</td>
<td>空间</td>
<td>None</td>
</tr>
<tr>
<td>SpaceTagFilter</td>
<td>空间标签</td>
<td>None</td>
</tr>
<tr>
<td>StructuralInstanceUsageFilter</td>
<td>给定结构用途的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralWallUsageFilter</td>
<td>指定结构墙用途的墙</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定图元的实体几何相交的图元</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定实体几何相交的元素</td>
<td>None</td>
</tr>
</tbody></table>
<p>以下慢速过滤器不能反转： <em>RoomFilter</em> RoomTagFilter <em>AreaFilter</em> AreaTagFilter <em>SpaceFilter</em> * </p>
<p>FamilyInstanceFilter 如快速过滤器一节所述，有些类不能与ElementClassFilter一起使用。其中一些类，如Room和RoomTag有自己的专用过滤器。</p>
<p> 代码区域6-5：使用房间过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. It is necessary to use the </span></span><br><span class="line"><span class="comment">// RoomFilter and not an ElementClassFilter or the shortcut method OfClass() because the Room </span></span><br><span class="line"><span class="comment">// class is not supported by those methods.</span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>ElementParameterFilter是一个功能强大的过滤器，可以根据元素可能具有的参数值查找元素。它可以查找参数值与特定值匹配或大于或小于某个值的元素。ElementParameterFilter还可用于查找支持特定共享参数的元素。 下面的示例使用ElementParameterFilter查找大小超过100平方英尺的房间和小于100平方英尺的房间。</p>
<p>代码区域6-6：使用参数过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates an ElementParameter filter to find rooms whose area is </span></span><br><span class="line"><span class="comment">// greater than specified value</span></span><br><span class="line"><span class="comment">// Create filter by provider and evaluator </span></span><br><span class="line">BuiltInParameter areaParam = BuiltInParameter.ROOM_AREA;</span><br><span class="line"><span class="comment">// provider</span></span><br><span class="line">ParameterValueProvider pvp = <span class="keyword">new</span> ParameterValueProvider(<span class="keyword">new</span> ElementId((<span class="built_in">int</span>)areaParam));</span><br><span class="line"><span class="comment">// evaluator</span></span><br><span class="line">FilterNumericRuleEvaluator fnrv = <span class="keyword">new</span> FilterNumericGreater();</span><br><span class="line"><span class="comment">// rule value </span></span><br><span class="line"><span class="built_in">double</span> ruleValue = <span class="number">100.0f</span>;      <span class="comment">// filter room whose area is greater than 100 SF</span></span><br><span class="line"><span class="comment">// rule</span></span><br><span class="line">FilterRule fRule = <span class="keyword">new</span> FilterDoubleRule(pvp, fnrv, ruleValue, <span class="number">1E-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an ElementParameter filter</span></span><br><span class="line">ElementParameterFilter filter = <span class="keyword">new</span> ElementParameterFilter(fRule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find rooms whose area is less than or equal to 100: </span></span><br><span class="line"><span class="comment">// Use inverted filter to match elements</span></span><br><span class="line">ElementParameterFilter lessOrEqualFilter = <span class="keyword">new</span> ElementParameterFilter(fRule, <span class="literal">true</span>); </span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList lessOrEqualFounds = collector.WherePasses(lessOrEqualFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下面的示例显示如何使用FamilyStructuralMaterialTypeFilter查找材质类型为木材的所有族。它还说明了如何使用反向过滤器来查找材质类型不是木材的所有族。</p>
<p>代码区域6-7：查找所有使用木质材料的家庭</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use FamilyStructuralMaterialType filter to find families whose material type is Wood</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter filter = <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection woodFamiles = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find families are not Wood: Use inverted filter to match families</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter notWoodFilter = </span><br><span class="line">        <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection notWoodFamilies = collector.WherePasses(notWoodFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>最后两个慢过滤器派生自ElementIntersectsFilter，后者是用于匹配与几何体相交的元素的过滤器的基类。有关此类过滤器的使用示例，请参见几何工具类一节中的代码区域：查找附近的墙。#逻辑过滤器逻辑过滤器联合收割机将两个或多个过滤器逻辑组合。下表总结了内置的逻辑筛选器。表15：内置逻辑过滤器</p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LogicalAndFilter</td>
<td>通过2个或更多过滤器的元素</td>
<td>WherePasses()-添加一个额外的过滤器IntersectWith()-连接两组独立的过滤器</td>
</tr>
<tr>
<td>LogicalOrFilter</td>
<td>至少通过2个或多个过滤器之一的元素</td>
<td>UnionWith()-连接两组独立的过滤器</td>
</tr>
</tbody></table>
<p>在下面的示例中，使用逻辑过滤器组合了两个快速过滤器，以获取文档中的所有door FamilyInstance元素。</p>
<p>代码区域6-8：使用LogicalAndFilter查找所有门实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all door instances in the project by finding all elements that both belong to the</span></span><br><span class="line"><span class="comment">// door category and are family instances.</span></span><br><span class="line">ElementClassFilter familyInstanceFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a category filter for Doors</span></span><br><span class="line">ElementCategoryFilter doorsCategoryfilter = </span><br><span class="line">        <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a logic And filter for all Door FamilyInstances</span></span><br><span class="line">LogicalAndFilter doorInstancesFilter = <span class="keyword">new</span> LogicalAndFilter(familyInstanceFilter, </span><br><span class="line">        doorsCategoryfilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList doors = collector.WherePasses(doorInstancesFilter).ToElements();</span><br></pre></td></tr></table></figure>



<h2 id="获取筛选的元素或元素ID"><a href="#获取筛选的元素或元素ID" class="headerlink" title="获取筛选的元素或元素ID"></a>获取筛选的元素或元素ID</h2><p>将一个或多个过滤器应用于FilteredElementCollector后，可以通过以下三种方式之一来检索已过滤的元素集：</p>
<ol>
<li>获取Elements或ElementId的集合。<ul>
<li>ToElements()-返回通过所有应用的过滤器的所有元素</li>
<li>ToElementIds()-返回通过所有应用过滤器的所有元素的ElementIds</li>
</ul>
</li>
<li>获取与筛选器匹配的第一个Element或ElementId。<ul>
<li>FirstElement()-返回第一个元素以通过所有应用的过滤器</li>
<li>FirstElementId()-返回第一个元素的id，以通过所有应用的过滤器</li>
</ul>
</li>
<li>获取ElementId或Element迭代器。<ul>
<li>GetElementIdIterator()-将FilteredElementIdIterator返回到通过过滤器的元素id</li>
<li>GetElementIterator()-将FilteredElementIterator返回给通过过滤器的元素</li>
<li>GetEnumerator()-返回一个IEnumerator，它遍历传递元素的集合</li>
</ul>
</li>
</ol>
<p>一次只能使用这些组中的一个方法;如果调用另一个方法来提取元素，收集器将重置。因此，如果您之前已经获得了一个迭代器，那么当您调用另一个方法来提取元素时，它将停止并且不再遍历任何元素。</p>
<p>哪种方法最好取决于应用。如果只需要一个匹配元素，那么FirstElement()或FirstElementId()是最佳选择。如果需要所有匹配的元素，请使用ToElements()。如果需要一个变量，使用迭代器。</p>
<p>如果应用程序将删除元素或对过滤列表中的元素进行重大更改，ToElementIds()或元素id迭代器是最佳选择。这是因为删除元素或对元素进行重大更改会使元素句柄无效。对于元素id，对具有ElementId的Document.GetElement()的调用将始终返回有效的Element（如果元素已被删除，则返回空引用）。</p>
<p>使用ToElements()方法将筛选结果作为元素集合获取，允许使用foreach检查集合中的每个元素，如下所示：</p>
<p>代码区域6-9：使用ToElements()获取筛选结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line">ICollection allLoads = collector.ToElements();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">&quot;The loads in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element loadElem <span class="keyword">in</span> allLoads)</span><br><span class="line">&#123;</span><br><span class="line">        LoadBase load = loadElem <span class="keyword">as</span> LoadBase;</span><br><span class="line">        prompt += load.GetType().Name +  <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                        load.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p>当只需要一个传递元素时，使用FirstElement()：</p>
<p>代码区域6-10：获取第一个通过的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a filter to find all columns</span></span><br><span class="line">StructuralInstanceUsageFilter columnFilter = </span><br><span class="line">        <span class="keyword">new</span> StructuralInstanceUsageFilter(StructuralInstanceUsage.Column);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(columnFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the first column from the filtered results</span></span><br><span class="line"><span class="comment">// Element will be a FamilyInstance</span></span><br><span class="line">FamilyInstance column = collector.FirstElement() <span class="keyword">as</span> FamilyInstance;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，FirstElement()是不够的。下一个示例显示如何使用扩展方法获取第一个非模板3D视图（这对于ReferenceIntersector构造函数的输入很有用）。</p>
<p>代码区域6-11：使用扩展方法获取第一个传递元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use filter to find a non-template 3D view</span></span><br><span class="line"><span class="comment">// This example does not use FirstElement() since first filterd view3D might be a template</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply ElementClassFilter</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use extension methods to get first non-template View3D</span></span><br><span class="line">View3D view3D = collector.Cast().First(isNotTemplate);</span><br></pre></td></tr></table></figure>

<p>The following example demonstrates the use of the FirstElementId() method to get one passing element (a 3d view in this case) and the use of ToElementIds() to get the filter results as a collection of element ids (in order to delete a set of elements in this case).<br>下面的示例演示了使用FirstElementId()方法获取一个传递元素（本例中为3D视图），以及使用ToElementIds()获取作为元素ID集合的过滤结果（本例中为删除一组元素）。</p>
<p>代码区域6-12：使用得到过滤器结果作为元素id</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use shortcut OfClass to get View elements</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Id of the first view</span></span><br><span class="line">ElementId viewId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test if the view is valid for element filtering</span></span><br><span class="line"><span class="keyword">if</span> (FilteredElementCollector.IsViewValidForElementIteration(document, viewId))</span><br><span class="line">&#123;</span><br><span class="line">        FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document, viewId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all FamilyInstance items in the view</span></span><br><span class="line">        viewCollector.OfClass(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line">        ICollection familyInstanceIds = viewCollector.ToElementIds();</span><br><span class="line"></span><br><span class="line">        document.Delete(familyInstanceIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中使用了GetElementIterator()方法，该方法循环访问已筛选的元素以检查某些管道的流状态。</p>
<p>代码区域6-13：以元素迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a filter to get all pipes in the document</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Autodesk.Revit.DB.Plumbing.Pipe));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as an element iterator and look for a pipe with</span></span><br><span class="line"><span class="comment">// a specific flow state</span></span><br><span class="line">FilteredElementIterator elemItr = collector.GetElementIterator();</span><br><span class="line">elemItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (elemItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        Pipe pipe = elemItr.Current <span class="keyword">as</span> Pipe;</span><br><span class="line">        <span class="keyword">if</span> (pipe.FlowState == PipeFlowState.LaminarState)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Model has at least one pipe with Laminar flow state.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，过滤结果可以作为元素id迭代器返回：</p>
<p>代码区域6-14：以元素id迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. </span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as ElementId iterator</span></span><br><span class="line">FilteredElementIdIterator roomIdItr = collector.GetElementIdIterator();</span><br><span class="line">roomIdItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (roomIdItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        ElementId roomId = roomIdItr.Current;</span><br><span class="line">        <span class="comment">// Warn rooms smaller than 50 SF</span></span><br><span class="line">        Room room = document.GetElement(roomId) <span class="keyword">as</span> Room;</span><br><span class="line">        <span class="keyword">if</span> (room.Area &lt; <span class="number">50.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                String prompt = <span class="string">&quot;Room is too small: id = &quot;</span> + roomId.ToString();</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，针对给定的过滤器测试单个元素，而不是获取通过过滤器的所有元素，可能会很有用。ElementFilter.PassesFilter()有两个重载，它们根据筛选器测试给定的Element或ElementId，如果元素通过筛选器，则返回true。</p>
<h2 id="LINQ查询"><a href="#LINQ查询" class="headerlink" title="LINQ查询"></a>LINQ查询</h2><p>在.NET中，FilteredElementCollector类支持Elements的IEEETM接口。您可以将此类与LINQ查询和操作一起使用来处理元素列表。请注意，由于此类提供的ElementFilters和快捷方法在生成托管包装之前处理本机代码中的元素，因此在尝试使用LINQ查询处理结果之前，在收集器上使用尽可能多的本机筛选器将获得更好的性能。</p>
<p>The following example uses an ElementClassFilter to get all FamilyInstance elements in the document, and then uses a LINQ query to narrow down the results to those FamilyInstances with a specific name.<br>下面的示例使用ElementClassFilter获取文档中的所有FamilyInstance元素，然后使用LINQ查询将结果范围缩小到具有特定名称的FamilyInstance。</p>
<p>代码区域6-15：使用LINQ查询</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find family instances whose name is 60&quot; x 30&quot; Student </span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Linq query to find family instances whose name is 60&quot; x 30&quot; Student</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                        <span class="keyword">where</span> element.Name == <span class="string">&quot;60\&quot; x 30\&quot; Student&quot;</span></span><br><span class="line">                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast found elements to family instances, </span></span><br><span class="line"><span class="comment">// this cast to FamilyInstance is safe because ElementClassFilter for FamilyInstance was used</span></span><br><span class="line">List familyInstances = query.Cast().ToList();</span><br></pre></td></tr></table></figure>

<h2 id="边界框过滤器"><a href="#边界框过滤器" class="headerlink" title="边界框过滤器"></a>边界框过滤器</h2><p> BoundingBox过滤器：</p>
<ul>
<li>BoundingBoxIsInsideFilter</li>
<li>BoundingBoxIntersectsFilter</li>
<li>BoundingBoxContainsPointFilter</li>
</ul>
<p>帮助您查找其边界框满足特定条件的元素。您可以检查每个元素的边界框是否在给定体积内，是否与给定体积相交，或者是否包含给定点。也可以反向执行此检查，以查找不与体积相交或不包含给定点的元素。</p>
<p>BoundingBox过滤器使用Outline作为其输入。Outline是一个表示直角棱柱的类，其轴与Revit世界坐标系对齐。</p>
<p>这些过滤器最适合于实际几何形状与其边界框的几何形状紧密匹配的形状。示例可能包括曲线与X或Y方向对齐的线性墙、由此类墙形成的矩形房间、与此类墙对齐的楼板或屋顶，或者合理的矩形族。否则，可能会出现误报，因为元素的边界框可能比实际几何形状大得多。(在这些情况下，您可以使用实际图元的几何图形来确定图元是否真正满足条件）。</p>
<h2 id="元素交叉过滤器"><a href="#元素交叉过滤器" class="headerlink" title="元素交叉过滤器"></a>元素交叉过滤器</h2><p> 元素过滤器：</p>
<ul>
<li>ElementIntersectsElementFilter</li>
<li>ElementIntersectsSolidFilter</li>
</ul>
<p>其实际三维几何体与目标对象的三维几何体相交的过程元素。</p>
<p>使用ElementIntersectsElementFilter，目标对象是另一个元素。交点的确定与Revit在生成冲突报告期间确定是否存在冲突时使用的逻辑相同。(意味着某些图元组合永远不会通过此过滤器，例如在相交处自动连接的混凝土构件，或也从干涉检查中排除的场地图元）。此外，没有实心几何图形的图元（如钢筋）也不会通过此过滤器。</p>
<p>使用ElementIntersectsSolidFilter，目标对象是任何实体。该实体可以从现有图元中获得，使用GeometryCreationUtilities中的例程从头开始创建，或者是布尔运算等二次运算的结果。与ElementIntersectsElementFilter类似，此过滤器不会传递缺少实心几何图形的元素。</p>
<p>两个过滤器都可以反转以匹配目标对象体积之外的元素。</p>
<p>这两个过滤器都是慢速过滤器，因此最好与一个或多个快速过滤器（如类或类别过滤器）组合使用。</p>
<p> 代码区域：使用ElementIntersectsSolidFilter匹配阻止禁用出口到门的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds any Revit physical elements which interfere with the target </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> solid region surrounding a door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This routine is useful for detecting interferences which are </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> violations of the Americans with Disabilities Act or other local disabled </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> access codes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The door instance.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The accessibility region calculated</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> to surround the approach of the door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Because the geometric parameters of this region are code- and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> door-specific, calculation of the geometry of the region is not </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> demonstrated in this example.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A collection of interfering element ids.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ICollection <span class="title">FindElementsInterferingWithDoor</span>(<span class="params">FamilyInstance doorInstance, Solid doorAccessibilityRegion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Setup the filtered element collector for all document elements.</span></span><br><span class="line">   FilteredElementCollector interferingCollector = </span><br><span class="line">      <span class="keyword">new</span> FilteredElementCollector(doorInstance.Document);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only accept element instances</span></span><br><span class="line">   interferingCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exclude intersections with the door itself or the host wall for the door.</span></span><br><span class="line">   List excludedElements = <span class="keyword">new</span> List();</span><br><span class="line">   excludedElements.Add(doorInstance.Id);</span><br><span class="line">   excludedElements.Add(doorInstance.Host.Id);</span><br><span class="line">   ExclusionFilter exclusionFilter = <span class="keyword">new</span> ExclusionFilter(excludedElements);</span><br><span class="line">   interferingCollector.WherePasses(exclusionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set up a filter which matches elements whose solid geometry intersects </span></span><br><span class="line">   <span class="comment">// with the accessibility region</span></span><br><span class="line">   ElementIntersectsSolidFilter intersectionFilter = </span><br><span class="line">      <span class="keyword">new</span> ElementIntersectsSolidFilter(doorAccessibilityRegion);</span><br><span class="line">   interferingCollector.WherePasses(intersectionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return all elements passing the collector</span></span><br><span class="line">   <span class="keyword">return</span> interferingCollector.ToElementIds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>
    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 funtim
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
